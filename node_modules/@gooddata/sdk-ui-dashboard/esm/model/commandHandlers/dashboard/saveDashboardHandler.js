import { __assign, __generator, __rest } from "tslib";
import { selectBasicLayout } from "../../store/layout/layoutSelectors";
import { call, put, select, setContext } from "redux-saga/effects";
import { selectFilterContextDefinition, selectFilterContextIdentity, } from "../../store/filterContext/filterContextSelectors";
import { selectDashboardDescriptor, selectPersistedDashboard } from "../../store/meta/metaSelectors";
import { selectDateFilterConfigOverrides } from "../../store/dateFilterConfig/dateFilterConfigSelectors";
import { batchActions } from "redux-batched-actions";
import { dashboardSaved } from "../../events/dashboard";
import { metaActions } from "../../store/meta";
import { filterContextActions } from "../../store/filterContext";
import { dashboardFilterContextIdentity } from "../../../_staging/dashboard/dashboardFilterContext";
import { invariant } from "ts-invariant";
import { dashboardLayoutRemoveIdentity, dashboardLayoutWidgetIdentityMap, } from "../../../_staging/dashboard/dashboardLayout";
import { isTemporaryIdentity } from "../../utils/dashboardItemUtils";
import { layoutActions } from "../../store/layout";
import { savingActions } from "../../store/saving";
import { selectSettings } from "../../store/config/configSelectors";
import { selectBackendCapabilities } from "../../store/backendCapabilities/backendCapabilitiesSelectors";
function createDashboard(ctx, saveCtx) {
    return ctx.backend.workspace(ctx.workspace).dashboards().createDashboard(saveCtx.dashboardToSave);
}
function updateDashboard(ctx, saveCtx) {
    var persistedDashboard = saveCtx.persistedDashboard, dashboardToSave = saveCtx.dashboardToSave;
    invariant(persistedDashboard);
    return ctx.backend
        .workspace(ctx.workspace)
        .dashboards()
        .updateDashboard(persistedDashboard, dashboardToSave);
}
export function getDashboardWithSharing(dashboard, sharingEnabled, sharingSupported, isNewDashboard) {
    if (sharingEnabled === void 0) { sharingEnabled = false; }
    if (sharingSupported === void 0) { sharingSupported = true; }
    var shareProp = {};
    if (isNewDashboard) {
        var _unusedIsUnderStrictControl = dashboard.isUnderStrictControl, dashboardRest = __rest(dashboard, ["isUnderStrictControl"]);
        shareProp =
            sharingEnabled && sharingSupported
                ? {
                    shareStatus: "private",
                    isUnderStrictControl: true,
                }
                : {
                    shareStatus: "public",
                };
        return __assign(__assign({}, dashboardRest), shareProp);
    }
    return dashboard;
}
/*
 * TODO: custom widget persistence; we need a new backend capability that indicates whether the
 *  backend can persist custom widget content (tiger can already, bear cannot). Based on that
 *  capability, this code should use either the selectBasicLayout (that strips any custom widgets) or
 *  selectLayout (that keeps custom widgets).
 */
function createDashboardSaveContext(cmd, isNewDashboard) {
    var persistedDashboard, dashboardDescriptor, filterContextDefinition, filterContextIdentity, layout, dateFilterConfig, settings, capabilities, dashboardIdentity, pluginsProp, dashboardFromState, dashboardToSave;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, select(selectPersistedDashboard)];
            case 1:
                persistedDashboard = _a.sent();
                return [4 /*yield*/, select(selectDashboardDescriptor)];
            case 2:
                dashboardDescriptor = _a.sent();
                return [4 /*yield*/, select(selectFilterContextDefinition)];
            case 3:
                filterContextDefinition = _a.sent();
                return [4 /*yield*/, select(selectFilterContextIdentity)];
            case 4:
                filterContextIdentity = _a.sent();
                return [4 /*yield*/, select(selectBasicLayout)];
            case 5:
                layout = _a.sent();
                return [4 /*yield*/, select(selectDateFilterConfigOverrides)];
            case 6:
                dateFilterConfig = _a.sent();
                return [4 /*yield*/, select(selectSettings)];
            case 7:
                settings = _a.sent();
                return [4 /*yield*/, select(selectBackendCapabilities)];
            case 8:
                capabilities = _a.sent();
                dashboardIdentity = {
                    ref: persistedDashboard === null || persistedDashboard === void 0 ? void 0 : persistedDashboard.ref,
                    uri: persistedDashboard === null || persistedDashboard === void 0 ? void 0 : persistedDashboard.uri,
                    identifier: persistedDashboard === null || persistedDashboard === void 0 ? void 0 : persistedDashboard.identifier,
                };
                pluginsProp = (persistedDashboard === null || persistedDashboard === void 0 ? void 0 : persistedDashboard.plugins) ? { plugins: persistedDashboard.plugins } : {};
                dashboardFromState = __assign(__assign(__assign(__assign({ type: "IDashboard" }, dashboardDescriptor), dashboardIdentity), { filterContext: __assign(__assign({}, filterContextIdentity), filterContextDefinition), layout: layout,
                    dateFilterConfig: dateFilterConfig }), pluginsProp);
                dashboardToSave = __assign(__assign({}, dashboardFromState), { layout: dashboardLayoutRemoveIdentity(layout, isTemporaryIdentity) });
                return [2 /*return*/, {
                        cmd: cmd,
                        persistedDashboard: persistedDashboard,
                        dashboardFromState: dashboardFromState,
                        dashboardToSave: getDashboardWithSharing(dashboardToSave, settings.enableAnalyticalDashboardPermissions, capabilities.supportsAccessControl, isNewDashboard),
                    }];
        }
    });
}
function save(ctx, saveCtx, saveFn, saveActionName) {
    var dashboard, identityMapping, batch;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, call(saveFn, ctx, saveCtx)];
            case 1:
                dashboard = _a.sent();
                identityMapping = dashboardLayoutWidgetIdentityMap(saveCtx.dashboardFromState.layout, dashboard.layout);
                batch = batchActions([
                    metaActions.setMeta({ dashboard: dashboard }),
                    filterContextActions.updateFilterContextIdentity({
                        filterContextIdentity: dashboardFilterContextIdentity(dashboard),
                    }),
                    layoutActions.updateWidgetIdentities(identityMapping),
                    layoutActions.clearLayoutHistory(),
                ], saveActionName);
                return [2 /*return*/, {
                        batch: batch,
                        dashboard: dashboard,
                    }];
        }
    });
}
export function saveDashboardHandler(ctx, cmd) {
    var persistedDashboard, isNewDashboard, saveCtx, result, dashboard, batch, e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 12, , 14]);
                return [4 /*yield*/, put(savingActions.setSavingStart())];
            case 1:
                _a.sent();
                return [4 /*yield*/, select(selectPersistedDashboard)];
            case 2:
                persistedDashboard = _a.sent();
                isNewDashboard = persistedDashboard === undefined;
                return [4 /*yield*/, call(createDashboardSaveContext, cmd, isNewDashboard)];
            case 3:
                saveCtx = _a.sent();
                result = void 0;
                if (!isNewDashboard) return [3 /*break*/, 5];
                return [4 /*yield*/, call(save, ctx, saveCtx, createDashboard, "@@GDC.DASH.SAVE_NEW")];
            case 4:
                result = _a.sent();
                return [3 /*break*/, 7];
            case 5: return [4 /*yield*/, call(save, ctx, saveCtx, updateDashboard, "@@GDC.DASH.SAVE_EXISTING")];
            case 6:
                result = _a.sent();
                _a.label = 7;
            case 7:
                dashboard = result.dashboard, batch = result.batch;
                return [4 /*yield*/, put(batch)];
            case 8:
                _a.sent();
                if (!isNewDashboard) return [3 /*break*/, 10];
                return [4 /*yield*/, setContext({
                        dashboardContext: __assign(__assign({}, ctx), { dashboardRef: dashboard.ref }),
                    })];
            case 9:
                _a.sent();
                _a.label = 10;
            case 10: return [4 /*yield*/, put(savingActions.setSavingSuccess())];
            case 11:
                _a.sent();
                return [2 /*return*/, dashboardSaved(ctx, dashboard, isNewDashboard, cmd.correlationId)];
            case 12:
                e_1 = _a.sent();
                return [4 /*yield*/, put(savingActions.setSavingError(e_1))];
            case 13:
                _a.sent();
                throw e_1;
            case 14: return [2 /*return*/];
        }
    });
}
//# sourceMappingURL=saveDashboardHandler.js.map