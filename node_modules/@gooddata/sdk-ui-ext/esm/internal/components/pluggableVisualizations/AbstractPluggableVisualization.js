import { __assign } from "tslib";
// (C) 2019 GoodData Corporation
import cloneDeep from "lodash/cloneDeep";
import { EmptyAfmSdkError, isEmptyAfm, } from "../../interfaces/Visualization";
import { findDerivedBucketItem, hasDerivedBucketItems, isDerivedBucketItem } from "../../utils/bucketHelper";
import { insightHasDataDefined, insightProperties } from "@gooddata/sdk-model";
import { DefaultLocale, isGoodDataSdkError, UnexpectedSdkError, } from "@gooddata/sdk-ui";
import { createInternalIntl } from "../../utils/internalIntlProvider";
import { getSupportedProperties } from "../../utils/propertiesHelper";
var AbstractPluggableVisualization = /** @class */ (function () {
    function AbstractPluggableVisualization(props) {
        var _this = this;
        var _a;
        this.getIsError = function () {
            return _this.hasEmptyAfm || _this.hasError;
        };
        //
        // Callback delegates
        //
        this.onError = function (error) {
            var _a, _b;
            (_b = (_a = _this.callbacks).onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);
            // EMPTY_AFM is handled in update as it can change on any render contrary to other error types
            // that have to be set manually or by loading
            if (!isEmptyAfm(error)) {
                _this.hasError = true;
            }
            _this.renderConfigurationPanel(_this.currentInsight);
        };
        this.onLoadingChanged = function (loadingState) {
            var _a, _b;
            (_b = (_a = _this.callbacks).onLoadingChanged) === null || _b === void 0 ? void 0 : _b.call(_a, loadingState);
            _this.hasError = false;
            _this.isLoading = loadingState.isLoading;
            _this.renderConfigurationPanel(_this.currentInsight);
        };
        this.onExportReady = function (exportResult) {
            var _a, _b;
            (_b = (_a = _this.callbacks).onExportReady) === null || _b === void 0 ? void 0 : _b.call(_a, exportResult);
        };
        this.pushData = function (data, options) {
            var _a, _b;
            (_b = (_a = _this.callbacks).pushData) === null || _b === void 0 ? void 0 : _b.call(_a, data, options);
        };
        this.afterRender = function () {
            var _a, _b;
            (_b = (_a = _this.callbacks).afterRender) === null || _b === void 0 ? void 0 : _b.call(_a);
        };
        this.onDrill = function (event) {
            // in case onDrill is not specified, default to always firing drill events
            return _this.callbacks.onDrill ? _this.callbacks.onDrill(event) : true;
        };
        this.callbacks = props.callbacks;
        this.locale = (_a = props.locale) !== null && _a !== void 0 ? _a : DefaultLocale;
        this.intl = createInternalIntl(this.locale);
        this.element = props.element;
        this.configPanelElement = props.configPanelElement;
    }
    //
    // Templated implementation of update contract
    //
    /**
     * Templated implementation of the update method. Given options, insight to render and the execution
     * factory, this function will drive the update process. It consists of the following:
     *
     * 1. call to {@link updateInstanceProperties} - this method should update any internal state
     *    of the instance's properties. Subclasses MAY override this to update state of their own private
     *    properties.
     *
     * 2. call to {@link checkBeforeRender} - this method is called as a hook to perform final check before
     *    the actual rendering is triggered:
     *    - if hook returns true, vis will be rendered
     *    - if hook returns false, vis will not be rendered
     *    - if hook throws an exception, it will be sent via onError callback; vis will not be rendered
     *
     * 3. vis rendering is triggered (unless step 2 determines it should not be)
     *
     * 4. configuration panel is rendered (always)
     *
     * Note: do not override this method.
     *
     * @param options
     * @param insight
     * @param visualizationPropertiesMeta
     * @param executionFactory
     */
    AbstractPluggableVisualization.prototype.update = function (options, insight, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    insightPropertiesMeta, executionFactory) {
        this.updateInstanceProperties(options, insight, insightPropertiesMeta);
        this.hasEmptyAfm = !insightHasDataDefined(insight);
        var shouldRenderVisualization;
        try {
            shouldRenderVisualization = this.checkBeforeRender(insight);
        }
        catch (e) {
            var sdkError = isGoodDataSdkError(e) ? e : new UnexpectedSdkError(undefined, e);
            this.onError(sdkError);
            return;
        }
        if (shouldRenderVisualization) {
            this.renderVisualization(options, insight, executionFactory);
        }
        this.renderConfigurationPanel(insight);
    };
    /**
     * This method will be called during the {@link update} processing. This is where internal properties of the
     * concrete plug vis class MAY be updated. If class overrides this method, it MUST call the method in
     * superclass.
     *
     * @param options - visualization options
     * @param insight - insight that is about to be rendered
     */
    AbstractPluggableVisualization.prototype.updateInstanceProperties = function (
    // @ts-expect-error Ignoring here so that the JSDoc has the proper name (not _options)
    options, insight, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    insightPropertiesMeta) {
        this.visualizationProperties = getSupportedProperties(insightProperties(insight), this.supportedPropertiesList);
        this.propertiesMeta = insightPropertiesMeta !== null && insightPropertiesMeta !== void 0 ? insightPropertiesMeta : null;
        this.currentInsight = insight;
    };
    /**
     * This method will be called during the {@link update} processing. It can be used to influence whether
     * visualization should be rendered and optionally whether particular error should be rendered by the app.
     *
     * @param insight - insight that is about to be rendered
     * @returns when true is returned (default), visualization will be rendered, when false is returned no rendering is done
     * @throws error - if anything is thrown, visualization will not be rendered and the exception will be passed via onError callback
     */
    AbstractPluggableVisualization.prototype.checkBeforeRender = function (insight) {
        if (!insightHasDataDefined(insight)) {
            throw new EmptyAfmSdkError();
        }
        return true;
    };
    //
    // Templated implementation of addNewDerivedBucketItems contract
    //
    AbstractPluggableVisualization.prototype.addNewDerivedBucketItems = function (referencePoint, newDerivedBucketItems) {
        var _this = this;
        if (!referencePoint.buckets) {
            return Promise.resolve(referencePoint);
        }
        var newReferencePoint = cloneDeep(referencePoint);
        newReferencePoint.buckets = referencePoint.buckets.map(function (bucket) {
            return __assign(__assign({}, bucket), { items: _this.mergeDerivedBucketItems(referencePoint, bucket, newDerivedBucketItems) });
        });
        return Promise.resolve(newReferencePoint);
    };
    AbstractPluggableVisualization.prototype.mergeDerivedBucketItems = function (referencePoint, bucket, newDerivedBucketItems) {
        return bucket.items.reduce(function (resultItems, bucketItem) {
            var newDerivedBucketItem = findDerivedBucketItem(bucketItem, newDerivedBucketItems);
            var shouldAddItem = newDerivedBucketItem &&
                !isDerivedBucketItem(bucketItem) &&
                !hasDerivedBucketItems(bucketItem, referencePoint.buckets);
            if (shouldAddItem) {
                resultItems.push(newDerivedBucketItem);
            }
            resultItems.push(bucketItem);
            return resultItems;
        }, []);
    };
    /**
     * Default no-op implementation of the drill down, which just returns the original visualization.
     *
     * @param sourceVisualization drill down source {@link IInsight}
     * @param _drillDownContext drill context (unused in this implementation)
     * @returns the {@code sourceVisualization}
     * @see {@link IVisualization.getInsightWithDrillDownApplied} for more information
     */
    AbstractPluggableVisualization.prototype.getInsightWithDrillDownApplied = function (sourceVisualization, _drillDownContext) {
        return sourceVisualization;
    };
    return AbstractPluggableVisualization;
}());
export { AbstractPluggableVisualization };
//# sourceMappingURL=AbstractPluggableVisualization.js.map