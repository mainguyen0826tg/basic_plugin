import { __awaiter, __extends, __generator, __spreadArrays } from "tslib";
import { decoratedBackend, } from "../decoratedBackend";
import LRUCache from "lru-cache";
import { DecoratedSecuritySettingsService } from "../decoratedBackend/securitySettings";
import { DecoratedExecutionFactory, DecoratedExecutionResult, DecoratedPreparedExecution, DecoratedDataView, } from "../decoratedBackend/execution";
import { DecoratedWorkspaceCatalogFactory } from "../decoratedBackend/catalog";
import stringify from "json-stable-stringify";
import compact from "lodash/compact";
import first from "lodash/first";
import flow from "lodash/flow";
import identity from "lodash/identity";
import invariant from "ts-invariant";
import partition from "lodash/partition";
import { areObjRefsEqual, idRef, isIdentifierRef, isUriRef, uriRef, } from "@gooddata/sdk-model";
import { DecoratedWorkspaceAttributesService } from "../decoratedBackend/attributes";
//
// Execution caching
//
var WithExecutionCaching = /** @class */ (function (_super) {
    __extends(WithExecutionCaching, _super);
    function WithExecutionCaching(decorated, ctx) {
        var _this = _super.call(this, decorated) || this;
        _this.ctx = ctx;
        _this.execute = function () { return __awaiter(_this, void 0, void 0, function () {
            var cacheKey, cache, cacheEntry, result, _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        cacheKey = this.fingerprint();
                        cache = this.ctx.caches.execution;
                        cacheEntry = cache.get(cacheKey);
                        if (!cacheEntry) {
                            result = _super.prototype.execute.call(this)
                                .then(function (res) {
                                return new WithExecutionResultCaching(res, _this.createNew, _this.ctx);
                            })
                                .catch(function (e) {
                                cache.del(cacheKey);
                                throw e;
                            });
                            cacheEntry = { result: result };
                            cache.set(cacheKey, cacheEntry);
                        }
                        _a = DefinitionSanitizingExecutionResult.bind;
                        return [4 /*yield*/, cacheEntry.result];
                    case 1: return [2 /*return*/, new (_a.apply(DefinitionSanitizingExecutionResult, [void 0, _b.sent(), this.createNew,
                            this.definition]))()];
                }
            });
        }); };
        _this.createNew = function (decorated) {
            return new WithExecutionCaching(decorated, _this.ctx);
        };
        return _this;
    }
    return WithExecutionCaching;
}(DecoratedPreparedExecution));
/**
 * This DataView decorator makes sure that definition used in it is the same as the definition in the result.
 *
 * See the usage of this class in {@link DefinitionSanitizingExecutionResult} for more.
 */
var DefinitionSanitizingDataView = /** @class */ (function (_super) {
    __extends(DefinitionSanitizingDataView, _super);
    function DefinitionSanitizingDataView(decorated, result) {
        var _this = _super.call(this, decorated, result) || this;
        _this.definition = result.definition;
        return _this;
    }
    return DefinitionSanitizingDataView;
}(DecoratedDataView));
/**
 * This ExecutionResult decorator makes sure that definitions used throughout the result are set
 * to the definitionOverride provided. This is useful with caching because different definitions may yield
 * the same cache key, but having the proper definition in the returned execution result is critical:
 * the definitions in the result must match the one which was used to request it.
 * This however is not always the case when using cached results, so we need to ensure it explicitly.
 *
 * See the usage of this class in {@link WithExecutionCaching} for more.
 */
var DefinitionSanitizingExecutionResult = /** @class */ (function (_super) {
    __extends(DefinitionSanitizingExecutionResult, _super);
    function DefinitionSanitizingExecutionResult(decorated, wrapper, definitionOverride) {
        var _this = _super.call(this, decorated, wrapper) || this;
        _this.readAll = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.withSanitizedDefinition;
                        return [4 /*yield*/, _super.prototype.readAll.call(this)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        }); };
        _this.readWindow = function (offset, size) { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.withSanitizedDefinition;
                        return [4 /*yield*/, _super.prototype.readWindow.call(this, offset, size)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        }); };
        _this.withSanitizedDefinition = function (original) {
            return new DefinitionSanitizingDataView(original, _this);
        };
        _this.definition = definitionOverride;
        return _this;
    }
    return DefinitionSanitizingExecutionResult;
}(DecoratedExecutionResult));
function windowKey(offset, size) {
    return "o(" + offset.join(",") + ")_s(" + size.join(",") + ")";
}
var WithExecutionResultCaching = /** @class */ (function (_super) {
    __extends(WithExecutionResultCaching, _super);
    function WithExecutionResultCaching(decorated, wrapper, ctx) {
        var _this = _super.call(this, decorated, wrapper) || this;
        _this.ctx = ctx;
        _this.readAll = function () {
            if (!_this.allData) {
                _this.allData = _super.prototype.readAll.call(_this).catch(function (e) {
                    _this.allData = undefined;
                    throw e;
                });
            }
            return _this.allData;
        };
        _this.readWindow = function (offset, size) {
            if (!_this.windows) {
                return _super.prototype.readWindow.call(_this, offset, size);
            }
            var cacheKey = windowKey(offset, size);
            var window = _this.windows.get(cacheKey);
            if (!window) {
                window = _super.prototype.readWindow.call(_this, offset, size).catch(function (e) {
                    if (_this.windows) {
                        _this.windows.del(cacheKey);
                    }
                    throw e;
                });
                _this.windows.set(cacheKey, window);
            }
            return window;
        };
        if (cachingEnabled(_this.ctx.config.maxResultWindows)) {
            _this.windows = new LRUCache({ max: _this.ctx.config.maxResultWindows });
        }
        return _this;
    }
    return WithExecutionResultCaching;
}(DecoratedExecutionResult));
//
// Catalog caching
//
function optionsKey(options) {
    return stringify(options);
}
var WithCatalogCaching = /** @class */ (function (_super) {
    __extends(WithCatalogCaching, _super);
    function WithCatalogCaching(decorated, ctx) {
        var _this = _super.call(this, decorated) || this;
        _this.ctx = ctx;
        _this.load = function () {
            var cache = _this.getOrCreateWorkspaceEntry(_this.workspace).catalogForOptions;
            var cacheKey = optionsKey(_this.options);
            var catalog = cache.get(cacheKey);
            if (!catalog) {
                catalog = _super.prototype.load.call(_this).catch(function (e) {
                    cache.del(cacheKey);
                    throw e;
                });
                cache.set(cacheKey, catalog);
            }
            return catalog;
        };
        _this.createNew = function (decorated) {
            return new WithCatalogCaching(decorated, _this.ctx);
        };
        _this.getOrCreateWorkspaceEntry = function (workspace) {
            var cache = _this.ctx.caches.workspaceCatalogs;
            var cacheEntry = cache.get(workspace);
            if (!cacheEntry) {
                cacheEntry = {
                    catalogForOptions: new LRUCache({
                        max: _this.ctx.config.maxCatalogOptions,
                    }),
                };
                cache.set(workspace, cacheEntry);
            }
            return cacheEntry;
        };
        return _this;
    }
    return WithCatalogCaching;
}(DecoratedWorkspaceCatalogFactory));
//
// Organization security settings caching
//
function validUrlInContextKey(url, context) {
    return context + "_" + stringify(url);
}
var WithSecuritySettingsCaching = /** @class */ (function (_super) {
    __extends(WithSecuritySettingsCaching, _super);
    function WithSecuritySettingsCaching(decorated, ctx) {
        var _this = _super.call(this, decorated) || this;
        _this.ctx = ctx;
        _this.isUrlValid = function (url, context) {
            var cache = _this.getOrCreateSecuritySettingsEntry(_this.scope).valid;
            var cacheKey = validUrlInContextKey(url, context);
            var result = cache.get(cacheKey);
            if (!result) {
                result = _super.prototype.isUrlValid.call(_this, url, context).catch(function (e) {
                    cache.del(cacheKey);
                    throw e;
                });
                cache.set(cacheKey, result);
            }
            return result;
        };
        _this.isDashboardPluginUrlValid = function (url, workspace) {
            var scope = "plugins_" + workspace;
            var cache = _this.getOrCreateSecuritySettingsEntry(scope).valid;
            var result = cache.get(url);
            if (!result) {
                result = _super.prototype.isDashboardPluginUrlValid.call(_this, url, workspace).catch(function (e) {
                    cache.del(url);
                    throw e;
                });
                cache.set(url, result);
            }
            return result;
        };
        _this.getOrCreateSecuritySettingsEntry = function (scope) {
            var cache = _this.ctx.caches.securitySettings;
            var cacheEntry = cache.get(scope);
            if (!cacheEntry) {
                cacheEntry = {
                    valid: new LRUCache({
                        max: _this.ctx.config.maxSecuritySettingsOrgUrls,
                        maxAge: _this.ctx.config.maxSecuritySettingsOrgUrlsAge,
                    }),
                };
                cache.set(scope, cacheEntry);
            }
            return cacheEntry;
        };
        return _this;
    }
    return WithSecuritySettingsCaching;
}(DecoratedSecuritySettingsService));
//
// Attributes caching
//
function refMatchesMdObject(ref, mdObject, type) {
    return (areObjRefsEqual(ref, mdObject.ref) ||
        areObjRefsEqual(ref, idRef(mdObject.id, type)) ||
        areObjRefsEqual(ref, uriRef(mdObject.uri)));
}
var firstDefined = flow(compact, first);
var WithAttributesCaching = /** @class */ (function (_super) {
    __extends(WithAttributesCaching, _super);
    function WithAttributesCaching(decorated, ctx, workspace) {
        var _this = _super.call(this, decorated) || this;
        _this.ctx = ctx;
        _this.workspace = workspace;
        _this.getAttributeDisplayForm = function (ref) {
            var cache = _this.getOrCreateWorkspaceEntry(_this.workspace).displayForms;
            var idCacheKey = isIdentifierRef(ref) ? ref.identifier : undefined;
            var uriCacheKey = isUriRef(ref) ? ref.uri : undefined;
            var cacheItem = firstDefined([idCacheKey, uriCacheKey].map(function (key) { return key && cache.get(key); }));
            if (!cacheItem) {
                cacheItem = _super.prototype.getAttributeDisplayForm.call(_this, ref).catch(function (e) {
                    if (idCacheKey) {
                        cache.del(idCacheKey);
                    }
                    if (uriCacheKey) {
                        cache.del(uriCacheKey);
                    }
                    throw e;
                });
                if (idCacheKey) {
                    cache.set(idCacheKey, cacheItem);
                }
                if (uriCacheKey) {
                    cache.set(uriCacheKey, cacheItem);
                }
            }
            return cacheItem;
        };
        _this.getAttributeDisplayForms = function (refs) { return __awaiter(_this, void 0, void 0, function () {
            var cache, refsWithCacheResults, _a, withCacheHits, withoutCacheHits, _b, alreadyInCache, loadedFromServer, candidates;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        cache = this.getOrCreateWorkspaceEntry(this.workspace).displayForms;
                        refsWithCacheResults = refs.map(function (ref) {
                            var idCacheKey = isIdentifierRef(ref) ? ref.identifier : undefined;
                            var uriCacheKey = isUriRef(ref) ? ref.uri : undefined;
                            var cacheHit = firstDefined([idCacheKey, uriCacheKey].map(function (key) { return key && cache.get(key); }));
                            return { ref: ref, cacheHit: cacheHit };
                        });
                        _a = partition(refsWithCacheResults, function (_a) {
                            var cacheHit = _a.cacheHit;
                            return !!cacheHit;
                        }), withCacheHits = _a[0], withoutCacheHits = _a[1];
                        return [4 /*yield*/, Promise.all([
                                // await the stuff from cache, we need the data available (we cannot just return the promises)
                                Promise.all(withCacheHits.map(function (item) { return item.cacheHit; })),
                                // load items not in cache using the bulk operation
                                this.decorated.getAttributeDisplayForms(withoutCacheHits.map(function (item) { return item.ref; })),
                            ])];
                    case 1:
                        _b = _c.sent(), alreadyInCache = _b[0], loadedFromServer = _b[1];
                        // save newly loaded to cache for future reference
                        loadedFromServer.forEach(function (loaded) {
                            var promisifiedResult = Promise.resolve(loaded);
                            // save the cache item for both types of refs
                            cache.set(loaded.id, promisifiedResult);
                            cache.set(loaded.uri, promisifiedResult);
                        });
                        candidates = __spreadArrays(loadedFromServer, alreadyInCache);
                        return [2 /*return*/, refs.map(function (ref) {
                                var match = candidates.find(function (item) { return refMatchesMdObject(ref, item, "displayForm"); });
                                // if this bombs, some data got lost in the process
                                invariant(match);
                                return match;
                            })];
                }
            });
        }); };
        _this.getOrCreateWorkspaceEntry = function (workspace) {
            var cache = _this.ctx.caches.workspaceAttributes;
            var cacheEntry = cache.get(workspace);
            if (!cacheEntry) {
                cacheEntry = {
                    displayForms: new LRUCache({
                        max: _this.ctx.config.maxAttributeDisplayFormsPerWorkspace,
                    }),
                };
                cache.set(workspace, cacheEntry);
            }
            return cacheEntry;
        };
        return _this;
    }
    return WithAttributesCaching;
}(DecoratedWorkspaceAttributesService));
//
//
//
function cachedExecutions(ctx) {
    return function (original) {
        return new DecoratedExecutionFactory(original, function (execution) { return new WithExecutionCaching(execution, ctx); });
    };
}
function cachedCatalog(ctx) {
    return function (original) { return new WithCatalogCaching(original, ctx); };
}
function cachedSecuritySettings(ctx) {
    return function (original) { return new WithSecuritySettingsCaching(original, ctx); };
}
function cachedAttributes(ctx) {
    return function (original, workspace) { return new WithAttributesCaching(original, ctx, workspace); };
}
function cachingEnabled(desiredSize) {
    return desiredSize !== undefined && desiredSize > 0;
}
function cacheControl(ctx) {
    var control = {
        resetExecutions: function () {
            var _a;
            (_a = ctx.caches.execution) === null || _a === void 0 ? void 0 : _a.reset();
        },
        resetCatalogs: function () {
            var _a;
            (_a = ctx.caches.workspaceCatalogs) === null || _a === void 0 ? void 0 : _a.reset();
        },
        resetSecuritySettings: function () {
            var _a;
            (_a = ctx.caches.securitySettings) === null || _a === void 0 ? void 0 : _a.reset();
        },
        resetAttributes: function () {
            var _a;
            (_a = ctx.caches.workspaceAttributes) === null || _a === void 0 ? void 0 : _a.reset();
        },
        resetAll: function () {
            control.resetExecutions();
            control.resetCatalogs();
            control.resetSecuritySettings();
            control.resetAttributes();
        },
    };
    return control;
}
function assertPositiveOrUndefined(value, valueName) {
    invariant(value === undefined || value > 0, valueName + " to cache must be positive or undefined, got: " + value);
}
/**
 * @beta
 */
export var DefaultCachingConfiguration = {
    maxExecutions: 10,
    maxResultWindows: 5,
    maxCatalogs: 1,
    maxCatalogOptions: 50,
    maxSecuritySettingsOrgs: 3,
    maxSecuritySettingsOrgUrls: 100,
    maxSecuritySettingsOrgUrlsAge: 300000,
    maxAttributeWorkspaces: 1,
    maxAttributeDisplayFormsPerWorkspace: 100,
};
/**
 * Adds caching layer on top of an existing analytical backend instance. It is currently possible to cache
 * results of executions and the workspace LDM catalog.
 *
 * @remarks see {@link CachingConfiguration} properties for more information.
 * @param realBackend - real backend to decorate with caching
 * @param config - caching configuration
 * @beta
 */
export function withCaching(realBackend, config) {
    if (config === void 0) { config = DefaultCachingConfiguration; }
    assertPositiveOrUndefined(config.maxCatalogOptions, "maxCatalogOptions");
    assertPositiveOrUndefined(config.maxSecuritySettingsOrgUrls, "maxSecuritySettingsOrgUrls");
    assertPositiveOrUndefined(config.maxSecuritySettingsOrgUrlsAge, "maxSecuritySettingsOrgUrlsAge");
    var execCaching = cachingEnabled(config.maxExecutions);
    var catalogCaching = cachingEnabled(config.maxCatalogs);
    var securitySettingsCaching = cachingEnabled(config.maxSecuritySettingsOrgs);
    var attributeCaching = cachingEnabled(config.maxAttributeWorkspaces);
    var ctx = {
        caches: {
            execution: execCaching ? new LRUCache({ max: config.maxExecutions }) : undefined,
            workspaceCatalogs: catalogCaching ? new LRUCache({ max: config.maxCatalogs }) : undefined,
            securitySettings: securitySettingsCaching
                ? new LRUCache({ max: config.maxSecuritySettingsOrgs })
                : undefined,
            workspaceAttributes: attributeCaching
                ? new LRUCache({ max: config.maxAttributeWorkspaces })
                : undefined,
        },
        config: config,
    };
    var execution = execCaching ? cachedExecutions(ctx) : identity;
    var catalog = catalogCaching ? cachedCatalog(ctx) : identity;
    var securitySettings = securitySettingsCaching ? cachedSecuritySettings(ctx) : identity;
    var attributes = attributeCaching ? cachedAttributes(ctx) : identity;
    if (config.onCacheReady) {
        config.onCacheReady(cacheControl(ctx));
    }
    return decoratedBackend(realBackend, { execution: execution, catalog: catalog, securitySettings: securitySettings, attributes: attributes });
}
//# sourceMappingURL=index.js.map