import { GdcMetadata } from "../meta/GdcMetadata";
/**
 * @public
 */
export declare namespace GdcVisualizationObject {
    type SortDirection = "asc" | "desc";
    type Identifier = string;
    type MeasureAggregation = "sum" | "count" | "avg" | "min" | "max" | "median" | "runsum";
    type TotalType = "sum" | "avg" | "max" | "min" | "nat" | "med";
    type VisualizationType = "table" | "line" | "column" | "bar" | "pie" | "doughnut" | "combo" | "area";
    type ArithmeticMeasureOperator = "sum" | "difference" | "multiplication" | "ratio" | "change";
    type BucketItem = IMeasure | IAttribute;
    type ExtendedFilter = Filter | IMeasureValueFilter | IRankingFilter;
    type Filter = DateFilter | AttributeFilter;
    type DateFilter = IRelativeDateFilter | IAbsoluteDateFilter;
    type AttributeFilter = IPositiveAttributeFilter | INegativeAttributeFilter;
    interface IObjUriQualifier {
        uri: string;
    }
    interface IObjIdentifierQualifier {
        identifier: string;
    }
    type ObjQualifier = IObjUriQualifier | IObjIdentifierQualifier;
    function isObjUriQualifier(objQualifier: ObjQualifier): objQualifier is IObjUriQualifier;
    function isObjIdentifierQualifier(objQualifier: ObjQualifier): objQualifier is IObjIdentifierQualifier;
    interface IPositiveAttributeFilter {
        positiveAttributeFilter: {
            displayForm: ObjQualifier;
            in: string[];
        };
    }
    interface INegativeAttributeFilter {
        negativeAttributeFilter: {
            displayForm: ObjQualifier;
            notIn: string[];
        };
    }
    interface IAbsoluteDateFilter {
        absoluteDateFilter: {
            dataSet: ObjQualifier;
            from?: string;
            to?: string;
        };
    }
    interface IRelativeDateFilter {
        relativeDateFilter: {
            dataSet: ObjQualifier;
            granularity: string;
            from?: number;
            to?: number;
        };
    }
    type ComparisonConditionOperator = "GREATER_THAN" | "GREATER_THAN_OR_EQUAL_TO" | "LESS_THAN" | "LESS_THAN_OR_EQUAL_TO" | "EQUAL_TO" | "NOT_EQUAL_TO";
    interface IComparisonCondition {
        comparison: {
            operator: ComparisonConditionOperator;
            value: number;
            treatNullValuesAs?: number;
        };
    }
    type RangeConditionOperator = "BETWEEN" | "NOT_BETWEEN";
    interface IRangeCondition {
        range: {
            operator: RangeConditionOperator;
            from: number;
            to: number;
            treatNullValuesAs?: number;
        };
    }
    type MeasureValueFilterCondition = IComparisonCondition | IRangeCondition;
    interface ILocalIdentifierQualifier {
        localIdentifier: string;
    }
    interface IMeasureValueFilter {
        measureValueFilter: {
            measure: IObjUriQualifier | ILocalIdentifierQualifier;
            condition?: MeasureValueFilterCondition;
        };
    }
    type RankingFilterOperator = "TOP" | "BOTTOM";
    interface IRankingFilter {
        rankingFilter: {
            measures: (IObjUriQualifier | ILocalIdentifierQualifier)[];
            attributes?: (IObjUriQualifier | ILocalIdentifierQualifier)[];
            operator: RankingFilterOperator;
            value: number;
        };
    }
    interface IVisualizationObjectContent {
        visualizationClass: IObjUriQualifier;
        buckets: IBucket[];
        filters?: ExtendedFilter[];
        properties?: string;
        references?: IReferenceItems;
    }
    interface IReferenceItems {
        [identifier: string]: string;
    }
    interface IBucket {
        localIdentifier?: Identifier;
        items: BucketItem[];
        totals?: ITotal[];
    }
    interface ITotal {
        type: TotalType;
        measureIdentifier: string;
        attributeIdentifier: string;
        alias?: string;
    }
    type IMeasureDefinitionType = IMeasureDefinition | IArithmeticMeasureDefinition | IPoPMeasureDefinition | IPreviousPeriodMeasureDefinition;
    interface IMeasure {
        measure: IMeasureContent;
    }
    interface IMeasureContent {
        localIdentifier: Identifier;
        definition: IMeasureDefinitionType;
        alias?: string;
        title?: string;
        format?: string;
    }
    interface IAttribute {
        visualizationAttribute: IVisualizationAttributeContent;
    }
    interface IVisualizationAttributeContent {
        localIdentifier: Identifier;
        displayForm: ObjQualifier;
        alias?: string;
    }
    interface IMeasureDefinition {
        measureDefinition: {
            item: ObjQualifier;
            aggregation?: MeasureAggregation;
            filters?: Filter[];
            computeRatio?: boolean;
        };
    }
    interface IArithmeticMeasureDefinition {
        arithmeticMeasure: {
            measureIdentifiers: Identifier[];
            operator: ArithmeticMeasureOperator;
        };
    }
    interface IPoPMeasureDefinition {
        popMeasureDefinition: {
            measureIdentifier: Identifier;
            popAttribute: ObjQualifier;
        };
    }
    interface IPreviousPeriodMeasureDefinition {
        previousPeriodMeasure: {
            measureIdentifier: Identifier;
            dateDataSets: IPreviousPeriodDateDataSet[];
        };
    }
    interface IPreviousPeriodDateDataSet {
        dataSet: ObjQualifier;
        periodsAgo: number;
    }
    interface IVisualizationObject {
        meta: GdcMetadata.IObjectMeta;
        content: IVisualizationObjectContent;
    }
    interface IVisualization {
        visualizationObject: IVisualizationObject;
    }
    interface IVisualizationObjectResponse {
        visualizationObject: IVisualizationObject;
    }
    function isVisualization(obj: unknown): obj is IVisualization;
    function isMeasure(bucketItem: IMeasure | IAttribute): bucketItem is IMeasure;
    function isAttribute(bucketItem: IMeasure | IAttribute): bucketItem is IAttribute;
    function isMeasureDefinition(definition: IMeasureDefinitionType): definition is IMeasureDefinition;
    function isArithmeticMeasureDefinition(definition: IMeasureDefinitionType): definition is IArithmeticMeasureDefinition;
    function isPopMeasureDefinition(definition: IMeasureDefinitionType): definition is IPoPMeasureDefinition;
    function isPreviousPeriodMeasureDefinition(definition: IMeasureDefinitionType): definition is IPreviousPeriodMeasureDefinition;
    function isAttributeFilter(filter: ExtendedFilter): filter is AttributeFilter;
    function isDateFilter(filter: ExtendedFilter): filter is DateFilter;
    function isPositiveAttributeFilter(filter: AttributeFilter): filter is IPositiveAttributeFilter;
    function isNegativeAttributeFilter(filter: AttributeFilter): filter is INegativeAttributeFilter;
    function isMeasureValueFilter(filter: ExtendedFilter): filter is IMeasureValueFilter;
    function isRankingFilter(filter: ExtendedFilter): filter is IRankingFilter;
    function isAbsoluteDateFilter(filter: DateFilter): filter is IAbsoluteDateFilter;
    function isRelativeDateFilter(filter: DateFilter): filter is IRelativeDateFilter;
    function isLocalIdentifierQualifier(objectQualifier: unknown): objectQualifier is ILocalIdentifierQualifier;
    function isComparisonCondition(condition: MeasureValueFilterCondition): condition is IComparisonCondition;
    function isRangeCondition(condition: MeasureValueFilterCondition): condition is IRangeCondition;
}
//# sourceMappingURL=GdcVisualizationObject.d.ts.map