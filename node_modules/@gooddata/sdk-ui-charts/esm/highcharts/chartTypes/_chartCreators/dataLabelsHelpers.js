// (C) 2007-2021 GoodData Corporation
import flatMap from "lodash/flatMap";
import { isStacked, isIntersecting, pointInRange, } from "./helpers";
import { isAreaChart, isOneOfTypes } from "../_util/common";
import { BLACK_LABEL, WHITE_LABEL, whiteDataLabelTypes } from "../../constants/label";
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function isLabelOverlappingItsShape(point) {
    var dataLabel = point.dataLabel, shapeArgs = point.shapeArgs;
    if (dataLabel && shapeArgs) {
        // shapeArgs for point hidden by legend is undefined
        if (shapeArgs.width === undefined) {
            return dataLabel.width > shapeArgs.r * 2 || dataLabel.height > shapeArgs.r * 2;
        }
        return dataLabel.width > shapeArgs.width || dataLabel.height > shapeArgs.height;
    }
    return false;
}
export var getDataLabelsGdcVisible = function (chart) { var _a, _b, _c, _d, _e; return (_e = (_d = (_c = (_b = (_a = chart === null || chart === void 0 ? void 0 : chart.options) === null || _a === void 0 ? void 0 : _a.plotOptions) === null || _b === void 0 ? void 0 : _b.gdcOptions) === null || _c === void 0 ? void 0 : _c.dataLabels) === null || _d === void 0 ? void 0 : _d.visible) !== null && _e !== void 0 ? _e : "auto"; };
var isLabelsStackedFromYAxis = function (chart) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    return ((_e = (_d = (_c = (_b = (_a = chart === null || chart === void 0 ? void 0 : chart.userOptions) === null || _a === void 0 ? void 0 : _a.yAxis) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.stackLabels) === null || _d === void 0 ? void 0 : _d.enabled) !== null && _e !== void 0 ? _e : false) ||
        ((_k = (_j = (_h = (_g = (_f = chart === null || chart === void 0 ? void 0 : chart.userOptions) === null || _f === void 0 ? void 0 : _f.yAxis) === null || _g === void 0 ? void 0 : _g[1]) === null || _h === void 0 ? void 0 : _h.stackLabels) === null || _j === void 0 ? void 0 : _j.enabled) !== null && _k !== void 0 ? _k : false);
};
export var areLabelsStacked = function (chart) {
    return isLabelsStackedFromYAxis(chart) && isStacked(chart);
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var hasDataLabel = function (point) { return !!point.dataLabel; };
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var hasShape = function (point) { return !!point.shapeArgs; };
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var hasLabelInside = function (point) {
    var _a, _b, _c;
    var verticalAlign = (_c = (_b = (_a = point === null || point === void 0 ? void 0 : point.dataLabel) === null || _a === void 0 ? void 0 : _a.alignOptions) === null || _b === void 0 ? void 0 : _b.verticalAlign) !== null && _c !== void 0 ? _c : "";
    return verticalAlign === "middle";
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var minimizeDataLabel = function (point) {
    var dataLabel = point.dataLabel;
    if (dataLabel) {
        dataLabel.width = 0;
        dataLabel.height = 0;
    }
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var hideDataLabel = function (point) {
    var dataLabel = point.dataLabel;
    if (dataLabel) {
        dataLabel.hide();
    }
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var showDataLabel = function (point) {
    var dataLabel = point.dataLabel;
    if (dataLabel) {
        dataLabel.show();
    }
};
export var hideDataLabels = function (points) {
    points.filter(hasDataLabel).forEach(hideDataLabel);
};
export var showDataLabels = function (points) {
    points.filter(hasDataLabel).forEach(showDataLabel);
};
export function showDataLabelInAxisRange(
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
point, value, axisRangeForAxes) {
    var _a, _b, _c;
    var isSecondAxis = (_c = (_b = (_a = point === null || point === void 0 ? void 0 : point.series) === null || _a === void 0 ? void 0 : _a.yAxis) === null || _b === void 0 ? void 0 : _b.opposite) !== null && _c !== void 0 ? _c : false;
    var axisRange = axisRangeForAxes[isSecondAxis ? "second" : "first"];
    var isInsideAxisRange = pointInRange(value, axisRange);
    if (!isInsideAxisRange) {
        hideDataLabel(point);
    }
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function showStackLabelInAxisRange(point, axisRangeForAxes) {
    var _a, _b, _c;
    var isSecondAxis = (_c = (_b = (_a = point.series) === null || _a === void 0 ? void 0 : _a.yAxis) === null || _b === void 0 ? void 0 : _b.opposite) !== null && _c !== void 0 ? _c : false;
    var axisRange = axisRangeForAxes[isSecondAxis ? "second" : "first"];
    var end = point.stackY || point.total;
    var start = end - point.y;
    var isWholeUnderMin = start <= axisRange.minAxisValue && end <= axisRange.minAxisValue;
    var isWholeAboveMax = start >= axisRange.maxAxisValue && end >= axisRange.maxAxisValue;
    if (isWholeUnderMin || isWholeAboveMax) {
        hideDataLabel(point);
    }
}
export var hideAllLabels = function (_a) {
    var series = _a.series;
    return hideDataLabels(flatMap(series, function (s) { return s.points; }));
};
export var showAllLabels = function (_a) {
    var series = _a.series;
    return showDataLabels(flatMap(series, function (s) { return s.points; }));
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function getDataLabelAttributes(point) {
    var _a, _b, _c;
    var dataLabel = (_a = point === null || point === void 0 ? void 0 : point.dataLabel) !== null && _a !== void 0 ? _a : null;
    var parentGroup = (_c = (_b = point === null || point === void 0 ? void 0 : point.dataLabel) === null || _b === void 0 ? void 0 : _b.parentGroup) !== null && _c !== void 0 ? _c : null;
    var labelSafeOffset = -100; // labels outside axis range have typically -9999, hide them
    var labelVisible = dataLabel && dataLabel.x > labelSafeOffset && dataLabel.y > labelSafeOffset;
    if (dataLabel && parentGroup && labelVisible) {
        return {
            x: dataLabel.x + parentGroup.translateX,
            y: dataLabel.y + parentGroup.translateY,
            width: dataLabel.width,
            height: dataLabel.height,
        };
    }
    return {
        x: 0,
        y: 0,
        width: 0,
        height: 0,
    };
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function intersectsParentLabel(point, points) {
    var pointParent = parseInt(point.parent, 10);
    // Highchart 7 doesn't render dataLabel at points which have null value
    var pointLabelShape = point.dataLabel;
    if (isNaN(pointParent) || !pointLabelShape) {
        return false;
    }
    var parentPoint = points[pointParent];
    var parentLabelShape = parentPoint.dataLabel;
    return isIntersecting(pointLabelShape, parentLabelShape);
}
function isTruncatedByMin(shape, chart) {
    return shape.y + shape.height > chart.clipBox.height;
}
function isTruncatedByMax(shape) {
    return shape.y < 0;
}
// works for both column/bar chart thanks bar's 90deg rotation
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function getShapeVisiblePart(shape, chart, wholeSize) {
    if (isTruncatedByMax(shape)) {
        return shape.y + shape.height;
    }
    else if (isTruncatedByMin(shape, chart)) {
        return chart.clipBox.height - shape.y;
    }
    return wholeSize;
}
export function getLabelStyle(type, stacking) {
    if (isAreaChart(type)) {
        return BLACK_LABEL;
    }
    return stacking || isOneOfTypes(type, whiteDataLabelTypes) ? WHITE_LABEL : BLACK_LABEL;
}
/**
 * A callback function to format data label and `this` is required by Highchart
 * Ref: https://api.highcharts.com/highcharts/yAxis.labels.formatter
 */
export function formatAsPercent(unit) {
    if (unit === void 0) { unit = 100; }
    var val = parseFloat((this.value * unit).toPrecision(14));
    return val + "%";
}
export function isInPercent(format) {
    if (format === void 0) { format = ""; }
    return format.includes("%");
}
export function getLabelsVisibilityConfig(visible) {
    switch (visible) {
        case "auto":
            return {
                enabled: true,
                allowOverlap: false,
            };
        case true:
            return {
                enabled: true,
                allowOverlap: true,
            };
        case false:
            return {
                enabled: false,
            };
        default:
            // keep decision on each chart for `undefined`
            return {};
    }
}
//# sourceMappingURL=dataLabelsHelpers.js.map