import { __assign } from "tslib";
// (C) 2007-2021 GoodData Corporation
import { isMeasure, insightMeasures, measureMasterIdentifier, isPoPMeasure, isPreviousPeriodMeasure, isArithmeticMeasure, isSimpleMeasure, measureLocalId, measureAlias, measureTitle, measureArithmeticOperands, measureArithmeticOperator, insightBuckets, bucketItems, } from "@gooddata/sdk-model";
import { stringUtils } from "@gooddata/util";
import { DerivedMeasureTitleSuffixFactory } from "./DerivedMeasureTitleSuffixFactory";
import { ArithmeticMeasureTitleFactory } from "./ArithmeticMeasureTitleFactory";
import { OverTimeComparisonTypes } from "../interfaces/OverTimeComparison";
var DEFAULT_MAX_ARITHMETIC_MEASURE_TITLE_LENGTH = 50;
function findOverTimeComparisonType(measure) {
    if (isPoPMeasure(measure)) {
        return OverTimeComparisonTypes.SAME_PERIOD_PREVIOUS_YEAR;
    }
    else if (isPreviousPeriodMeasure(measure)) {
        return OverTimeComparisonTypes.PREVIOUS_PERIOD;
    }
    return OverTimeComparisonTypes.NOTHING;
}
function containsMeasureTitleItem(measureTitleProps, localIdentifier) {
    return measureTitleProps.some(function (prop) { return prop.localIdentifier === localIdentifier; });
}
function containsMeasureTitleItems(measureTitleProps, localIdentifiers) {
    return localIdentifiers.every(function (identifier) { return containsMeasureTitleItem(measureTitleProps, identifier); });
}
function findMeasureTitleItem(measureTitles, localIdentifier) {
    return measureTitles.find(function (prop) { return prop.localIdentifier === localIdentifier; }) || null;
}
function findTitleForDerivedMeasure(measure, measureTitleProps, suffixFactory) {
    var masterMeasureIdentifier = measureMasterIdentifier(measure);
    if (!masterMeasureIdentifier) {
        return undefined;
    }
    var measureProps = findMeasureTitleItem(measureTitleProps, masterMeasureIdentifier);
    if (measureProps === null) {
        return undefined;
    }
    var derivedMeasureTitleBase = measureProps.alias || measureProps.title || "";
    var overTimeComparisonType = findOverTimeComparisonType(measure);
    return derivedMeasureTitleBase + suffixFactory.getSuffix(overTimeComparisonType);
}
function buildMeasureTitle(measure) {
    if (isSimpleMeasure(measure)) {
        var alias = measureAlias(measure);
        var localIdentifier = measureLocalId(measure);
        var title = measureTitle(measure);
        return {
            localIdentifier: localIdentifier,
            title: title,
            alias: alias,
        };
    }
    return null;
}
function buildArithmeticMeasureTitle(measure, measureTitleProps, titleFactory, maxArithmeticMeasureTitleLength) {
    if (isArithmeticMeasure(measure)) {
        var alias = measureAlias(measure);
        var localIdentifier = measureLocalId(measure);
        var measureIdentifiers = measureArithmeticOperands(measure);
        var operator = measureArithmeticOperator(measure);
        if (containsMeasureTitleItems(measureTitleProps, measureIdentifiers)) {
            var fullLengthTitle = titleFactory.getTitle({
                operator: operator,
                masterMeasureLocalIdentifiers: measureIdentifiers,
            }, measureTitleProps);
            if (!fullLengthTitle) {
                return null;
            }
            var title = stringUtils.shortenText(fullLengthTitle, {
                maxLength: maxArithmeticMeasureTitleLength,
            });
            return {
                localIdentifier: localIdentifier,
                title: title,
                alias: alias,
            };
        }
    }
    return null;
}
function buildDerivedMeasureTitle(measure, measureTitleProps, suffixFactory) {
    if (isPoPMeasure(measure) || isPreviousPeriodMeasure(measure)) {
        var alias = measureAlias(measure);
        var localIdentifier = measureLocalId(measure);
        var masterMeasureIdentifier = measureMasterIdentifier(measure);
        if (containsMeasureTitleItem(measureTitleProps, masterMeasureIdentifier)) {
            return {
                localIdentifier: localIdentifier,
                title: findTitleForDerivedMeasure(measure, measureTitleProps, suffixFactory),
                alias: alias,
            };
        }
    }
    return null;
}
function buildMeasureTitles(measures, locale, maxArithmeticMeasureTitleLength) {
    var titleFactory = new ArithmeticMeasureTitleFactory(locale);
    var suffixFactory = new DerivedMeasureTitleSuffixFactory(locale);
    var measureTitleProps = [];
    var isMeasureTitlePropsChanged = true;
    while (isMeasureTitlePropsChanged) {
        isMeasureTitlePropsChanged = false;
        measures.forEach(function (measure) {
            var localId = measureLocalId(measure);
            if (!containsMeasureTitleItem(measureTitleProps, localId)) {
                var newMeasureTitleProp = buildMeasureTitle(measure) ||
                    buildArithmeticMeasureTitle(measure, measureTitleProps, titleFactory, maxArithmeticMeasureTitleLength) ||
                    buildDerivedMeasureTitle(measure, measureTitleProps, suffixFactory);
                if (newMeasureTitleProp !== null) {
                    measureTitleProps.push(newMeasureTitleProp);
                    isMeasureTitlePropsChanged = true;
                }
            }
        });
    }
    return measureTitleProps;
}
function updateBucketItemTitle(bucketItem, measureTitleProps) {
    if (isMeasure(bucketItem)) {
        var localId = measureLocalId(bucketItem);
        var measureTitleProp = findMeasureTitleItem(measureTitleProps, localId);
        if (measureTitleProp !== null) {
            var title = measureTitleProp.title, alias = measureTitleProp.alias;
            return __assign(__assign({}, bucketItem), { measure: __assign(__assign({}, bucketItem.measure), { title: title,
                    alias: alias }) });
        }
    }
    return bucketItem;
}
function updateBucketTitles(bucket, measureTitleProps) {
    var items = bucketItems(bucket);
    return __assign(__assign({}, bucket), { items: items.map(function (bucketItem) { return updateBucketItemTitle(bucketItem, measureTitleProps); }) });
}
function updateVisualizationObjectTitles(insight, measureTitleProps) {
    var buckets = insightBuckets(insight);
    return {
        insight: __assign(__assign({}, insight.insight), { buckets: buckets.map(function (bucket) { return updateBucketTitles(bucket, measureTitleProps); }) }),
    };
}
/**
 * The function fills the titles of the measures that does not have it set.
 *
 * The derived measures
 * have the title built from the current name of the master measure and suffix based on the derived measure type.
 *
 * The arithmetic measures
 * have the title built from the current names of the referenced master measures and type of the arithmetic
 * operation.
 *
 * @param insight - insight or insight definition that must be processed.
 * @param locale - locale used for localization of the measure titles.
 * @param maxArithmeticMeasureTitleLength - maximum length of generated arithmetic measures titles.
 * Longer names will be shortened. Default value is 50 characters.
 *
 * @returns a copy of insight with auto-generated titles for derived and arithmetic measures
 *
 * @internal
 */
export function fillMissingTitles(insight, locale, maxArithmeticMeasureTitleLength) {
    if (maxArithmeticMeasureTitleLength === void 0) { maxArithmeticMeasureTitleLength = DEFAULT_MAX_ARITHMETIC_MEASURE_TITLE_LENGTH; }
    var measures = insightMeasures(insight);
    var measureTitleProps = buildMeasureTitles(measures, locale, maxArithmeticMeasureTitleLength);
    return updateVisualizationObjectTitles(insight, measureTitleProps);
}
//# sourceMappingURL=fillMissingTitles.js.map