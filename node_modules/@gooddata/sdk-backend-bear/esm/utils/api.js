import { __awaiter, __generator } from "tslib";
import { UnexpectedError, UnexpectedResponseError } from "@gooddata/sdk-backend-spi";
import { isIdentifierRef, isUriRef } from "@gooddata/sdk-model";
import last from "lodash/last";
import uniq from "lodash/uniq";
import invariant from "ts-invariant";
import { convertUser } from "../convertors/fromBackend/UsersConverter";
import isEmpty from "lodash/isEmpty";
import { isApiResponseError } from "./errorHandling";
/**
 * Returns a user uri. This is used in some bear client calls.
 * If there is no user available, returns null instead.
 * @param getPrincipal - function to obtain currently authenticated principal to get the data from
 *
 * @internal
 */
export var userUriFromAuthenticatedPrincipalWithAnonymous = function (getPrincipal) { return __awaiter(void 0, void 0, void 0, function () {
    var principal, selfLink;
    var _a, _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4 /*yield*/, getPrincipal()];
            case 1:
                principal = _c.sent();
                selfLink = (_b = (_a = principal.userMeta) === null || _a === void 0 ? void 0 : _a.links) === null || _b === void 0 ? void 0 : _b.self;
                return [2 /*return*/, selfLink !== null && selfLink !== void 0 ? selfLink : null];
        }
    });
}); };
/**
 * Returns a user uri. This is used in some bear client calls
 * If there is no user available, throws an error.
 * @param getPrincipal - function to obtain currently authenticated principal to get the data from
 *
 * @internal
 */
export var userUriFromAuthenticatedPrincipal = function (getPrincipal) { return __awaiter(void 0, void 0, void 0, function () {
    var selfLink;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, userUriFromAuthenticatedPrincipalWithAnonymous(getPrincipal)];
            case 1:
                selfLink = _a.sent();
                if (!selfLink) {
                    throw new UnexpectedError("Cannot obtain the current user uri");
                }
                return [2 /*return*/, selfLink];
        }
    });
}); };
/**
 * Returns a user login md5. This is used in some bear client calls as a userId.
 * If there is no user available, returns null instead.
 * @param getPrincipal - function to obtain currently authenticated principal to get the data from
 *
 * @internal
 */
export var userLoginMd5FromAuthenticatedPrincipalWithAnonymous = function (getPrincipal) { return __awaiter(void 0, void 0, void 0, function () {
    var principal, selfLink, userLoginMd5;
    var _a, _b, _c;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0: return [4 /*yield*/, getPrincipal()];
            case 1:
                principal = _d.sent();
                selfLink = (_c = (_b = (_a = principal.userMeta) === null || _a === void 0 ? void 0 : _a.links) === null || _b === void 0 ? void 0 : _b.self) !== null && _c !== void 0 ? _c : "";
                userLoginMd5 = last(selfLink.split("/"));
                return [2 /*return*/, userLoginMd5 !== null && userLoginMd5 !== void 0 ? userLoginMd5 : null];
        }
    });
}); };
/**
 * Returns a user login md5. This is used in some bear client calls as a userId.
 * If there is no user available, throws an error.
 * @param getPrincipal - function to obtain currently authenticated principal to get the data from
 *
 * @internal
 */
export var userLoginMd5FromAuthenticatedPrincipal = function (getPrincipal) { return __awaiter(void 0, void 0, void 0, function () {
    var userLoginMd5;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, userLoginMd5FromAuthenticatedPrincipalWithAnonymous(getPrincipal)];
            case 1:
                userLoginMd5 = _a.sent();
                if (!userLoginMd5) {
                    throw new UnexpectedError("Cannot obtain the current user login md5");
                }
                return [2 /*return*/, userLoginMd5];
        }
    });
}); };
/**
 * Returns the objectId from the given URI.
 * @param uri - URI to get objectId from
 */
export var getObjectIdFromUri = function (uri) {
    // eslint-disable-next-line no-useless-escape
    var match = /\/obj\/([^$\/\?]*)/.exec(uri);
    return match ? match[1] : "";
};
/**
 * Converts ObjRef instance to URI. For UriRef returns the uri as is, for IdentifierRef calls the backend and gets the URI.
 * @param ref - ref to convert
 * @param workspace - workspace id to use
 * @param authCall - call guard to perform API calls through
 *
 * @internal
 */
export var objRefToUri = function (ref, workspace, authCall) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, isUriRef(ref)
                ? ref.uri
                : authCall(function (sdk) {
                    return sdk.md.getObjectUri(workspace, ref.identifier).catch(function (e) {
                        var _a;
                        // Nasty but necessary :( Resolution of id -> uri happens using POST request which succeeds and
                        // tells that the object does not exist && the api-client-bear does not have proper exception
                        // to communicate this with. It sends ApiResponseError and includes the response of the POST
                        // which has all green statuses.
                        //
                        // Backend must reconcile here and do explicit categorization otherwise the upstream handlers
                        // will throw this into UnexpectedError category (reserved for really unexpected stuff happening which
                        // kind of makes sense if you get ApiResponseError with status code 200 :))
                        if (isApiResponseError(e) && ((_a = e.message) === null || _a === void 0 ? void 0 : _a.search("not found")) > -1) {
                            throw new UnexpectedResponseError("Object with " + ref.identifier + " does not exist.", 404, e.responseBody);
                        }
                        throw e;
                    });
                })];
    });
}); };
/**
 * Converts ObjRef instances to URIs. For UriRefs, it returns the URIs as they are,
 * for IdentifierRefs calls the backend and gets the URIs.
 * @param refs - refs to convert
 * @param workspace - workspace id to use
 * @param authCall - call guard to perform API calls through
 * @param throwOnUnresolved - whether to throw an error if id to uri cannot be resolved for some ref; default is true
 * @returns resolved URIs; when throwOnUnresolved is true, then order of appearance of the resolved URIs
 *  is guaranteed to match the order on the input; otherwise if throwOnUnresolved is false and some identifiers
 *  could not be resolved, the returned array will be smaller with no indication as to which identifiers could
 *  not be resolved
 * @internal
 */
export var objRefsToUris = function (refs, workspace, authCall, throwOnUnresolved) {
    if (throwOnUnresolved === void 0) { throwOnUnresolved = true; }
    return __awaiter(void 0, void 0, void 0, function () {
        var identifiers, identifiersToUrisPairs, translatedUris;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (isEmpty(refs)) {
                        return [2 /*return*/, []];
                    }
                    identifiers = refs.filter(isIdentifierRef).map(function (filter) { return filter.identifier; });
                    return [4 /*yield*/, authCall(function (sdk) {
                            return sdk.md.getUrisFromIdentifiers(workspace, identifiers);
                        })];
                case 1:
                    identifiersToUrisPairs = _a.sent();
                    translatedUris = [];
                    refs.forEach(function (ref) {
                        if (isUriRef(ref)) {
                            translatedUris.push(ref.uri);
                        }
                        else {
                            var foundPair = identifiersToUrisPairs.find(function (pair) { return pair.identifier === ref.identifier; });
                            if (!foundPair) {
                                if (throwOnUnresolved) {
                                    throw new UnexpectedError("REFERENCED_OBJECT_NOT_FOUND", new Error("Referenced object for " + ref.identifier + " not found"));
                                }
                                else {
                                    // eslint-disable-next-line no-console
                                    console.debug("Unable to translate identifier " + ref.identifier + " to object URI. The ref will be skipped.");
                                    return;
                                }
                            }
                            translatedUris.push(foundPair.uri);
                        }
                    });
                    return [2 /*return*/, translatedUris];
            }
        });
    });
};
/**
 * Converts ObjRef instance to identifier. For IdentifierRef returns the identifier as is,
 * for UriRef calls the backend and gets the identifier.
 * @param ref - ref to convert
 * @param workspace - workspace id to use
 * @param authCall - call guard to perform API calls through
 *
 * @internal
 */
export var objRefToIdentifier = function (ref, authCall) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, isIdentifierRef(ref) ? ref.identifier : authCall(function (sdk) { return sdk.md.getObjectIdentifier(ref.uri); })];
    });
}); };
/**
 * Converts ObjRef instances to identifiers. For IdentifierRefs returns the identifiers as is,
 * for UriRefs calls the backend and gets the identifiers.
 * @param refs - refs to convert
 * @param workspace - workspace id to use
 * @param authCall - call guard to perform API calls through
 *
 * @internal
 */
export var objRefsToIdentifiers = function (refs, authCall) { return __awaiter(void 0, void 0, void 0, function () {
    return __generator(this, function (_a) {
        return [2 /*return*/, Promise.all(refs.map(function (ref) { return objRefToIdentifier(ref, authCall); }))];
    });
}); };
/**
 * Gets an updated userMap loading information for any missing users. The map is keyed by the user URI.
 */
export var updateUserMap = function (userMap, requestedUserUris, authCall) { return __awaiter(void 0, void 0, void 0, function () {
    var usersToLoad, uniqueUsersToLoad, results;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                usersToLoad = requestedUserUris.filter(function (uri) { return !userMap.has(uri); });
                uniqueUsersToLoad = uniq(usersToLoad);
                return [4 /*yield*/, Promise.all(uniqueUsersToLoad.map(function (uri) {
                        return authCall(function (sdk) { return __awaiter(void 0, void 0, void 0, function () {
                            var result, ex_1;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        _a.trys.push([0, 2, , 3]);
                                        return [4 /*yield*/, sdk.xhr.getParsed(uri)];
                                    case 1:
                                        result = _a.sent();
                                        return [2 /*return*/, convertUser(result.accountSetting)];
                                    case 2:
                                        ex_1 = _a.sent();
                                        // for inactive users, non-admins will get Forbidden from the server
                                        // so on error we assume that the user that was requested is no longer there (is inactive)
                                        return [2 /*return*/, undefined];
                                    case 3: return [2 /*return*/];
                                }
                            });
                        }); });
                    }))];
            case 1:
                results = _a.sent();
                results.forEach(function (result) {
                    if (result) {
                        var uri = isUriRef(result.ref) ? result.ref.uri : undefined;
                        invariant(uri, "User must have uri in bear backend instances.");
                        userMap.set(uri, result);
                    }
                });
                return [2 /*return*/, userMap];
        }
    });
}); };
//# sourceMappingURL=api.js.map