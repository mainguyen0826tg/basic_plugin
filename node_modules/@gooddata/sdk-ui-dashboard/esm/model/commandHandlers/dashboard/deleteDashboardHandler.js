// (C) 2021 GoodData Corporation
import { __assign, __generator, __read, __spread } from "tslib";
import { call, put, select, setContext } from "redux-saga/effects";
import { invalidArgumentsProvided } from "../../events/general";
import { areObjRefsEqual, idRef, uriRef } from "@gooddata/sdk-model";
import { batchActions } from "redux-batched-actions";
import { executionResultsActions } from "../../store/executionResults";
import { selectDateFilterConfig } from "../../store/config/configSelectors";
import { selectPersistedDashboard } from "../../store/meta/metaSelectors";
import { dashboardDeleted } from "../../events/dashboard";
import { invariant } from "ts-invariant";
import { actionsToInitializeNewDashboard } from "./common/stateInitializers";
function deleteDashboard(ctx, dashboardRef) {
    var backend = ctx.backend, workspace = ctx.workspace;
    return backend.workspace(workspace).dashboards().deleteDashboard(dashboardRef);
}
/**
 * Resets the essential state so that an empty dashboard is rendered. This includes change of the
 * saga context so that it contains an empty dashboardRef.
 *
 * Note: This will not clear any of the dashboard-agnostic global state such as config and settings.
 *
 * @param ctx
 */
function resetToNewDashboard(ctx) {
    var dateFilterConfig, newContext;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, select(selectDateFilterConfig)];
            case 1:
                dateFilterConfig = _a.sent();
                return [4 /*yield*/, put(batchActions(__spread(actionsToInitializeNewDashboard(dateFilterConfig), [
                        executionResultsActions.clearAllExecutionResults(),
                    ]), "@@GDC.DASH/BATCH.CLEAR"))];
            case 2:
                _a.sent();
                newContext = __assign(__assign({}, ctx), { dashboardRef: undefined });
                return [4 /*yield*/, setContext({
                        dashboardContext: newContext,
                    })];
            case 3:
                _a.sent();
                return [2 /*return*/, newContext];
        }
    });
}
export function deleteDashboardHandler(ctx, cmd) {
    var existingDashboardRef, persistedDashboard, newContext;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                existingDashboardRef = ctx.dashboardRef;
                return [4 /*yield*/, select(selectPersistedDashboard)];
            case 1:
                persistedDashboard = _a.sent();
                if (!persistedDashboard) {
                    throw invalidArgumentsProvided(ctx, cmd, "Attempting to delete a dashboard that was never saved.");
                }
                // if this invariant fails, it means the state is inconsistent; previous command processing must have done
                // something wrong; for instance updated context with some ref but did not update the persisted dashboard
                // accordingly
                invariant(existingDashboardRef &&
                    (areObjRefsEqual(existingDashboardRef, uriRef(persistedDashboard.uri)) ||
                        areObjRefsEqual(existingDashboardRef, idRef(persistedDashboard.identifier))));
                // perform the actual delete
                return [4 /*yield*/, call(deleteDashboard, ctx, persistedDashboard.ref)];
            case 2:
                // perform the actual delete
                _a.sent();
                return [4 /*yield*/, call(resetToNewDashboard, ctx)];
            case 3:
                newContext = _a.sent();
                return [2 /*return*/, dashboardDeleted(newContext, persistedDashboard, cmd.correlationId)];
        }
    });
}
//# sourceMappingURL=deleteDashboardHandler.js.map