import { __assign } from "tslib";
import { filterIsEmpty, isAbsoluteDateFilter, isAttributeElementsByValue, isAttributeFilter, isComparisonCondition, isFilter, isMeasureValueFilter, isPositiveAttributeFilter, isRangeCondition, isRankingFilter, isRelativeDateFilter, } from "@gooddata/sdk-model";
import { toTigerGranularity } from "../../fromBackend/dateGranularityConversions";
import { toDateDataSetQualifier, toLabelQualifier, toMeasureValueFilterMeasureQualifier, toRankingFilterDimensionalityIdentifier, } from "../ObjRefConverter";
export function newFilterWithApplyOnResult(filter, applyOnResult) {
    return { filter: filter, applyOnResult: applyOnResult };
}
function extractValuesFromAttributeElements(attributeElements) {
    if (isAttributeElementsByValue(attributeElements)) {
        return attributeElements.values;
    }
    // XXX: there is no other way now then to be lenient. the KD does not support text filters and always works
    //  primarily with URIs. Changing / refactoring KD in this area is out of question. So this code is now
    //  more lenient and if it finds attribute elements to be URIs, it will use them in the filter.
    //
    //  Furthermore.. this is not 100% wrong anyway as tiger elements have URIs which are in the end
    //  text values as well :)
    return attributeElements.uris;
}
function convertPositiveFilter(filter, applyOnResultProp) {
    var labelRef = filter.positiveAttributeFilter.displayForm;
    var attributeElements = filter.positiveAttributeFilter.in;
    return {
        positiveAttributeFilter: __assign({ label: toLabelQualifier(labelRef), in: {
                values: extractValuesFromAttributeElements(attributeElements),
            } }, applyOnResultProp),
    };
}
function convertNegativeFilter(filter, applyOnResultProp) {
    var labelRef = filter.negativeAttributeFilter.displayForm;
    var attributeElements = filter.negativeAttributeFilter.notIn;
    return {
        negativeAttributeFilter: __assign({ label: toLabelQualifier(labelRef), notIn: {
                values: extractValuesFromAttributeElements(attributeElements),
            } }, applyOnResultProp),
    };
}
function convertAttributeFilter(filter, applyOnResultProp) {
    if (filterIsEmpty(filter)) {
        return null;
    }
    if (isPositiveAttributeFilter(filter)) {
        return convertPositiveFilter(filter, applyOnResultProp);
    }
    return convertNegativeFilter(filter, applyOnResultProp);
}
function convertAbsoluteDateFilter(filter, applyOnResultProp) {
    var absoluteDateFilter = filter.absoluteDateFilter;
    if (absoluteDateFilter.from === undefined || absoluteDateFilter.to === undefined) {
        return null;
    }
    var datasetRef = absoluteDateFilter.dataSet;
    return {
        absoluteDateFilter: __assign({ dataset: toDateDataSetQualifier(datasetRef), from: String(absoluteDateFilter.from), to: String(absoluteDateFilter.to) }, applyOnResultProp),
    };
}
function convertRelativeDateFilter(filter, applyOnResultProp) {
    var relativeDateFilter = filter.relativeDateFilter;
    if (relativeDateFilter.from === undefined || !relativeDateFilter.to === undefined) {
        return null;
    }
    var datasetRef = relativeDateFilter.dataSet;
    return {
        relativeDateFilter: __assign({ dataset: toDateDataSetQualifier(datasetRef), granularity: toTigerGranularity(relativeDateFilter.granularity), from: Number(relativeDateFilter.from), to: Number(relativeDateFilter.to) }, applyOnResultProp),
    };
}
function convertMeasureValueFilter(filter, applyOnResultProp) {
    var measureValueFilter = filter.measureValueFilter;
    var condition = measureValueFilter.condition;
    if (isComparisonCondition(condition)) {
        var _a = condition.comparison, operator = _a.operator, value = _a.value, treatNullValuesAs = _a.treatNullValuesAs;
        return {
            comparisonMeasureValueFilter: __assign({ measure: toMeasureValueFilterMeasureQualifier(measureValueFilter.measure), 
                // Operator has same values, we only need type assertion
                operator: operator, value: value,
                treatNullValuesAs: treatNullValuesAs }, applyOnResultProp),
        };
    }
    if (isRangeCondition(condition)) {
        var _b = condition.range, operator = _b.operator, originalFrom = _b.from, originalTo = _b.to, treatNullValuesAs = _b.treatNullValuesAs;
        return {
            rangeMeasureValueFilter: __assign({ measure: toMeasureValueFilterMeasureQualifier(measureValueFilter.measure), 
                // Operator has same values, we only need type assertion
                operator: operator, 
                // make sure the boundaries are always from <= to, because tiger backend cannot handle from > to in a user friendly way
                // this is effectively the same behavior as in bear
                from: Math.min(originalFrom, originalTo), to: Math.max(originalFrom, originalTo), treatNullValuesAs: treatNullValuesAs }, applyOnResultProp),
        };
    }
    return null;
}
function convertRankingFilter(filter, applyOnResultProp, afmAttributes) {
    var _a = filter.rankingFilter, measure = _a.measure, attributes = _a.attributes, operator = _a.operator, value = _a.value;
    var dimensionalityProp = attributes
        ? {
            dimensionality: attributes.map(function (attr) {
                return toRankingFilterDimensionalityIdentifier(attr, afmAttributes);
            }),
        }
        : {};
    return {
        rankingFilter: __assign(__assign(__assign({ measures: [toMeasureValueFilterMeasureQualifier(measure)] }, dimensionalityProp), { operator: operator, value: value }), applyOnResultProp),
    };
}
export function convertFilter(filter0, afmAttributes) {
    if (afmAttributes === void 0) { afmAttributes = []; }
    var _a = isFilter(filter0)
        ? [filter0, undefined]
        : [filter0.filter, filter0.applyOnResult], filter = _a[0], applyOnResult = _a[1];
    var applyOnResultProp = applyOnResult === undefined ? {} : { applyOnResult: applyOnResult };
    if (isAttributeFilter(filter)) {
        return convertAttributeFilter(filter, applyOnResultProp);
    }
    else if (isAbsoluteDateFilter(filter)) {
        return convertAbsoluteDateFilter(filter, applyOnResultProp);
    }
    else if (isRelativeDateFilter(filter)) {
        return convertRelativeDateFilter(filter, applyOnResultProp);
    }
    else if (isMeasureValueFilter(filter)) {
        return convertMeasureValueFilter(filter, applyOnResultProp);
    }
    else if (isRankingFilter(filter)) {
        return convertRankingFilter(filter, applyOnResultProp, afmAttributes);
    }
    else {
        // eslint-disable-next-line no-console
        console.warn("Tiger does not support this filter. The filter will be ignored");
        return null;
    }
}
//# sourceMappingURL=FilterConverter.js.map