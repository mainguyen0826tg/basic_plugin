import { __assign, __awaiter, __generator } from "tslib";
import invariant from "ts-invariant";
import { NotAuthenticated, isNotAuthenticated, } from "@gooddata/sdk-backend-spi";
import { newAxios, tigerClientFactory, jsonApiHeaders } from "@gooddata/api-client-tiger";
import isEmpty from "lodash/isEmpty";
import isString from "lodash/isString";
import inRange from "lodash/inRange";
import identity from "lodash/identity";
import omit from "lodash/omit";
import { convertApiError } from "../utils/errorHandling";
import { TigerWorkspace } from "./workspace";
import { TigerWorkspaceQueryFactory } from "./workspaces";
import { TigerUserService } from "./user";
import { AuthProviderCallGuard, AnonymousAuthProvider, } from "@gooddata/sdk-backend-base";
import { createDefaultDateFormatter } from "../convertors/fromBackend/dateFormatting/defaultDateFormatter";
import { TigerOrganization, TigerOrganizations } from "./organization";
var CAPABILITIES = {
    hasTypeScopedIdentifiers: true,
    canCalculateGrandTotals: true,
    canCalculateSubTotals: false,
    canCalculateNativeTotals: false,
    canCalculateTotals: false,
    canExportCsv: false,
    canExportXlsx: false,
    canSortData: false,
    canTransformExistingResult: false,
    maxDimensions: 2,
    supportsElementUris: false,
    supportsObjectUris: false,
    supportsCsvUploader: false,
    supportsRankingFilter: true,
    supportsRankingFilterWithMeasureValueFilter: false,
    supportsElementsQueryParentFiltering: false,
    supportsKpiWidget: false,
    supportsHyperlinkAttributeLabels: false,
    supportsGenericDateAttributeElements: false,
    supportsExplain: true,
    supportsAccessControl: false,
    usesStrictAccessControl: true,
};
/**
 * An implementation of analytical backend for GoodData CloudNative (codename tiger).
 */
var TigerBackend = /** @class */ (function () {
    function TigerBackend(config, implConfig, telemetry, authProvider) {
        var _this = this;
        if (config === void 0) { config = {}; }
        if (implConfig === void 0) { implConfig = {}; }
        if (telemetry === void 0) { telemetry = {}; }
        var _a, _b, _c;
        this.capabilities = CAPABILITIES;
        this.isAuthenticated = function () {
            return new Promise(function (resolve, reject) {
                _this.authProvider
                    .getCurrentPrincipal({ client: _this.client, backend: _this })
                    .then(function (res) {
                    resolve(res);
                })
                    .catch(function (err) {
                    if (isNotAuthenticatedResponse(err) || isNotAuthenticated(err)) {
                        resolve(null);
                    }
                    reject(err);
                });
            });
        };
        this.authenticate = function (force) {
            if (!force) {
                return _this.authApiCall(function (client) { return __awaiter(_this, void 0, void 0, function () {
                    var principal;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.authProvider.getCurrentPrincipal({ client: client, backend: this })];
                            case 1:
                                principal = _a.sent();
                                invariant(principal, "Principal must be defined");
                                return [2 /*return*/, principal];
                        }
                    });
                }); });
            }
            return _this.triggerAuthentication(true)
                .catch(function (e) {
                throw convertApiError(e);
            })
                .catch(_this.handleNotAuthenticated);
        };
        /**
         * Perform API call that requires authentication. The call will be decorated with error handling
         * such that not authenticated errors will trigger authentication flow AND other errors will be
         * converted using the provided converter and throw.
         *
         * @param call - a call which requires an authenticated session
         * @param errorConverter - converter from rest client errors to analytical backend errors
         */
        this.authApiCall = function (call, errorConverter) {
            if (errorConverter === void 0) { errorConverter = convertApiError; }
            return __awaiter(_this, void 0, void 0, function () {
                var _a, _b;
                var _this = this;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _a = call;
                            _b = [this.client];
                            return [4 /*yield*/, this.getAsyncCallContext()];
                        case 1: return [2 /*return*/, _a.apply(void 0, _b.concat([_c.sent()]))
                                .catch(function (err) {
                                if (!isNotAuthenticatedResponse(err)) {
                                    throw errorConverter(err);
                                }
                                return _this.triggerAuthentication()
                                    .then(function (_) { return __awaiter(_this, void 0, void 0, function () {
                                    var _a, _b;
                                    return __generator(this, function (_c) {
                                        switch (_c.label) {
                                            case 0:
                                                _a = call;
                                                _b = [this.client];
                                                return [4 /*yield*/, this.getAsyncCallContext()];
                                            case 1: return [2 /*return*/, _a.apply(void 0, _b.concat([_c.sent()])).catch(function (e) {
                                                    throw errorConverter(e);
                                                })];
                                        }
                                    });
                                }); })
                                    .catch(function (err2) {
                                    throw errorConverter(err2);
                                });
                            })
                                .catch(this.handleNotAuthenticated)];
                    }
                });
            });
        };
        this.handleNotAuthenticated = function (err) {
            var _a, _b;
            if (isNotAuthenticated(err)) {
                (_b = (_a = _this.authProvider).onNotAuthenticated) === null || _b === void 0 ? void 0 : _b.call(_a, { client: _this.client, backend: _this }, err);
            }
            throw err;
        };
        this.getAuthenticationContext = function () {
            return { client: _this.client, backend: _this };
        };
        this.getAsyncCallContext = function () { return __awaiter(_this, void 0, void 0, function () {
            var getPrincipal;
            var _this = this;
            return __generator(this, function (_a) {
                getPrincipal = function () { return __awaiter(_this, void 0, void 0, function () {
                    var principal;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!this.authProvider) {
                                    throw new NotAuthenticated("Cannot obtain principal without an authProvider.");
                                }
                                return [4 /*yield*/, this.authProvider.getCurrentPrincipal({
                                        client: this.client,
                                        backend: this,
                                    })];
                            case 1:
                                principal = _a.sent();
                                if (principal) {
                                    return [2 /*return*/, principal];
                                }
                                return [2 /*return*/, this.authProvider.authenticate(this.getAuthenticationContext())];
                        }
                    });
                }); };
                return [2 /*return*/, {
                        getPrincipal: getPrincipal,
                    }];
            });
        }); };
        this.triggerAuthentication = function (reset) {
            if (reset === void 0) { reset = false; }
            if (!_this.authProvider) {
                return Promise.reject(new NotAuthenticated("Backend is not set up with authentication provider."));
            }
            if (reset) {
                _this.authProvider.reset();
            }
            return _this.authProvider.authenticate({ client: _this.client, backend: _this });
        };
        this.config = config;
        this.implConfig = implConfig;
        this.telemetry = telemetry;
        this.authProvider = authProvider || new AnonymousAuthProvider();
        this.dateFormatter = (_a = implConfig.dateFormatter) !== null && _a !== void 0 ? _a : createDefaultDateFormatter();
        var axios = createAxios(this.config, this.implConfig, this.telemetry);
        interceptBackendErrorsToConsole(axios);
        this.client = tigerClientFactory(axios);
        (_c = (_b = this.authProvider).initializeClient) === null || _c === void 0 ? void 0 : _c.call(_b, this.client);
        if (this.implConfig.onTigerSpecificFunctionsReady) {
            var specificFunctions = {
                isCommunityEdition: function () { return __awaiter(_this, void 0, void 0, function () {
                    var _a;
                    var _this = this;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _b.trys.push([0, 2, , 3]);
                                return [4 /*yield*/, this.authApiCall(function (sdk) { return __awaiter(_this, void 0, void 0, function () {
                                        var response;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, sdk.organizationObjects.getAllEntitiesWorkspaces({ page: 0, size: 1 }, { headers: jsonApiHeaders })];
                                                case 1:
                                                    response = _a.sent();
                                                    // the header name are all lowercase in this object
                                                    return [2 /*return*/, response.headers["gooddata-deployment"] === "aio"];
                                            }
                                        });
                                    }); })];
                            case 1: return [2 /*return*/, _b.sent()];
                            case 2:
                                _a = _b.sent();
                                return [2 /*return*/, false];
                            case 3: return [2 /*return*/];
                        }
                    });
                }); },
            };
            this.implConfig.onTigerSpecificFunctionsReady(specificFunctions);
        }
    }
    TigerBackend.prototype.onHostname = function (hostname) {
        return new TigerBackend(__assign(__assign({}, this.config), { hostname: hostname }), this.implConfig, this.telemetry);
    };
    TigerBackend.prototype.withTelemetry = function (componentName, props) {
        return new TigerBackend(this.config, this.implConfig, { componentName: componentName, props: Object.keys(props) }, this.authProvider);
    };
    TigerBackend.prototype.withAuthentication = function (provider) {
        var guardedAuthProvider = new AuthProviderCallGuard(provider);
        return new TigerBackend(this.config, this.implConfig, this.telemetry, guardedAuthProvider);
    };
    TigerBackend.prototype.deauthenticate = function () {
        if (!this.authProvider) {
            throw new NotAuthenticated("Backend is not set up with authentication provider.");
        }
        return this.authProvider.deauthenticate(this.getAuthenticationContext());
    };
    TigerBackend.prototype.organization = function (organizationId) {
        return new TigerOrganization(this.authApiCall, organizationId);
    };
    TigerBackend.prototype.organizations = function () {
        return new TigerOrganizations(this.authApiCall);
    };
    TigerBackend.prototype.currentUser = function () {
        return new TigerUserService(this.authApiCall);
    };
    TigerBackend.prototype.workspace = function (id) {
        invariant(isString(id), "Invalid workspaceId, expected a string, got: " + id);
        return new TigerWorkspace(this.authApiCall, id, this.dateFormatter);
    };
    TigerBackend.prototype.workspaces = function () {
        return new TigerWorkspaceQueryFactory(this.authApiCall, this.dateFormatter);
    };
    return TigerBackend;
}());
export { TigerBackend };
function createAxios(config, implConfig, telemetry) {
    var baseUrl = config.hostname ? config.hostname : undefined;
    var headers = createHeaders(implConfig, telemetry);
    return newAxios(baseUrl, headers);
}
function interceptBackendErrorsToConsole(client) {
    client.interceptors.response.use(identity, function (error) {
        var response = error.response;
        // If there is no response object (for example for blocked requests), print the whole error.
        if (!response) {
            // eslint-disable-next-line no-console
            console.error("Tiger backend threw an error:", error);
        }
        // Else if the response is an object (JSON parsed by axios) and there is a problem, then log error
        // into console for easier diagnostics.
        else if (inRange(response.status, 400, 600) && typeof response.data === "object") {
            // Title is redundant (Bad Request)
            var details = omit(response.data, ["title"]);
            // eslint-disable-next-line no-console
            console.error("Tiger backend threw an error:", details);
        }
        return Promise.reject(error);
    });
    return client;
}
function createHeaders(implConfig, telemetry) {
    var headers = {};
    if (telemetry.componentName) {
        headers["X-GDC-JS-SDK-COMP"] = telemetry.componentName;
    }
    if (telemetry.props && !isEmpty(telemetry.props)) {
        headers["X-GDC-JS-SDK-COMP-PROPS"] = telemetry.props.join(",");
    }
    if (implConfig.packageName && implConfig.packageVersion) {
        headers["X-GDC-JS-PACKAGE"] = implConfig.packageName;
        headers["X-GDC-JS-PACKAGE-VERSION"] = implConfig.packageVersion;
    }
    return headers;
}
function isNotAuthenticatedResponse(err) {
    var _a;
    return ((_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.status) === 401;
}
//# sourceMappingURL=index.js.map