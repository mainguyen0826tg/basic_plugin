import { GdcExecution, GdcExecuteAFM } from "@gooddata/api-model-bear";
import { XhrModule, ApiResponseError } from "../xhr";
export declare const DEFAULT_LIMIT = 1000;
/**
 * This interface represents input for executeVisualization API endpoint.
 *
 * NOTE: all functionality related to executeVisualization is experimental and subject to possible breaking changes
 * in the future; location and shape of this interface WILL change when the functionality is made GA.
 *
 * @private
 * @internal
 */
export interface IVisualizationExecution {
    visualizationExecution: {
        reference: string;
        resultSpec?: GdcExecuteAFM.IResultSpec;
        filters?: GdcExecuteAFM.CompatibilityFilter[];
    };
}
/**
 * This interface represents error caused during second part of api execution (data fetching)
 * and contains information about first execution part if that part was successful.
 *
 * @private
 * @internal
 */
export declare class ApiExecutionResponseError extends ApiResponseError {
    executionResponse: GdcExecution.IExecutionResponse;
    constructor(error: ApiResponseError, executionResponse: GdcExecution.IExecutionResponse);
}
export declare class ExecuteAfmModule {
    private xhr;
    constructor(xhr: XhrModule);
    /**
     * Execute AFM and fetch all data results
     *
     * @method executeAfm
     * @param {String} projectId - GD project identifier
     * @param {GdcExecuteAFM.IExecution} execution
     *
     * @returns {Promise<GdcExecution.IExecutionResponses>} Structure with `executionResponse` and `executionResult`
     */
    executeAfm(projectId: string, execution: GdcExecuteAFM.IExecution): Promise<GdcExecution.IExecutionResponses>;
    /**
     * Execute AFM and return execution's response; the response describes dimensionality of the results and
     * includes link to poll for the results.
     *
     * @method getExecutionResponse
     * @param {string} projectId - GD project identifier
     * @param {GdcExecuteAFM.IExecution} execution
     *
     * @returns {Promise<GdcExecution.IExecutionResponse>} Promise with `executionResponse`
     */
    getExecutionResponse(projectId: string, execution: GdcExecuteAFM.IExecution): Promise<GdcExecution.IExecutionResponse>;
    /**
     * Execute saved visualization and get all data.
     *
     * NOTE: all functionality related to executeVisualization is experimental and subject to possible breaking changes
     * in the future; location and shape of this interface WILL change when the functionality is made GA.
     *
     * @param {string} projectId - GD project identifier
     * @param {IVisualizationExecution} visExecution - execution payload
     *
     * @private
     * @internal
     */
    _executeVisualization(projectId: string, visExecution: IVisualizationExecution): Promise<GdcExecution.IExecutionResponses>;
    /**
     *
     * Execute visualization and return the response; the response describes dimensionality of the results and
     * includes link to poll for the results.
     *
     * NOTE: all functionality related to executeVisualization is experimental and subject to possible breaking changes
     * in the future; location and shape of this interface WILL change when the functionality is made GA.
     *
     * @param {string} projectId - GD project identifier
     * @param {IVisualizationExecution} visExecution - execution payload
     *
     * @private
     * @internal
     */
    _getVisExecutionResponse(projectId: string, visExecution: IVisualizationExecution): Promise<GdcExecution.IExecutionResponse>;
    /**
     * Get one page of Result from Execution (with requested limit and offset)
     *
     * @method getPartialExecutionResult
     * @param {string} executionResultUri
     * @param {number[]} limit - limit for each dimension
     * @param {number[]} offset - offset for each dimension
     *
     * @returns {Promise<GdcExecution.IExecutionResult | null>}
     *  Promise with `executionResult` or `null` (null means empty response - HTTP 204)
     */
    getPartialExecutionResult(executionResultUri: string, limit: number[], offset: number[]): Promise<GdcExecution.IExecutionResult | null>;
    /**
     * Get whole ExecutionResult
     *
     * @method getExecutionResult
     * @param {string} executionResultUri
     *
     * @returns {Promise<GdcExecution.IExecutionResult | null>}
     *  Promise with `executionResult` or `null` (null means empty response - HTTP 204)
     */
    getExecutionResult(executionResultUri: string): Promise<GdcExecution.IExecutionResult | null>;
    private getPage;
    private getAllPages;
    private fetchExecutionResult;
}
export declare function replaceLimitAndOffsetInUri(oldUri: string, limit: number[], offset: number[]): string;
export declare function getNextOffset(limit: number[], offset: number[], total: number[]): number[];
export declare function getNextLimit(limit: number[], nextOffset: number[], total: number[]): number[];
export declare function nextPageExists(nextOffset: number[], total: number[]): boolean;
export declare function mergePage(prevExecutionResult: GdcExecution.IExecutionResult, executionResult: GdcExecution.IExecutionResult): GdcExecution.IExecutionResult;
