import { __generator } from "tslib";
import { invalidArgumentsProvided } from "../../events/general";
import { selectLayout, selectStash } from "../../store/layout/layoutSelectors";
import { call, put, select } from "redux-saga/effects";
import { validateItemExists, validateSectionExists } from "./validation/layoutValidation";
import { layoutActions } from "../../store/layout";
import { validateAndResolveStashedItems } from "./validation/stashValidation";
import isEmpty from "lodash/isEmpty";
import { layoutSectionItemReplaced } from "../../events/layout";
import { validateAndNormalizeWidgetItems, validateAndResolveItemFilterSettings, } from "./validation/itemValidation";
import { batchActions } from "redux-batched-actions";
import { insightsActions } from "../../store/insights";
import { addTemporaryIdentityToWidgets } from "../../utils/dashboardItemUtils";
function validateAndResolve(commandCtx) {
    var ctx = commandCtx.ctx, _a = commandCtx.cmd.payload, sectionIndex = _a.sectionIndex, itemIndex = _a.itemIndex, items = commandCtx.items, layout = commandCtx.layout, stash = commandCtx.stash;
    if (!validateSectionExists(layout, sectionIndex)) {
        throw invalidArgumentsProvided(ctx, commandCtx.cmd, "Attempting to replace item from non-existent section at " + sectionIndex + ". There are only " + layout.sections.length + " sections.");
    }
    var fromSection = layout.sections[sectionIndex];
    if (!validateItemExists(fromSection, itemIndex)) {
        throw invalidArgumentsProvided(ctx, commandCtx.cmd, "Attempting to replace non-existent item from index " + itemIndex + " in section " + sectionIndex + ". There are only " + fromSection.items.length + " items in this section.");
    }
    var stashValidationResult = validateAndResolveStashedItems(stash, items);
    if (!isEmpty(stashValidationResult.missing)) {
        throw invalidArgumentsProvided(ctx, commandCtx.cmd, "Attempting to use non-existing stashes. Identifiers of missing stashes: " + stashValidationResult.missing.join(", "));
    }
    return {
        itemToReplace: fromSection.items[itemIndex],
        stashValidationResult: stashValidationResult,
    };
}
export function replaceSectionItemHandler(ctx, cmd) {
    var item, commandCtx, _a, _b, itemToReplace, stashValidationResult, _c, sectionIndex, itemIndex, stashIdentifier, autoResolveDateFilterDataset, normalizationResult, itemsToAdd;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                item = cmd.payload.item;
                _a = {
                    ctx: ctx,
                    cmd: cmd,
                    items: addTemporaryIdentityToWidgets([item])
                };
                return [4 /*yield*/, select(selectLayout)];
            case 1:
                _a.layout = _d.sent();
                return [4 /*yield*/, select(selectStash)];
            case 2:
                commandCtx = (_a.stash = _d.sent(),
                    _a);
                _b = validateAndResolve(commandCtx), itemToReplace = _b.itemToReplace, stashValidationResult = _b.stashValidationResult;
                _c = cmd.payload, sectionIndex = _c.sectionIndex, itemIndex = _c.itemIndex, stashIdentifier = _c.stashIdentifier, autoResolveDateFilterDataset = _c.autoResolveDateFilterDataset;
                return [4 /*yield*/, call(validateAndNormalizeWidgetItems, ctx, stashValidationResult, cmd)];
            case 3:
                normalizationResult = _d.sent();
                return [4 /*yield*/, call(validateAndResolveItemFilterSettings, ctx, cmd, normalizationResult, autoResolveDateFilterDataset)];
            case 4:
                itemsToAdd = _d.sent();
                return [4 /*yield*/, put(batchActions([
                        insightsActions.addInsights(normalizationResult.resolvedInsights.loaded),
                        layoutActions.replaceSectionItem({
                            sectionIndex: sectionIndex,
                            itemIndex: itemIndex,
                            newItems: itemsToAdd,
                            stashIdentifier: stashIdentifier,
                            usedStashes: stashValidationResult.existing,
                            undo: {
                                cmd: cmd,
                            },
                        }),
                    ]))];
            case 5:
                _d.sent();
                return [2 /*return*/, layoutSectionItemReplaced(ctx, sectionIndex, itemIndex, stashValidationResult.resolved, itemToReplace, stashIdentifier, cmd.correlationId)];
        }
    });
}
//# sourceMappingURL=replaceSectionItemHandler.js.map