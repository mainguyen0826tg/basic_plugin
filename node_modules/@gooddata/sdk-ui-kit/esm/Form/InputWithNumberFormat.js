import { __assign, __extends, __read } from "tslib";
// (C) 2007-2020 GoodData Corporation
import React from "react";
import memoize from "lodash/memoize";
import { InputPure } from "./InputPure";
// Highest number (BIGINT) according to gooddata documentation help.gooddata.com object-datatypes
export var MAX_NUMBER = Math.pow(10, 15);
// Max number of digits right to decimal point according to gooddata documentation help.gooddata.com object-datatypes
var MAX_DECIMAL_POINT_NUMBERS = 6;
export var DEFAULT_SEPARATORS = {
    thousand: ",",
    decimal: ".",
};
var getDanglingDecimalPointRegExp = memoize(function (decimal) { return new RegExp("\\" + decimal + "$"); });
var getFormatValidationRegExp = memoize(function (_a) {
    var thousand = _a.thousand, decimal = _a.decimal;
    return new RegExp("^-?(\\d|\\" + thousand + ")*(\\" + decimal + "\\d*)?$");
});
var parseStandardNumberString = function (numberString) {
    var belowDecimal = numberString.split(".")[1];
    var roundedNumberString = belowDecimal && belowDecimal.length >= MAX_DECIMAL_POINT_NUMBERS
        ? parseFloat(numberString).toFixed(MAX_DECIMAL_POINT_NUMBERS)
        : numberString;
    var number = parseFloat(roundedNumberString);
    return number === 0 ? 0 : number;
};
var convertFormattedStringToStandard = function (formattedString, _a) {
    var thousand = _a.thousand, decimal = _a.decimal;
    var withoutThousandSeparators = formattedString.toString().split(thousand).join("");
    var withoutDanglingDecimalPoint = withoutThousandSeparators.replace(getDanglingDecimalPointRegExp(decimal), "");
    var withStandardDecimalPoint = withoutDanglingDecimalPoint.split(decimal).join(".");
    return withStandardDecimalPoint.length > 0 ? withStandardDecimalPoint : null;
};
var parse = function (value, separators) {
    if (value === null || value === "" || value === "-") {
        return null;
    }
    var numberString = convertFormattedStringToStandard(value, separators);
    if (numberString === null) {
        return null;
    }
    return parseStandardNumberString(numberString);
};
var isValid = function (value, separators) {
    return (getFormatValidationRegExp(separators).test(value) && Math.abs(parse(value, separators)) <= MAX_NUMBER);
};
var format = function (value, _a) {
    var thousand = _a.thousand, decimal = _a.decimal;
    if (value === null) {
        return "";
    }
    var _b = __read(value.toString().split("."), 2), aboveDecimal = _b[0], belowDecimal = _b[1];
    var aboveDecimalFormatted = aboveDecimal.replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + thousand);
    return belowDecimal ? "" + aboveDecimalFormatted + decimal + belowDecimal : aboveDecimalFormatted;
};
/**
 * @internal
 */
var InputWithNumberFormat = /** @class */ (function (_super) {
    __extends(InputWithNumberFormat, _super);
    function InputWithNumberFormat(props) {
        var _this = _super.call(this, props) || this;
        _this.onChange = function (value, e) {
            var _a = _this.props, separators = _a.separators, onChange = _a.onChange;
            if (_this.state.value === value) {
                return;
            }
            if (!isValid(value, separators)) {
                _this.handleCaretShift(e);
                return;
            }
            _this.setState({ value: value });
            onChange(parse(value, separators));
        };
        _this.onFocus = function (e) {
            _this.setState({ isFocused: true });
            _this.props.onFocus(e);
        };
        _this.onBlur = function (e) {
            var _a = _this.props, separators = _a.separators, onBlur = _a.onBlur;
            var value = _this.state.value;
            _this.setState({
                value: format(parse(value, separators), separators),
                isFocused: false,
            });
            onBlur(e);
        };
        _this.state = {
            value: format(props.value, props.separators),
            isFocused: false,
        };
        return _this;
    }
    InputWithNumberFormat.prototype.UNSAFE_componentWillReceiveProps = function (_a) {
        var newValue = _a.value;
        var _b = this.props, value = _b.value, separators = _b.separators;
        var isFocused = this.state.isFocused;
        if (value !== newValue && !isFocused) {
            this.setState({ value: format(newValue, separators) });
        }
    };
    InputWithNumberFormat.prototype.handleCaretShift = function (e) {
        var _this = this;
        var caretPosition = e.target.selectionStart - 1;
        this.setState({}, function () {
            _this.input.inputNodeRef.setSelectionRange(caretPosition, caretPosition);
        });
    };
    InputWithNumberFormat.prototype.render = function () {
        var _this = this;
        return (React.createElement(InputPure, __assign({}, this.props, { ref: function (ref) {
                _this.input = ref;
            }, onFocus: this.onFocus, onChange: this.onChange, onBlur: this.onBlur, value: this.state.value })));
    };
    InputWithNumberFormat.defaultProps = __assign(__assign({}, InputPure.defaultProps), { separators: DEFAULT_SEPARATORS });
    return InputWithNumberFormat;
}(React.PureComponent));
export { InputWithNumberFormat };
//# sourceMappingURL=InputWithNumberFormat.js.map