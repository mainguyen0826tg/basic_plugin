// (C) 2021 GoodData Corporation
import { isScopeCol, isSeriesCol, isRootCol, } from "./tableDescriptorTypes";
import { isAttributeColumnLocator, isMeasureColumnLocator, } from "../../columnWidths";
import invariant from "ts-invariant";
import { colMeasureLocalId } from "./colAccessors";
/**
 * Given data sheet columns, this function will traverse them in order to attempt to match the provided
 * column locators. This function works recursively, if the cols are composite (root col or scope col) then
 * after successfully matching locator, the code proceed further to search through the children.
 *
 * @param cols - columns to search
 * @param locators - column locators to match
 */
export function searchForLocatorMatch(cols, locators) {
    var found = undefined;
    var _loop_1 = function (col) {
        if (isRootCol(col)) {
            // root group is there for better presentation. can be safely skipped during search.
            found = searchForLocatorMatch(col.children, locators);
        }
        else if (isScopeCol(col)) {
            /*
             * Find attribute locator which matches current scope col's attribute - to compare apples with apples.
             *
             * Once code has that, it can compare the URI of attribute element for which this group was created with
             * the excepted attribute element in the locator.
             */
            var groupByAttributeLocalId_1 = col.attributeDescriptor.attributeHeader.localIdentifier;
            var matchingLocator_1 = locators.find(function (locator) {
                return (isAttributeColumnLocator(locator) &&
                    locator.attributeLocatorItem.attributeIdentifier === groupByAttributeLocalId_1);
            });
            if (!matchingLocator_1) {
                return { value: undefined };
            }
            var elementToMatch = matchingLocator_1.attributeLocatorItem.element;
            // while the attribute locator has element optional (for wildcard match), all the remaining code always populates
            // the attribute element.
            // TODO: revise the API, it may be that it really should not be optional in the interface.
            invariant(elementToMatch);
            if (col.header.attributeHeaderItem.uri === elementToMatch) {
                if (locators.length === 1) {
                    // elements match; see if all locators exhausted. if so, it means the width item does
                    // not contain any measure locator; it's OK to match the DataColGroup though, so mark it
                    // as found and bail out
                    found = col;
                }
                else {
                    // otherwise dive deeper to inspect the children. make sure not to send the already-matched locator.
                    var remainingLocators = locators.filter(function (locator) { return locator !== matchingLocator_1; });
                    found = searchForLocatorMatch(col.children, remainingLocators);
                }
            }
        }
        else if (isSeriesCol(col)) {
            if (locators.length > 1 || !isMeasureColumnLocator(locators[0])) {
                return { value: undefined };
            }
            if (colMeasureLocalId(col) === locators[0].measureLocatorItem.measureIdentifier) {
                found = col;
            }
        }
        if (found) {
            return { value: found };
        }
    };
    for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {
        var col = cols_1[_i];
        var state_1 = _loop_1(col);
        if (typeof state_1 === "object")
            return state_1.value;
    }
    return undefined;
}
//# sourceMappingURL=colLocatorMatching.js.map