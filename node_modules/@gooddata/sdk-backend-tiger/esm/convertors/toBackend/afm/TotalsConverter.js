import { __spreadArrays } from "tslib";
// (C) 2007-2021 GoodData Corporation
import { MeasureGroupIdentifier, } from "@gooddata/sdk-model";
import groupBy from "lodash/groupBy";
import flatMap from "lodash/flatMap";
import isEmpty from "lodash/isEmpty";
import { TotalFunction } from "@gooddata/api-client-tiger";
/**
 * Extracts total definitions from execution definition dimensions and converts them into total specifications for
 * tiger AFM. Totals in tiger are defined more explicitly and therefore also more generally. Specifically a total is
 * defined by `includedDimensions`, i.e. the actual dimension on which it will be computed. Also there's a possibility
 * to compute totals only for some attribute values from an attribute in a dimension. While this is again working
 * for any attribute (e.g. compute totals only for US column of Country attribute) it's probably mostly useful only in
 * case of the measureGroup pseudo-attribute.
 *
 * TODO: subtotals
 */
export function convertTotals(def) {
    var allDimensionIndexes = def.dimensions.map(function (_dim, idx) { return idx; });
    return withTotals(def.dimensions, function (dimIdx, _typeIdx, totalsOfType) {
        // (one-dimensional) grand total is defined in Tiger by all dimensions except the current one
        var includedDimensionIndexes = allDimensionIndexes.filter(function (idx) { return dimIdx != idx; });
        var measureIdentifiers = totalsOfType.map(function (total) { return total.measureIdentifier; });
        var includedDimensionss = includedDimensionIndexes.map(function (includedDimIdx) {
            var _a, _b;
            var dim = def.dimensions[includedDimIdx];
            var dimensionAttributesValues = dim.itemIdentifiers.includes(MeasureGroupIdentifier)
                ? { dimensionAttributesValues: (_a = {}, _a[MeasureGroupIdentifier] = measureIdentifiers, _a) }
                : null;
            // FIXME synchronize dimensionIdentifier naming with convertDimensions
            return _b = {}, _b["dim_" + includedDimIdx] = dimensionAttributesValues, _b;
        });
        var totalType = totalsOfType[0].type;
        return {
            localIdentifier: totalLocalIdentifier(totalType, dimIdx),
            function: convertTotalType(totalType),
            includedDimensions: Object.assign.apply(Object, __spreadArrays([{}], includedDimensionss)),
        };
    });
}
/**
 * Traverse given dimensions and their total definitions, group those by total type and call totalProcessor on each
 * of these groups, together with current dimension index (dimIdx) and total type index in that dimension (typeIdx).
 *
 * This function captures the contract between execution response and execution result. Both of these response
 * structures are synchronized using local identifiers induced from dimIdx typeIdx. In the future the function should
 * be replaced by explicit concept of total local identifiers both in ITotal and ITotalDescriptor. Currently, given
 * the rather limit functionality of general totals API, it's needed/useful only in Tiger.
 */
export function withTotals(dimensions, totalProcessor) {
    validateTotals(dimensions);
    return flatMap(dimensions, function (dim, dimIdx) {
        var totalsByType = groupBy(dim.totals || [], function (total) { return total.type; });
        return Object.keys(totalsByType).map(function (type, typeIdx) {
            return totalProcessor(dimIdx, typeIdx, totalsByType[type]);
        });
    });
}
export function totalLocalIdentifier(type, dimIdx) {
    return "total_" + dimIdx + "_" + type;
}
function validateTotals(dimensions) {
    var _a;
    var _loop_1 = function (dim) {
        if (isEmpty(dim.totals)) {
            return "continue";
        }
        var firstDimensionItem = dim.itemIdentifiers[0];
        (_a = dim.totals) === null || _a === void 0 ? void 0 : _a.forEach(function (totalDef) {
            if (totalDef.attributeIdentifier != firstDimensionItem) {
                throw new Error("Tiger backend does not support subtotals.");
            }
        });
        var oppositeDimensions = dimensions.filter(function (dim0) { return dim != dim0; });
        // NOTE measureGroup is assumed to be correctly placed at at most one dimension (checked elsewhere)
        if (!oppositeDimensions.some(containsMeasureGroup)) {
            throw new Error('Grand total must be defined opposite to some dimension containing "measure group".');
        }
    };
    for (var _i = 0, dimensions_1 = dimensions; _i < dimensions_1.length; _i++) {
        var dim = dimensions_1[_i];
        _loop_1(dim);
    }
}
function containsMeasureGroup(dim) {
    return dim.itemIdentifiers.includes(MeasureGroupIdentifier);
}
function convertTotalType(type) {
    if (type === "sum") {
        return TotalFunction.SUM;
    }
    if (type === "max") {
        return TotalFunction.MAX;
    }
    if (type === "min") {
        return TotalFunction.MIN;
    }
    if (type === "avg") {
        return TotalFunction.AVG;
    }
    if (type === "med") {
        return TotalFunction.MED;
    }
    // type === "nat"
    throw new Error("Tiger backend does not support native totals.");
}
//# sourceMappingURL=TotalsConverter.js.map