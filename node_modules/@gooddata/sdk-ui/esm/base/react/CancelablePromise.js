import { __extends } from "tslib";
// (C) 2019-2021 GoodData Corporation
import isError from "lodash/isError";
/**
 * @internal
 */
var CANCEL_ERROR_MESSAGE = "Canceled";
/**
 * @internal
 */
var CancelError = /** @class */ (function (_super) {
    __extends(CancelError, _super);
    function CancelError(reason) {
        var _this = _super.call(this, CANCEL_ERROR_MESSAGE) || this;
        _this.reason = reason;
        // https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work
        Object.setPrototypeOf(_this, CancelError.prototype);
        return _this;
    }
    /**
     * Underlying cause of this error (if any).
     */
    CancelError.prototype.getReason = function () {
        return this.reason;
    };
    return CancelError;
}(Error));
export { CancelError };
/**
 * @internal
 */
export var isCancelError = function (obj) {
    return isError(obj) && obj.message === CANCEL_ERROR_MESSAGE;
};
/**
 * !!! USE WITH CAUTION !!! Opinionated utility to wrap promise and make it cancelable
 *
 * - It does not stop original promise execution after canceling, it just does not care about it's results anymore
 * (for example when react component unmounts)
 * - This is not meant to be universal solution to make promises cancelable, it's not easily composable,
 * and it's not good to solve more complex async logic
 * - For cancelable async operations, there are much better abstractions than promises, for example Tasks,
 * however there is no standard for this in JavaScript
 *
 * @internal
 */
export function makeCancelable(promise) {
    var cancelReason;
    var hasCanceled = false;
    var hasFulfilled = false;
    var wrappedPromise = new Promise(function (resolve, reject) {
        promise.then(function (value) {
            if (hasCanceled) {
                reject(new CancelError(cancelReason));
            }
            else {
                hasFulfilled = true;
                resolve(value);
            }
        }, function (error) {
            if (hasCanceled) {
                reject(new CancelError(cancelReason));
            }
            else {
                hasFulfilled = true;
                reject(error);
            }
        });
    });
    return {
        promise: wrappedPromise,
        cancel: function (reason) {
            hasCanceled = true;
            cancelReason = reason;
        },
        getHasCanceled: function () { return hasCanceled; },
        getHasFulfilled: function () { return hasFulfilled; },
    };
}
//# sourceMappingURL=CancelablePromise.js.map