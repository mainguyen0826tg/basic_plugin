import { __assign, __spreadArrays } from "tslib";
// (C) 2019-2020 GoodData Corporation
import { getPushpinColors } from "./geoChartColor";
import { DEFAULT_CLUSTER_RADIUS, DEFAULT_CLUSTER_MAX_ZOOM, PUSHPIN_SIZE_OPTIONS_MAP, } from "./constants/geoChart";
import { getMinMax } from "./helpers/geoChart/common";
function transformPushpinDataSource(dataSourceProps) {
    var _a, _b, _c, _d, _e, _f, _g;
    var config = dataSourceProps.config, geoData = dataSourceProps.geoData, colorStrategy = dataSourceProps.colorStrategy;
    var color = geoData.color, location = geoData.location, segment = geoData.segment, size = geoData.size, tooltipText = geoData.tooltipText;
    if (!location) {
        /*
         * short-circuit the processing at this point. if there is no location data then the featurs will
         * be empty
         */
        return [];
    }
    var _h = (config || {}).points, geoPointsConfig = _h === void 0 ? {} : _h;
    var locationNameTitle = tooltipText ? tooltipText.name : "";
    var colorTitle = color ? color.name : "";
    var sizeTitle = size ? size.name : "";
    var segmentTitle = segment ? segment.name : "";
    var hasSize = size !== undefined;
    var locationData = location.data;
    var locationNameData = (_a = tooltipText === null || tooltipText === void 0 ? void 0 : tooltipText.data) !== null && _a !== void 0 ? _a : [];
    var segmentData = (_b = segment === null || segment === void 0 ? void 0 : segment.data) !== null && _b !== void 0 ? _b : [];
    var segmentUris = (_c = segment === null || segment === void 0 ? void 0 : segment.uris) !== null && _c !== void 0 ? _c : [];
    var sizeData = (_d = size === null || size === void 0 ? void 0 : size.data) !== null && _d !== void 0 ? _d : [];
    var _j = getMinMax(sizeData), minSizeFromData = _j.min, maxSizeFromData = _j.max;
    var colorData = (_e = color === null || color === void 0 ? void 0 : color.data) !== null && _e !== void 0 ? _e : [];
    var sizeFormat = (_f = size === null || size === void 0 ? void 0 : size.format) !== null && _f !== void 0 ? _f : "";
    var colorFormat = (_g = color === null || color === void 0 ? void 0 : color.format) !== null && _g !== void 0 ? _g : "";
    var pushpinColors = getPushpinColors(colorData, segmentData, colorStrategy);
    return locationData.reduce(function (result, coordinates, index) {
        if (!coordinates) {
            return result;
        }
        var lat = coordinates.lat, lng = coordinates.lng;
        var pushpinSize = hasSize
            ? calculateSizeInPixel(sizeData[index], minSizeFromData, maxSizeFromData, geoPointsConfig)
            : PUSHPIN_SIZE_OPTIONS_MAP.min["default"];
        var colorValue = colorData[index];
        var segmentValue = segmentData[index];
        var segmentUri = segmentUris[index];
        var pushpinColor = pushpinColors[index] || pushpinColors[0] || {};
        return __spreadArrays(result, [
            {
                type: "Feature",
                geometry: {
                    type: "Point",
                    coordinates: [lng, lat]
                },
                properties: {
                    pushpinSize: pushpinSize,
                    locationName: {
                        title: locationNameTitle,
                        value: locationNameData[index]
                    },
                    locationIndex: index,
                    color: __assign(__assign({}, pushpinColor), { title: colorTitle, value: colorValue, format: colorFormat }),
                    size: {
                        title: sizeTitle,
                        value: sizeData[index],
                        format: sizeFormat
                    },
                    segment: {
                        title: segmentTitle,
                        value: segmentValue,
                        uri: segmentUri
                    }
                }
            },
        ]);
    }, []);
}
// transform data value to pushpin size in pixel
var calculateSizeInPixel = function (dataValue, minSize, maxSize, geoPointsConfig) {
    if (minSize === maxSize || dataValue === null) {
        return PUSHPIN_SIZE_OPTIONS_MAP.min["default"];
    }
    var _a = geoPointsConfig || {}, _b = _a.minSize, minSizeFromConfig = _b === void 0 ? "default" : _b, _c = _a.maxSize, maxSizeFromConfig = _c === void 0 ? "default" : _c;
    var minSizeInPixel = PUSHPIN_SIZE_OPTIONS_MAP.min[minSizeFromConfig];
    var maxSizeInPixel = PUSHPIN_SIZE_OPTIONS_MAP.max[maxSizeFromConfig];
    return ((dataValue - minSize) * (maxSizeInPixel - minSizeInPixel)) / (maxSize - minSize) + minSizeInPixel;
};
export var createPushpinDataSource = function (dataSourceProps) {
    var hasClustering = dataSourceProps.hasClustering;
    var source = {
        type: "geojson",
        data: {
            type: "FeatureCollection",
            features: transformPushpinDataSource(dataSourceProps)
        }
    };
    if (hasClustering) {
        return __assign(__assign({}, source), { cluster: true, clusterMaxZoom: DEFAULT_CLUSTER_MAX_ZOOM, clusterRadius: DEFAULT_CLUSTER_RADIUS });
    }
    return source;
};
//# sourceMappingURL=geoChartDataSource.js.map