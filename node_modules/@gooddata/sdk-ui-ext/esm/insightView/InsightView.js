import { __assign, __awaiter, __extends, __generator } from "tslib";
// (C) 2019 GoodData Corporation
import React, { useCallback, useMemo, useRef, useState } from "react";
import { injectIntl } from "react-intl";
import { idRef, insightTitle, insightVisualizationUrl, areObjRefsEqual, insightRef, } from "@gooddata/sdk-model";
import { withContexts, DefaultLocale, LoadingComponent as DefaultLoading, ErrorComponent as DefaultError, IntlWrapper, useCancelablePromise, convertError, } from "@gooddata/sdk-ui";
import InsightTitle from "./InsightTitle";
import { InsightRenderer } from "./InsightRenderer";
import { InsightError } from "./InsightError";
import { colorPaletteDataLoaderFactory, insightDataLoaderFactory, userWorkspaceSettingsDataLoaderFactory, } from "../dataLoaders";
var InsightViewCore = function (props) {
    var insight = props.insight, backend = props.backend, workspace = props.workspace, filters = props.filters, executeByReference = props.executeByReference, showTitle = props.showTitle, colorPalette = props.colorPalette, config = props.config, execConfig = props.execConfig, locale = props.locale, drillableItems = props.drillableItems, onDrill = props.onDrill, onLoadingChanged = props.onLoadingChanged, onExportReady = props.onExportReady, onError = props.onError, onInsightLoaded = props.onInsightLoaded, pushData = props.pushData, _a = props.ErrorComponent, ErrorComponent = _a === void 0 ? DefaultError : _a, _b = props.LoadingComponent, LoadingComponent = _b === void 0 ? DefaultLoading : _b, _c = props.TitleComponent, TitleComponent = _c === void 0 ? InsightTitle : _c;
    var _d = useState({
        isVisualizationLoading: false,
        visualizationError: undefined,
    }), state = _d[0], setState = _d[1];
    // ref of the insight last reported by the onInsightLoaded
    var lastReportedRef = useRef();
    var _e = useCancelablePromise({
        promise: function () { return __awaiter(void 0, void 0, void 0, function () {
            var ref, insightData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        ref = typeof insight === "string" ? idRef(insight, "insight") : insight;
                        return [4 /*yield*/, insightDataLoaderFactory
                                .forWorkspace(workspace)
                                .getInsight(backend, ref)];
                    case 1:
                        insightData = _a.sent();
                        if (!lastReportedRef.current ||
                            !areObjRefsEqual(lastReportedRef.current, insightRef(insightData))) {
                            onInsightLoaded === null || onInsightLoaded === void 0 ? void 0 : onInsightLoaded(insightData);
                            lastReportedRef.current = insightRef(insightData);
                        }
                        if (executeByReference) {
                            /*
                             * In execute-by-reference, filter merging happens on the server
                             */
                            return [2 /*return*/, insightData];
                        }
                        /*
                         * In freeform execution, frontend is responsible for filter merging. Code defers the merging to the
                         * implementation of analytical backend because the merging may first need to unify how the different
                         * filter entities are referenced (id vs uri).
                         */
                        return [2 /*return*/, backend
                                .workspace(workspace)
                                .insights()
                                .getInsightWithAddedFilters(insightData, filters !== null && filters !== void 0 ? filters : [])];
                }
            });
        }); },
    }, [insight, backend, workspace, executeByReference, filters, onInsightLoaded]), insightError = _e.error, insightResult = _e.result, insightStatus = _e.status;
    var _f = useCancelablePromise({
        promise: function () {
            return colorPaletteDataLoaderFactory.forWorkspace(workspace).getColorPalette(backend);
        },
    }, [backend, workspace]), colorPaletteError = _f.error, colorPaletteResult = _f.result, colorPaletteStatus = _f.status;
    var _g = useCancelablePromise({
        promise: function () {
            return userWorkspaceSettingsDataLoaderFactory
                .forWorkspace(workspace)
                .getUserWorkspaceSettings(backend);
        },
    }, [backend, workspace]), workspaceSettingsError = _g.error, workspaceSettingsResult = _g.result, workspaceSettingsStatus = _g.status;
    // extract the url outside of backendWithTelemetry and use it as a dependency instead of the whole insight
    // this reduces the amount of re-renders in case just filters change for example
    var currentInsightVisualizationUrl = insightResult && insightVisualizationUrl(insightResult);
    var backendWithTelemetry = useMemo(function () {
        var telemetryProps = __assign({}, props);
        // add a fake prop so that the type of the visualization rendered is present in the telemetry
        if (currentInsightVisualizationUrl) {
            var key = "visualizationUrl_" + currentInsightVisualizationUrl;
            telemetryProps[key] = true;
        }
        return backend.withTelemetry("InsightView", telemetryProps);
    }, [currentInsightVisualizationUrl, backend]);
    var handleLoadingChanged = useCallback(function (_a) {
        var isLoading = _a.isLoading;
        setState(function (oldState) {
            return {
                isVisualizationLoading: isLoading,
                // if we started loading, any previous vis error is obsolete at this point, get rid of it
                visualizationError: isLoading ? undefined : oldState.visualizationError,
            };
        });
        onLoadingChanged === null || onLoadingChanged === void 0 ? void 0 : onLoadingChanged({ isLoading: isLoading });
    }, [onLoadingChanged]);
    var handleError = useCallback(function (visualizationError) {
        setState(function (oldState) {
            return __assign(__assign({}, oldState), { visualizationError: visualizationError });
        });
        onError === null || onError === void 0 ? void 0 : onError(visualizationError);
    }, [onError]);
    var isDataLoading = insightStatus === "loading" ||
        insightStatus === "pending" ||
        colorPaletteStatus === "loading" ||
        colorPaletteStatus === "pending" ||
        workspaceSettingsStatus === "loading" ||
        workspaceSettingsStatus === "pending";
    var resolveInsightTitle = function (insight) {
        switch (typeof showTitle) {
            case "string":
                return showTitle;
            case "boolean":
                return !isDataLoading && showTitle && insight ? insightTitle(insight) : undefined;
            case "function":
                return !isDataLoading && insight && showTitle(insight);
            default:
                return undefined;
        }
    };
    var resolvedTitle = resolveInsightTitle(insightResult);
    var isLoadingShown = isDataLoading || state.isVisualizationLoading;
    var error = state.visualizationError || insightError || colorPaletteError || workspaceSettingsError;
    return (React.createElement("div", { className: "insight-view-container" },
        resolvedTitle && React.createElement(TitleComponent, { title: resolvedTitle }),
        isLoadingShown && React.createElement(LoadingComponent, { className: "insight-view-loader" }),
        error && !isDataLoading && (React.createElement(InsightError, { error: convertError(error), ErrorComponent: ErrorComponent })),
        React.createElement("div", { className: "insight-view-visualization", 
            // make the visualization div 0 height so that the loading component can take up the whole area
            style: isLoadingShown ? { height: 0 } : undefined },
            React.createElement(InsightRenderer, { insight: insightResult, workspace: workspace, backend: backendWithTelemetry, colorPalette: colorPalette !== null && colorPalette !== void 0 ? colorPalette : colorPaletteResult, config: config, execConfig: execConfig, drillableItems: drillableItems, executeByReference: executeByReference, filters: filters, locale: locale || (workspaceSettingsResult === null || workspaceSettingsResult === void 0 ? void 0 : workspaceSettingsResult.locale) || DefaultLocale, settings: workspaceSettingsResult, ErrorComponent: ErrorComponent, LoadingComponent: LoadingComponent, onDrill: onDrill, onError: handleError, onExportReady: onExportReady, onLoadingChanged: handleLoadingChanged, pushData: pushData }))));
};
export var IntlInsightView = withContexts(injectIntl(InsightViewCore));
/**
 * Renders insight which was previously created and saved in the Analytical Designer.
 *
 * @public
 */
var InsightView = /** @class */ (function (_super) {
    __extends(InsightView, _super);
    function InsightView() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    InsightView.prototype.render = function () {
        return (React.createElement(IntlWrapper, { locale: this.props.locale },
            React.createElement(IntlInsightView, __assign({}, this.props))));
    };
    return InsightView;
}(React.Component));
export { InsightView };
//# sourceMappingURL=InsightView.js.map