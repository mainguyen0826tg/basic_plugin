import { __assign, __extends, __spreadArrays } from "tslib";
// (C) 2007-2018 GoodData Corporation
import React from "react";
import { v4 } from "uuid";
import set from "lodash/set";
import isEqual from "lodash/isEqual";
import noop from "lodash/noop";
import partial from "lodash/partial";
import throttle from "lodash/throttle";
import isNil from "lodash/isNil";
import cx from "classnames";
import { Chart } from "./Chart";
import { isPieOrDonutChart, isOneOfTypes, isHeatmap } from "../chartTypes/_util/common";
import { VisualizationTypes } from "@gooddata/sdk-ui";
import { alignChart } from "../chartTypes/_chartCreators/helpers";
import { Legend, getLegendDetails, } from "@gooddata/sdk-ui-vis-commons";
import { Bubble, BubbleHoverTrigger, Icon } from "@gooddata/sdk-ui-kit";
import { BOTTOM, LEFT, RIGHT, TOP } from "../typings/mess";
/**
 * @internal
 */
export var FLUID_LEGEND_THRESHOLD = 768;
export function renderChart(props) {
    return React.createElement(Chart, __assign({}, props));
}
export function renderLegend(props) {
    return React.createElement(Legend, __assign({}, props));
}
var HighChartsRenderer = /** @class */ (function (_super) {
    __extends(HighChartsRenderer, _super);
    function HighChartsRenderer(props) {
        var _this = _super.call(this, props) || this;
        _this.highchartsRendererRef = React.createRef(); // whole component = legend + chart
        _this.containerId = "visualization-" + v4();
        _this.onWindowResize = function () {
            _this.setState({
                showFluidLegend: _this.shouldShowFluid(),
            });
            _this.realignPieOrDonutChart();
        };
        _this.throttledOnWindowResize = throttle(_this.onWindowResize, 100);
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        _this.onLegendItemClick = function (item) {
            _this.setState({
                legendItemsEnabled: set(__spreadArrays(_this.state.legendItemsEnabled), item.legendIndex, !_this.state.legendItemsEnabled[item.legendIndex]),
            });
        };
        _this.setChartRef = function (chartRef) {
            _this.chartRef = chartRef;
        };
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        _this.onChartSelection = function (event) {
            var chartWrapper = event.target.renderTo.parentElement;
            var resetZoomButton = chartWrapper.closest(".visualization").querySelector(".viz-zoom-out");
            if (event.resetSelection) {
                resetZoomButton.style.display = "none";
            }
            else {
                resetZoomButton.style.display = "block";
            }
            return undefined;
        };
        _this.onZoomOutButtonClick = function () {
            _this.chartRef.getChart().zoomOut();
        };
        _this.state = {
            legendItemsEnabled: [],
            showFluidLegend: _this.shouldShowFluid(),
        };
        return _this;
    }
    HighChartsRenderer.prototype.shouldShowFluid = function () {
        var _a = this.props, documentObj = _a.documentObj, legend = _a.legend;
        return (documentObj.documentElement.clientWidth < FLUID_LEGEND_THRESHOLD &&
            (legend === null || legend === void 0 ? void 0 : legend.responsive) !== "autoPositionWithPopup");
    };
    HighChartsRenderer.prototype.UNSAFE_componentWillMount = function () {
        this.resetLegendState(this.props);
    };
    HighChartsRenderer.prototype.componentDidMount = function () {
        var _this = this;
        // http://stackoverflow.com/questions/18240254/highcharts-width-exceeds-container-div-on-first-load
        setTimeout(function () {
            if (_this.chartRef) {
                var chart = _this.chartRef.getChart();
                if (chart.container && chart.container.style) {
                    chart.container.style.height = (_this.props.height && String(_this.props.height)) || "100%";
                    chart.container.style.position = _this.props.height ? "relative" : "absolute";
                    chart.reflow();
                }
            }
        }, 0);
        this.props.onLegendReady({
            legendItems: this.getItems(this.props.legend.items),
        });
        window.addEventListener("resize", this.throttledOnWindowResize);
    };
    HighChartsRenderer.prototype.componentWillUnmount = function () {
        this.throttledOnWindowResize.cancel();
        window.removeEventListener("resize", this.throttledOnWindowResize);
    };
    HighChartsRenderer.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        var _a, _b, _c, _d;
        var thisLegendItems = (_b = (_a = this.props.legend) === null || _a === void 0 ? void 0 : _a.items) !== null && _b !== void 0 ? _b : [];
        var nextLegendItems = (_d = (_c = nextProps.legend) === null || _c === void 0 ? void 0 : _c.items) !== null && _d !== void 0 ? _d : [];
        var hasLegendChanged = !isEqual(thisLegendItems, nextLegendItems);
        if (hasLegendChanged) {
            this.resetLegendState(nextProps);
        }
        if (!isEqual(this.props.legend.items, nextProps.legend.items)) {
            this.props.onLegendReady({
                legendItems: this.getItems(nextProps.legend.items),
            });
        }
    };
    HighChartsRenderer.prototype.getFlexDirection = function (position) {
        if (position === TOP || position === BOTTOM) {
            return "column";
        }
        return "row";
    };
    HighChartsRenderer.prototype.getItems = function (items) {
        var _this = this;
        return items.map(function (i) {
            return {
                name: i.name,
                color: i.color,
                onClick: partial(_this.onLegendItemClick, i),
            };
        });
    };
    HighChartsRenderer.prototype.resetLegendState = function (props) {
        var _a, _b, _c;
        var legendItemsCount = (_c = (_b = (_a = props.legend) === null || _a === void 0 ? void 0 : _a.items) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
        this.setState({
            legendItemsEnabled: new Array(legendItemsCount).fill(true),
        });
    };
    HighChartsRenderer.prototype.createChartConfig = function (chartConfig, legendItemsEnabled) {
        var _a, _b;
        var series = chartConfig.series, chart = chartConfig.chart, xAxis = chartConfig.xAxis, yAxis = chartConfig.yAxis;
        var selectionEvent = chart.zoomType
            ? {
                selection: this.onChartSelection,
            }
            : {};
        var firstSeriesTypes = [
            VisualizationTypes.PIE,
            VisualizationTypes.DONUT,
            VisualizationTypes.TREEMAP,
        ];
        var multipleSeries = isOneOfTypes(chart.type, firstSeriesTypes);
        var items = isOneOfTypes(chart.type, firstSeriesTypes) ? (_a = series === null || series === void 0 ? void 0 : series[0]) === null || _a === void 0 ? void 0 : _a.data : series;
        var updatedItems = items.map(function (item, itemIndex) {
            var visible = legendItemsEnabled[itemIndex] !== undefined ? legendItemsEnabled[itemIndex] : true;
            return __assign(__assign({}, item), { visible: isNil(item.visible) ? visible : item.visible });
        });
        var updatedSeries = updatedItems;
        if (multipleSeries) {
            updatedSeries = __spreadArrays([
                __assign(__assign({}, series === null || series === void 0 ? void 0 : series[0]), { data: updatedItems })
            ], series.slice(1));
        }
        return __assign(__assign({}, chartConfig), { chart: __assign(__assign({}, chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.chart), { events: __assign(__assign({}, (_b = chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.chart) === null || _b === void 0 ? void 0 : _b.events), selectionEvent) }), series: updatedSeries, yAxis: yAxis.map(function (ax) {
                var _a;
                return (__assign(__assign({}, ax), { title: __assign(__assign({}, ax === null || ax === void 0 ? void 0 : ax.title), { style: __assign(__assign({}, (_a = ax === null || ax === void 0 ? void 0 : ax.title) === null || _a === void 0 ? void 0 : _a.style), { textOverflow: "ellipsis", overflow: "hidden" }) }) }));
            }), 
            // perform a shallow copy of axis
            // (otherwise there's a highcharts internal error on smallest responsive charts)
            xAxis: xAxis.map(function (ax) { return (__assign({}, ax)); }) });
    };
    HighChartsRenderer.prototype.renderLegend = function (legendDetails, contentRect, containerId) {
        var _a = this.props, chartOptions = _a.chartOptions, legend = _a.legend, height = _a.height, legendRenderer = _a.legendRenderer, locale = _a.locale;
        var items = legend.items, format = legend.format;
        var showFluidLegend = this.state.showFluidLegend;
        if (!legend.enabled) {
            return null;
        }
        var type = chartOptions.type;
        if (isPieOrDonutChart(type)) {
            type = VisualizationTypes.PIE;
        }
        var legendProps = {
            responsive: legend.responsive,
            enableBorderRadius: legend.enableBorderRadius,
            seriesMapper: legend.seriesMapper,
            series: items,
            onItemClick: this.onLegendItemClick,
            legendItemsEnabled: this.state.legendItemsEnabled,
            heatmapLegend: isHeatmap(type),
            height: height,
            legendLabel: legendDetails === null || legendDetails === void 0 ? void 0 : legendDetails.name,
            maximumRows: legendDetails === null || legendDetails === void 0 ? void 0 : legendDetails.maxRows,
            position: legendDetails.position,
            format: format,
            locale: locale,
            showFluidLegend: showFluidLegend,
            validateOverHeight: noop,
            contentDimensions: contentRect === null || contentRect === void 0 ? void 0 : contentRect.client,
            containerId: containerId,
        };
        return legendRenderer(legendProps);
    };
    HighChartsRenderer.prototype.renderHighcharts = function () {
        // shrink chart to give space to legend items
        var style = { flex: "1 1 auto", position: "relative", overflow: "hidden" };
        var config = this.createChartConfig(this.props.hcOptions, this.state.legendItemsEnabled);
        var chartProps = {
            domProps: { className: "viz-react-highchart-wrap gd-viz-highchart-wrap", style: style },
            ref: this.setChartRef,
            config: config,
            callback: this.props.afterRender,
        };
        return this.props.chartRenderer(chartProps);
    };
    HighChartsRenderer.prototype.renderZoomOutButton = function () {
        var _a, _b;
        var _c = this.props, chart = _c.hcOptions.chart, theme = _c.theme, resetZoomButtonTooltip = _c.resetZoomButtonTooltip;
        if (chart && chart.zoomType) {
            return (React.createElement(BubbleHoverTrigger, { tagName: "abbr", hideDelay: 100, showDelay: 100, className: "gd-bubble-trigger-zoom-out" },
                React.createElement("button", { className: "viz-zoom-out s-zoom-out", onClick: this.onZoomOutButtonClick, style: { display: "none" } },
                    React.createElement(Icon.Undo, { width: 20, height: 20, color: (_b = (_a = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _a === void 0 ? void 0 : _a.complementary) === null || _b === void 0 ? void 0 : _b.c7 })),
                React.createElement(Bubble, { alignPoints: [{ align: "cr cl" }, { align: "cl cr" }] }, resetZoomButtonTooltip)));
        }
        return null;
    };
    HighChartsRenderer.prototype.renderVisualization = function () {
        var _a;
        var _b = this.props, legend = _b.legend, chartOptions = _b.chartOptions, contentRect = _b.contentRect;
        var legendDetailOptions = {
            showFluidLegend: this.state.showFluidLegend,
            contentRect: contentRect,
            isHeatmap: isHeatmap(chartOptions.type),
            legendLabel: chartOptions.legendLabel,
        };
        var legendDetails = getLegendDetails(legend.position, legend.responsive, legendDetailOptions);
        if (!legendDetails) {
            return null;
        }
        var classes = cx("viz-line-family-chart-wrap", "s-viz-line-family-chart-wrap", legend.responsive === true ? "responsive-legend" : "non-responsive-legend", (_a = {},
            _a["flex-direction-" + this.getFlexDirection(legendDetails.position)] = true,
            _a["legend-position-bottom"] = legendDetails.position === BOTTOM,
            _a), this.containerId);
        var legendPosition = legendDetails.position;
        var isLegendRenderedFirst = legendPosition === TOP || legendPosition === LEFT || this.state.showFluidLegend;
        return (React.createElement("div", { className: classes, ref: this.highchartsRendererRef },
            this.renderZoomOutButton(),
            isLegendRenderedFirst && this.renderLegend(legendDetails, contentRect, this.containerId),
            this.renderHighcharts(),
            !isLegendRenderedFirst && this.renderLegend(legendDetails, contentRect, this.containerId)));
    };
    HighChartsRenderer.prototype.render = function () {
        return this.renderVisualization();
    };
    HighChartsRenderer.prototype.realignPieOrDonutChart = function () {
        var _a = this.props.chartOptions, type = _a.type, verticalAlign = _a.verticalAlign;
        var chartRef = this.chartRef;
        if (isPieOrDonutChart(type) && chartRef) {
            alignChart(chartRef.getChart(), verticalAlign);
        }
    };
    HighChartsRenderer.defaultProps = {
        afterRender: noop,
        height: null,
        legend: {
            enabled: true,
            responsive: false,
            position: RIGHT,
        },
        chartRenderer: renderChart,
        legendRenderer: renderLegend,
        onLegendReady: noop,
        documentObj: document,
    };
    return HighChartsRenderer;
}(React.PureComponent));
export { HighChartsRenderer };
//# sourceMappingURL=HighChartsRenderer.js.map