import { __assign } from "tslib";
import findIndex from "lodash/findIndex";
import { COLUMN_ATTRIBUTE_COLUMN, COLUMN_GROUPING_DELIMITER, MEASURE_COLUMN, ROW_ATTRIBUTE_COLUMN, } from "../base/constants";
import { agColId, ColumnGroupingDescriptorId, } from "./tableDescriptorTypes";
import { sortDirection } from "@gooddata/sdk-model";
import { attributeSortMatcher, measureSortMatcher } from "./colSortItemMatching";
function getSortProp(initialSorts, predicate) {
    var sortIndex = findIndex(initialSorts, function (s) { return predicate(s); });
    var sort = initialSorts[sortIndex];
    return sort
        ? {
            sort: sortDirection(sort),
            // use sortedAt to make sure the order of sorts is the same as the order of columns
            sortedAt: sortIndex,
        }
        : {};
}
function createAndAddSliceColDefs(rows, state) {
    var _loop_1 = function (row) {
        var sortProp = getSortProp(state.initialSorts, function (s) { return attributeSortMatcher(row, s); });
        var cellRendererProp = !state.cellRendererPlaced ? { cellRenderer: "loadingRenderer" } : {};
        var colDef = __assign(__assign({ type: ROW_ATTRIBUTE_COLUMN, colId: row.id, field: row.id, headerName: row.attributeDescriptor.attributeHeader.formOf.name }, cellRendererProp), sortProp);
        state.rowColDefs.push(colDef);
        state.allColDefs.push(colDef);
        if (!state.cellRendererPlaced) {
            state.cellRendererPlaced = colDef;
        }
    };
    for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {
        var row = rows_1[_i];
        _loop_1(row);
    }
}
function createColumnGroupColDef(col, state) {
    var children = createColumnHeadersFromDescriptors(col.children, state);
    if (children.length === 0) {
        var colDef = {
            type: COLUMN_ATTRIBUTE_COLUMN,
            colId: col.id,
            headerName: col.header.attributeHeaderItem.name,
        };
        state.allColDefs.push(colDef);
        state.leafColDefs.push(colDef);
        return colDef;
    }
    else {
        var colGroup = {
            groupId: col.id,
            headerName: col.header.attributeHeaderItem.name,
            children: children,
        };
        state.allColDefs.push(colGroup);
        return colGroup;
    }
}
function createColumnHeadersFromDescriptors(cols, state) {
    var colDefs = [];
    var _loop_2 = function (col) {
        switch (col.type) {
            case "rootCol": {
                var colDef = {
                    groupId: ColumnGroupingDescriptorId,
                    children: createColumnHeadersFromDescriptors(col.children, state),
                    headerName: col.groupingAttributes
                        .map(function (attr) { return attr.attributeHeader.formOf.name; })
                        .join(COLUMN_GROUPING_DELIMITER),
                };
                colDefs.push(colDef);
                state.allColDefs.push(colDef);
                break;
            }
            case "scopeCol": {
                colDefs.push(createColumnGroupColDef(col, state));
                break;
            }
            case "seriesCol": {
                var sortProp = getSortProp(state.initialSorts, function (s) { return measureSortMatcher(col, s); });
                var cellRendererProp = !state.cellRendererPlaced ? { cellRenderer: "loadingRenderer" } : {};
                var colDef = __assign(__assign({ type: MEASURE_COLUMN, colId: col.id, field: col.id, headerName: col.seriesDescriptor.measureTitle() }, sortProp), cellRendererProp);
                colDefs.push(colDef);
                state.leafColDefs.push(colDef);
                state.allColDefs.push(colDef);
                if (!state.cellRendererPlaced) {
                    state.cellRendererPlaced = colDef;
                }
                break;
            }
        }
    };
    for (var _i = 0, cols_1 = cols; _i < cols_1.length; _i++) {
        var col = cols_1[_i];
        _loop_2(col);
    }
    return colDefs;
}
function createAndAddDataColDefs(table, state) {
    var _a;
    var cols = createColumnHeadersFromDescriptors(table.rootDataCols, state);
    (_a = state.rootColDefs).push.apply(_a, cols);
}
//
//
//
/**
 * Given table column descriptors & list of sort items, this function will create ag-grid ColDefs which mirror
 * the column descriptor. Any ColDefs whose descriptors match the sortItems will have the sorts set according
 * to the matching sort item.
 *
 * @param table - table col descriptors
 * @param initialSorts - initial table sorting definition
 */
export function createColDefsFromTableDescriptor(table, initialSorts) {
    var state = {
        initialSorts: initialSorts,
        cellRendererPlaced: undefined,
        rootColDefs: [],
        allColDefs: [],
        leafColDefs: [],
        rowColDefs: [],
    };
    createAndAddSliceColDefs(table.sliceCols, state);
    createAndAddDataColDefs(table, state);
    var idToColDef = {};
    state.allColDefs.forEach(function (colDef) { return (idToColDef[agColId(colDef)] = colDef); });
    return {
        sliceColDefs: state.rowColDefs,
        rootDataColDefs: state.rootColDefs,
        leafDataColDefs: state.leafColDefs,
        idToColDef: idToColDef,
    };
}
//# sourceMappingURL=colDefFactory.js.map