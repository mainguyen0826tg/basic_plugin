import { __spreadArrays } from "tslib";
// (C) 2020 GoodData Corporation
import { getDrillIntersection, isSomeHeaderPredicateMatched, } from "@gooddata/sdk-ui";
import { findGeoAttributesInDimension, parseGeoProperties } from "./data";
import without from "lodash/without";
import omit from "lodash/omit";
import CustomEvent from "custom-event";
function getDrillIntersectionForGeoChart(drillableItems, dv, geoData, locationIndex) {
    var measureGroupItems = dv.meta().measureDescriptors();
    var measureHeaders = measureGroupItems.slice(0, 2);
    var _a = findGeoAttributesInDimension(dv, geoData), locationAttribute = _a.locationAttribute, segmentByAttribute = _a.segmentByAttribute, tooltipTextAttribute = _a.tooltipTextAttribute;
    var _b = getAttributeHeader(locationAttribute, locationIndex), locationAttributeHeader = _b.attributeHeader, locationAttributeHeaderItem = _b.attributeHeaderItem;
    var _c = getAttributeHeader(segmentByAttribute, locationIndex), segmentByAttributeHeader = _c.attributeHeader, segmentByAttributeHeaderItem = _c.attributeHeaderItem;
    var _d = getAttributeHeader(tooltipTextAttribute, locationIndex), tooltipTextAttributeHeader = _d.attributeHeader, tooltipTextAttributeHeaderItem = _d.attributeHeaderItem;
    // pin is drillable if a drillableItem matches:
    //   pin's measure,
    //   pin's location attribute,
    //   pin's location attribute item,
    //   pin's segmentBy attribute,
    //   pin's segmentBy attribute item,
    //   pin's tooltipText attribute,
    //   pin's tooltipText attribute item,
    var drillItems = without(__spreadArrays(measureHeaders, [
        locationAttributeHeaderItem,
        locationAttributeHeader,
        segmentByAttributeHeaderItem,
        segmentByAttributeHeader,
        tooltipTextAttributeHeaderItem,
        tooltipTextAttributeHeader,
    ]), undefined);
    var drilldown = drillItems.some(function (drillableHook) {
        return isSomeHeaderPredicateMatched(drillableItems, drillableHook, dv);
    });
    if (drilldown) {
        return getDrillIntersection(drillItems);
    }
    return undefined;
}
function getAttributeHeader(attribute, dataIndex) {
    if (attribute) {
        return {
            attributeHeader: { attributeHeader: omit(attribute, "items") },
            attributeHeaderItem: attribute.items[dataIndex]
        };
    }
    return {
        attributeHeader: undefined,
        attributeHeaderItem: undefined
    };
}
export function handleGeoPushpinDrillEvent(drillableItems, drillConfig, dv, geoData, pinProperties, pinCoordinates, target) {
    var locationIndex = (pinProperties || {}).locationIndex;
    var drillIntersection = getDrillIntersectionForGeoChart(drillableItems, dv, geoData, locationIndex);
    if (!drillIntersection || !drillIntersection.length) {
        return;
    }
    var onDrill = drillConfig.onDrill;
    var lng = pinCoordinates[0], lat = pinCoordinates[1];
    var _a = parseGeoProperties(pinProperties) || {}, locationNameValue = _a.locationName.value, colorValue = _a.color.value, segmentByValue = _a.segment.value, sizeValue = _a.size.value;
    var drillContext = {
        element: "pushpin",
        intersection: drillIntersection,
        type: "pushpin",
        color: colorValue,
        location: { lat: lat, lng: lng },
        locationName: locationNameValue,
        segmentBy: segmentByValue,
        size: sizeValue
    };
    var drillEventExtended = {
        dataView: dv.dataView,
        drillContext: drillContext
    };
    if (onDrill) {
        var shouldFireEvent = onDrill(drillEventExtended);
        // if user-specified onDrill fn returns false, do not fire default DOM event
        if (shouldFireEvent !== false) {
            var event_1 = new CustomEvent("drill", {
                detail: drillEventExtended,
                bubbles: true
            });
            target.dispatchEvent(event_1);
        }
    }
}
//# sourceMappingURL=drilling.js.map