import { __spreadArrays } from "tslib";
import isString from "lodash/isString";
import range from "lodash/range";
function formatColor(red, green, blue, opacity) {
    if (opacity === void 0) { opacity = 1; }
    if (opacity === 1) {
        return "rgb(" + red + "," + green + "," + blue + ")";
    }
    return "rgba(" + red + "," + green + "," + blue + "," + opacity + ")";
}
function parseRGBColorCode(color) {
    var f = color.split(",");
    var R = parseInt(f[0].slice(4), 10);
    var G = parseInt(f[1], 10);
    var B = parseInt(f[2], 10);
    return { R: R, G: G, B: B };
}
function getCalculatedChannel(channel, index, step) {
    return Math.trunc(channel + index * step);
}
function getCalculatedColors(count, channels, steps, opacity) {
    if (opacity === void 0) { opacity = 1; }
    return range(1, count).map(function (index) {
        return formatColor(getCalculatedChannel(channels[0], index, steps[0]), getCalculatedChannel(channels[1], index, steps[1]), getCalculatedChannel(channels[2], index, steps[2]), opacity);
    });
}
function getRGBColorCode(color) {
    if (isString(color)) {
        var _a = parseRGBColorCode(color), r = _a.R, g = _a.G, b = _a.B;
        return {
            r: r,
            g: g,
            b: b
        };
    }
    return color;
}
export function getColorPalette(baseColor, opacity) {
    if (opacity === void 0) { opacity = 1; }
    var colorItemsCount = 6;
    var _a = getRGBColorCode(baseColor), r = _a.r, g = _a.g, b = _a.b;
    var channels = [r, g, b];
    var steps = channels.map(function (channel) { return (255 - channel) / colorItemsCount; });
    var generatedColors = getCalculatedColors(colorItemsCount, channels, steps, opacity);
    return __spreadArrays(generatedColors.reverse(), [formatColor(r, g, b, opacity)]);
}
export function rgbToRgba(color, opacity) {
    if (opacity === void 0) { opacity = 1; }
    var _a = parseRGBColorCode(color), R = _a.R, G = _a.G, B = _a.B;
    return formatColor(R, G, B, opacity);
}
//# sourceMappingURL=colors.js.map