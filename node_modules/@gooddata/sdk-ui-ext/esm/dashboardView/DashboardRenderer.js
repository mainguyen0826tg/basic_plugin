import { __assign } from "tslib";
// (C) 2020 GoodData Corporation
import React, { memo } from "react";
import { isWidget, UnexpectedError, widgetId, widgetUri, isDashboardLayout, isDashboardWidget, isInsightWidget, widgetType as getWidgetType, isKpiWidget, } from "@gooddata/sdk-backend-spi";
import { insightId, insightUri, areObjRefsEqual, objRefToString, } from "@gooddata/sdk-model";
import { useThemeIsLoading } from "@gooddata/sdk-ui-theme-provider";
import { DashboardLayout, getDashboardLayoutWidgetDefaultHeight, DashboardLayoutBuilder, getDashboardLayoutItemHeight, getDashboardLayoutItemHeightForRatioAndScreen, validateDashboardLayoutWidgetSize, } from "../internal";
import { DashboardWidgetRenderer, } from "./DashboardWidgetRenderer/DashboardWidgetRenderer";
import { useAlerts, useUserWorkspaceSettings } from "./contexts";
/**
 * Ensure that areObjRefsEqual() and other predicates will be working with uncontrolled user ref inputs in custom layout transformation and/or custom widget/item renderers
 */
var polluteWidgetRefsWithBothIdAndUri = function (getInsightByRef) {
    return function (item) {
        return item.widget(function (c) {
            var updatedContent = __assign({}, c);
            if (isWidget(updatedContent)) {
                updatedContent.ref = __assign(__assign({}, updatedContent.ref), { uri: widgetUri(updatedContent), identifier: widgetId(updatedContent) });
            }
            if (isInsightWidget(updatedContent)) {
                var insight = getInsightByRef(updatedContent.insight);
                updatedContent.insight = __assign(__assign({}, updatedContent.insight), { uri: insightUri(insight), identifier: insightId(insight) });
            }
            return updatedContent;
        });
    };
};
var validateItemsSize = function (getInsightByRef, enableKDWidgetCustomHeight) {
    return function (item) {
        var widget = item.facade().widget();
        if (isInsightWidget(widget)) {
            var insight = getInsightByRef(widget.insight);
            var currentWidth = item.facade().size().xl.gridWidth;
            var currentHeight = item.facade().size().xl.gridHeight;
            var _a = validateDashboardLayoutWidgetSize(currentWidth, currentHeight, "insight", insight, { enableKDWidgetCustomHeight: enableKDWidgetCustomHeight }), validWidth = _a.validWidth, validHeight = _a.validHeight;
            var validatedItem = item;
            if (currentWidth !== validWidth) {
                validatedItem = validatedItem.size({
                    xl: __assign(__assign({}, validatedItem.facade().size().xl), { gridWidth: validWidth }),
                });
            }
            if (currentHeight !== validHeight) {
                validatedItem = validatedItem.size({
                    xl: __assign(__assign({}, validatedItem.facade().size().xl), { gridHeight: validHeight }),
                });
            }
            return validatedItem;
        }
    };
};
export var DashboardRenderer = memo(function DashboardRenderer(_a) {
    var dashboardLayout = _a.dashboardLayout, filters = _a.filters, onFiltersChange = _a.onFiltersChange, filterContext = _a.filterContext, backend = _a.backend, workspace = _a.workspace, drillableItems = _a.drillableItems, onDrill = _a.onDrill, ErrorComponent = _a.ErrorComponent, onError = _a.onError, LoadingComponent = _a.LoadingComponent, className = _a.className, getVisType = _a.getVisType, getInsightByRef = _a.getInsightByRef, widgetRenderer = _a.widgetRenderer, areSectionHeadersEnabled = _a.areSectionHeadersEnabled, dashboardRef = _a.dashboardRef, transformLayout = _a.transformLayout;
    var alerts = useAlerts().alerts;
    var isThemeLoading = useThemeIsLoading();
    if (isThemeLoading) {
        // do not render the dashboard until you have the theme to avoid flash of un-styled content
        return React.createElement(LoadingComponent, null);
    }
    var userWorkspaceSettings = useUserWorkspaceSettings();
    var getWidgetAlert = function (widgetRef) { return alerts === null || alerts === void 0 ? void 0 : alerts.find(function (alert) { return areObjRefsEqual(alert.widget, widgetRef); }); };
    var selectAllItemsWithInsights = function (items) {
        return items.filter(function (item) { return item.isInsightWidgetItem(); });
    };
    var commonLayoutBuilder = DashboardLayoutBuilder.for(dashboardLayout).modifySections(function (section) {
        return section
            .modifyItems(polluteWidgetRefsWithBothIdAndUri(getInsightByRef))
            .modifyItems(validateItemsSize(getInsightByRef, userWorkspaceSettings.enableKDWidgetCustomHeight), selectAllItemsWithInsights);
    });
    var transformedLayout = transformLayout
        ? transformLayout(commonLayoutBuilder, {
            getWidgetAlert: getWidgetAlert,
            getInsight: getInsightByRef,
            filters: filters,
        }).build()
        : commonLayoutBuilder.build();
    return (React.createElement(DashboardLayout, { layout: transformedLayout, itemKeyGetter: function (keyGetterProps) {
            var widget = keyGetterProps.item.widget();
            if (isWidget(widget)) {
                return objRefToString(widget.ref);
            }
            return keyGetterProps.item.index().toString();
        }, widgetRenderer: function (renderProps) {
            var item = renderProps.item, screen = renderProps.screen, DefaultWidgetRenderer = renderProps.DefaultWidgetRenderer;
            var visType;
            var widgetType;
            var insight;
            var content;
            var widget = item.widget();
            if (isDashboardLayout(widget)) {
                throw new UnexpectedError("Nested layouts not yet supported.");
            }
            if (isWidget(widget)) {
                visType = getVisType(widget);
                widgetType = getWidgetType(widget);
            }
            if (isInsightWidget(widget)) {
                insight = getInsightByRef(widget.insight);
                content = insight;
            }
            if (isKpiWidget(widget)) {
                content = widget.kpi;
            }
            var currentSize = item.size()[screen];
            var minHeight = getDashboardLayoutItemHeight(currentSize) ||
                (!currentSize.heightAsRatio
                    ? getDashboardLayoutWidgetDefaultHeight(userWorkspaceSettings, widgetType, content)
                    : undefined);
            var height = currentSize.heightAsRatio && !currentSize.gridHeight
                ? getDashboardLayoutItemHeightForRatioAndScreen(currentSize, screen)
                : undefined;
            var allowOverflow = !!currentSize.heightAsRatio;
            var computedRenderProps = {
                allowOverflow: allowOverflow,
                minHeight: minHeight,
                height: height,
            };
            var alert = isWidget(widget)
                ? alerts === null || alerts === void 0 ? void 0 : alerts.find(function (alert) { return areObjRefsEqual(alert.widget, widget.ref); }) : undefined;
            var widgetRenderProps = {
                insight: insight,
                dashboardRef: dashboardRef,
                ErrorComponent: ErrorComponent,
                LoadingComponent: LoadingComponent,
                drillableItems: drillableItems,
                filters: filters,
                onFiltersChange: onFiltersChange,
                filterContext: filterContext,
                onDrill: onDrill,
                onError: onError,
                workspace: workspace,
                backend: backend,
                widget: isWidget(widget) ? widget : undefined,
                visType: visType,
                screen: screen,
                alert: alert,
            };
            var renderedWidget = isWidget(widget) ? (React.createElement(DashboardWidgetRenderer, __assign({}, widgetRenderProps))) : null;
            var predicates = {
                isCustomWidget: function () { return !isDashboardWidget(widget); },
                isWidgetWithRef: function (ref) { return isWidget(widget) && areObjRefsEqual(ref, widget.ref); },
                isWidgetWithKpiRef: function (ref) {
                    return isWidget(widget) && widget.type === "kpi" && areObjRefsEqual(ref, widget.ref);
                },
                isWidgetWithKpiType: function (comparisonType) {
                    return isWidget(widget) &&
                        widget.type === "kpi" &&
                        comparisonType === widget.kpi.comparisonType;
                },
                isWidgetWithInsightRef: function (ref) {
                    return isWidget(widget) && widget.type === "insight" && areObjRefsEqual(ref, widget.insight);
                },
                isWidgetWithInsightType: function (type) {
                    return isWidget(widget) && widget.type === "insight" && type === visType;
                },
            };
            var commonCustomWidgetRenderProps = {
                ErrorComponent: ErrorComponent,
                LoadingComponent: LoadingComponent,
                predicates: predicates,
                widget: isWidget(widget) ? widget : undefined,
                renderedWidget: renderedWidget,
                filters: filters,
                customWidget: !isDashboardWidget(widget) ? widget : undefined,
            };
            var customWidgetRendererProps = __assign(__assign({}, commonCustomWidgetRenderProps), { insight: insight,
                alert: alert });
            var className = userWorkspaceSettings.enableKDWidgetCustomHeight
                ? "custom-height"
                : undefined;
            return (React.createElement(DefaultWidgetRenderer, __assign({}, renderProps, computedRenderProps, { className: className }), widgetRenderer ? widgetRenderer(customWidgetRendererProps) : renderedWidget));
        }, className: className, 
        // When section headers are enabled, use default DashboardLayout rowHeaderRenderer.
        // When turned off, render nothing.
        sectionHeaderRenderer: areSectionHeadersEnabled ? undefined : function () { return null; }, enableCustomHeight: userWorkspaceSettings.enableKDWidgetCustomHeight }));
});
//# sourceMappingURL=DashboardRenderer.js.map