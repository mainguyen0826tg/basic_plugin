import { __assign, __read, __spread } from "tslib";
import { FluidLayoutCustomizer } from "./fluidLayoutCustomizer";
var DefaultLayoutCustomizer = /** @class */ (function () {
    function DefaultLayoutCustomizer(logger) {
        var _this = this;
        this.logger = logger;
        this.sealed = false;
        this.fluidLayoutTransformations = [];
        this.customizeFluidLayout = function (customizationFn) {
            if (!_this.sealed) {
                _this.fluidLayoutTransformations.push(customizationFn);
            }
            else {
                _this.logger.warn("Attempting to add layout customization outside of plugin registration. Ignoring.");
            }
            return _this;
        };
        this.sealCustomizer = function () {
            _this.sealed = true;
            return _this;
        };
        this.getExistingDashboardTransformFn = function () {
            var snapshot = __spread(_this.fluidLayoutTransformations);
            return function (dashboard) {
                var layout = dashboard.layout;
                /*
                 * Once the dashboard component supports multiple layout types, then the code here must only
                 * perform the transformations applicable for the dashboard's layout type..
                 *
                 * At this point, since dashboard only supports fluid layout, the code tests that there is a
                 * layout in a dashboard and is of expected type. This condition will be always true for
                 * non-empty, non-corrupted dashboards
                 */
                if (!layout || layout.type !== "IDashboardLayout") {
                    return undefined;
                }
                var newLayout = snapshot.reduce(function (currentLayout, fn) {
                    // Create a new fluid layout customizer just for this round of processing
                    var customizer = new FluidLayoutCustomizer(_this.logger);
                    try {
                        // call out to the plugin-provided function with the current value of the layout & the
                        // customizer to use. the custom function may now inspect the layout & use the customizer
                        // to add sections or items. customizer will not reflect those changes immediately. instead
                        // it will accumulate those operations
                        fn(currentLayout, customizer);
                        // now make the customizer apply the registered layout modifications; this is done so that
                        // customizer can guarantee that all new items are added at first (keeping the original
                        // section indexes) and only then new sections are added
                        return customizer.applyTransformations(currentLayout);
                    }
                    catch (e) {
                        _this.logger.error("An error has occurred while transforming fluid dashboard layout. Skipping failed transformation.", e);
                        return currentLayout;
                    }
                }, layout);
                return __assign(__assign({}, dashboard), { layout: newLayout });
            };
        };
    }
    return DefaultLayoutCustomizer;
}());
export { DefaultLayoutCustomizer };
//# sourceMappingURL=layoutCustomizer.js.map