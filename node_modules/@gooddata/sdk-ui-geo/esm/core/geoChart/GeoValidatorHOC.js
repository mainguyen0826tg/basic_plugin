import { __assign, __extends } from "tslib";
// (C) 2020 GoodData Corporation
import React from "react";
import isEqual from "lodash/isEqual";
import { injectIntl } from "react-intl";
import { isLocationMissing } from "./helpers/geoChart/common";
import { ErrorCodes, ErrorComponent as DefaultErrorComponent, GeoLocationMissingSdkError, GeoTokenMissingSdkError, IntlWrapper, newErrorMapping, } from "@gooddata/sdk-ui";
export function geoValidatorHOC(InnerComponent) {
    var ValidatorHOCWrapped = /** @class */ (function (_super) {
        __extends(ValidatorHOCWrapped, _super);
        function ValidatorHOCWrapped(props) {
            var _this = _super.call(this, props) || this;
            _this.isLocationMissing = false;
            _this.isMapboxTokenMissing = false;
            _this.errorMap = newErrorMapping(props.intl);
            return _this;
        }
        ValidatorHOCWrapped.prototype.render = function () {
            this.initError();
            if (this.isMapboxTokenMissing) {
                return this.renderErrorComponent(ErrorCodes.GEO_MAPBOX_TOKEN_MISSING);
            }
            if (this.isLocationMissing) {
                return this.renderErrorComponent(ErrorCodes.GEO_LOCATION_MISSING);
            }
            return React.createElement(InnerComponent, __assign({ key: "InnerComponent" }, this.props));
        };
        ValidatorHOCWrapped.prototype.shouldComponentUpdate = function (nextProps) {
            var _a = this.props, config = _a.config, execution = _a.execution, drillableItems = _a.drillableItems;
            var nextConfig = nextProps.config, nextExecution = nextProps.execution, nextDrillableItems = nextProps.drillableItems;
            // check if buckets, filters and config are changed
            var isSameConfig = this.isSameConfig(config, nextConfig);
            var isSameDataSource = this.isSameData(execution, nextExecution);
            var isSameDrillableItems = isEqual(drillableItems, nextDrillableItems);
            return !isSameConfig || !isSameDataSource || !isSameDrillableItems;
        };
        ValidatorHOCWrapped.prototype.componentDidUpdate = function () {
            this.handleError();
        };
        ValidatorHOCWrapped.prototype.componentDidMount = function () {
            this.handleError();
        };
        ValidatorHOCWrapped.prototype.initError = function () {
            var _a, _b;
            var mapboxToken = (_b = (_a = this.props.config) === null || _a === void 0 ? void 0 : _a.mapboxToken) !== null && _b !== void 0 ? _b : "";
            var execution = this.props.execution;
            this.isLocationMissing = isLocationMissing(execution.definition.buckets);
            this.isMapboxTokenMissing = !mapboxToken;
        };
        ValidatorHOCWrapped.prototype.handleError = function () {
            var onError = this.props.onError;
            if (this.isLocationMissing) {
                onError === null || onError === void 0 ? void 0 : onError(new GeoLocationMissingSdkError());
            }
            if (this.isMapboxTokenMissing) {
                onError === null || onError === void 0 ? void 0 : onError(new GeoTokenMissingSdkError());
            }
        };
        ValidatorHOCWrapped.prototype.renderErrorComponent = function (errorState) {
            var _a;
            var ErrorComponent = (_a = this.props.ErrorComponent) !== null && _a !== void 0 ? _a : DefaultErrorComponent;
            // in this case, we show "Sorry, we can't display this insight"
            var errorProps = this.errorMap[errorState] || this.errorMap[ErrorCodes.UNKNOWN_ERROR];
            return React.createElement(ErrorComponent, __assign({ code: errorState }, errorProps));
        };
        ValidatorHOCWrapped.prototype.isSameConfig = function (config, nextConfig) {
            var colorMapping = ((config === null || config === void 0 ? void 0 : config.colorMapping) || []).map(function (currentColor) { return currentColor.color; });
            var nextColorMapping = ((nextConfig === null || nextConfig === void 0 ? void 0 : nextConfig.colorMapping) || []).map(function (newColor) { return newColor.color; });
            var configProps = __assign(__assign({}, config), { colorMapping: colorMapping });
            var nextConfigProps = __assign(__assign({}, nextConfig), { colorMapping: nextColorMapping });
            return isEqual(configProps, nextConfigProps);
        };
        ValidatorHOCWrapped.prototype.isSameData = function (execution, nextExecution) {
            if (!execution || !nextExecution) {
                // one of data views is undefined. just test if the other one is also undefined, otherwise
                // data is definitely different
                return execution === nextExecution;
            }
            // we need equals here (not just fingerprint) for cases where measure is moved from one bucket to another
            return execution.equals(nextExecution);
        };
        return ValidatorHOCWrapped;
    }(React.Component));
    var IntlValidatorHOC = injectIntl(ValidatorHOCWrapped);
    return /** @class */ (function (_super) {
        __extends(ValidatorHOC, _super);
        function ValidatorHOC() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ValidatorHOC.prototype.render = function () {
            return (React.createElement(IntlWrapper, { locale: this.props.locale },
                React.createElement(IntlValidatorHOC, __assign({}, this.props))));
        };
        return ValidatorHOC;
    }(React.Component));
}
//# sourceMappingURL=GeoValidatorHOC.js.map