// (C) 2007-2020 GoodData Corporation
import mapValues from "lodash/mapValues";
import merge from "lodash/merge";
import { elementRegion } from "./domUtilities";
var ALIGN_RATIOS_X = {
    l: 0,
    r: 1,
    c: 0.5,
};
var ALIGN_RATIOS_Y = {
    t: 0,
    b: 1,
    c: 0.5,
};
var DEFAULT_OFFSET_VALUES = {
    x: 0,
    y: 0,
};
export var DEFAULT_ALIGN_POINTS = [
    {
        align: "cc cc",
        offset: {
            x: 0,
            y: 0,
        },
    },
];
var FULLY_HIDDEN_ALIGNMENT = {
    alignment: {
        left: 0,
        top: 0,
        right: 0,
        align: DEFAULT_ALIGN_POINTS[0].align,
    },
    visiblePart: -1,
};
function getDefaultViewportRegion(ignoreScrollOffsets) {
    var region = elementRegion(document.body);
    return {
        top: ignoreScrollOffsets ? 0 : document.documentElement.scrollTop,
        left: ignoreScrollOffsets ? 0 : document.documentElement.scrollLeft,
        width: region.width,
        height: region.height,
    };
}
function getDefaultDocumentRegion() {
    return {
        top: 0,
        left: 0,
        height: document.documentElement.scrollHeight,
        width: document.documentElement.scrollWidth,
    };
}
function getAlignRatios(coordinatesString) {
    if (!(coordinatesString[0] in ALIGN_RATIOS_Y) || !(coordinatesString[1] in ALIGN_RATIOS_X)) {
        throw new Error("Invalid point specification: " + coordinatesString);
    }
    return {
        x: ALIGN_RATIOS_X[coordinatesString[1]],
        y: ALIGN_RATIOS_Y[coordinatesString[0]],
    };
}
function getAlignPointRatios(alignPointAlign) {
    var alignPointPositions = alignPointAlign.split(" ");
    return {
        target: getAlignRatios(alignPointPositions[0]),
        self: getAlignRatios(alignPointPositions[1]),
    };
}
function getRegionOffset(region, ratio, direction) {
    if (direction === void 0) { direction = 1; }
    return {
        x: region.width * ratio.x * direction,
        y: region.height * ratio.y * direction,
    };
}
function getAlignPointOffset(alignPointOffset) {
    return merge({}, DEFAULT_OFFSET_VALUES, alignPointOffset);
}
function addOffset(position, offset) {
    return {
        x: position.x + offset.x,
        y: position.y + offset.y,
    };
}
function getGlobalOffset(target) {
    return {
        x: target.left,
        y: target.top,
    };
}
/**
 * Get left-top coordinates of a child summing up offsets of a child,
 * align points and left-top coordinates of target region
 */
function getGlobalPosition(targetRegion, selfRegion, alignPoint) {
    var alignRatio = getAlignPointRatios(alignPoint.align);
    var targetRegionOffset = getRegionOffset(targetRegion, alignRatio.target);
    var selfRegionOffset = getRegionOffset(selfRegion, alignRatio.self, -1);
    var alignPointOffset = getAlignPointOffset(alignPoint.offset);
    var cumulativeOffset = addOffset(alignPointOffset, addOffset(targetRegionOffset, selfRegionOffset));
    var globalOffset = getGlobalOffset(targetRegion);
    return addOffset(globalOffset, cumulativeOffset);
}
/**
 * Move region to position specified by anchor point,
 * using its left-top coordinates
 */
function moveRegionToPosition(region, anchorPoint) {
    return merge({}, region, {
        left: anchorPoint.x,
        top: anchorPoint.y,
        width: region.width,
        height: region.height,
    });
}
/**
 * Move self region to new position using its left-top coordinates
 */
function getPositionedSelfRegion(_a) {
    var targetRegion = _a.targetRegion, selfRegion = _a.selfRegion, alignPoint = _a.alignPoint;
    var globalPosition = getGlobalPosition(targetRegion, selfRegion, alignPoint);
    return moveRegionToPosition(selfRegion, globalPosition);
}
/**
 * Get fraction of visible area
 */
function getRatioOfVisibleRegion(boundaryRegion, region) {
    var maximalVisibleArea = region.width * region.height;
    if (maximalVisibleArea === 0) {
        return 0;
    }
    var leftBorder = Math.max(boundaryRegion.left, region.left);
    var rightBorder = Math.min(boundaryRegion.left + boundaryRegion.width, region.left + region.width);
    var topBorder = Math.max(boundaryRegion.top, region.top);
    var bottomBorder = Math.min(boundaryRegion.top + boundaryRegion.height, region.top + region.height);
    var visibleWidth = Math.max(rightBorder - leftBorder, 0);
    var visibleHeight = Math.max(bottomBorder - topBorder, 0);
    var visibleArea = visibleWidth * visibleHeight;
    var visibleRatio = visibleArea / maximalVisibleArea;
    return Math.max(0, visibleRatio);
}
function isFullyVisible(alignment) {
    return alignment.visiblePart === 1;
}
function isFullyHidden(alignment) {
    return alignment.visiblePart === 0;
}
/**
 * Calculate most visible alignment of self region which
 * would be positioned to target region using specified
 * align points
 */
export function getOptimalAlignmentForRegion(_a) {
    var boundaryRegion = _a.boundaryRegion, targetRegion = _a.targetRegion, selfRegion = _a.selfRegion, alignPoints = _a.alignPoints;
    var mostVisibleAlignment = FULLY_HIDDEN_ALIGNMENT;
    for (var i = 0; i < alignPoints.length; i += 1) {
        var positionedSelfRegion = getPositionedSelfRegion({
            alignPoint: alignPoints[i],
            targetRegion: targetRegion,
            selfRegion: selfRegion,
        });
        var visiblePart = getRatioOfVisibleRegion(boundaryRegion, positionedSelfRegion);
        if (visiblePart > mostVisibleAlignment.visiblePart) {
            var coordinates = {
                left: positionedSelfRegion.left,
                top: positionedSelfRegion.top,
                right: boundaryRegion.left + boundaryRegion.width - positionedSelfRegion.left - selfRegion.width,
            };
            mostVisibleAlignment = {
                alignment: merge(mapValues(coordinates, Math.floor), {
                    align: alignPoints[i].align,
                }),
                visiblePart: visiblePart,
            };
        }
        if (isFullyVisible(mostVisibleAlignment)) {
            return mostVisibleAlignment;
        }
    }
    return mostVisibleAlignment;
}
/**
 * Calculate optimal alignment of self region
 * using viewport boundaries. Try to position
 * using body boundaries if the region
 * is fully hidden in the viewport
 */
export function getOptimalAlignment(_a) {
    var targetRegion = _a.targetRegion, selfRegion = _a.selfRegion, ignoreScrollOffsets = _a.ignoreScrollOffsets, alignPoints = _a.alignPoints, _b = _a.getViewportRegion, getViewportRegion = _b === void 0 ? getDefaultViewportRegion : _b, _c = _a.getDocumentRegion, getDocumentRegion = _c === void 0 ? getDefaultDocumentRegion : _c;
    var optimalAlign = getOptimalAlignmentForRegion({
        boundaryRegion: getViewportRegion(ignoreScrollOffsets),
        targetRegion: targetRegion,
        selfRegion: selfRegion,
        alignPoints: alignPoints,
    });
    if (isFullyHidden(optimalAlign)) {
        optimalAlign = getOptimalAlignmentForRegion({
            boundaryRegion: getDocumentRegion(),
            targetRegion: targetRegion,
            selfRegion: selfRegion,
            alignPoints: alignPoints,
        });
    }
    return optimalAlign;
}
//# sourceMappingURL=overlay.js.map