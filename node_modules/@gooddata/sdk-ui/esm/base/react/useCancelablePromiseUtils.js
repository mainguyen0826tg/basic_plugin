import { __read, __spread } from "tslib";
// (C) 2019-2021 GoodData Corporation
import identity from "lodash/identity";
import { UnexpectedSdkError } from "../errors/GoodDataSdkError";
/**
 * Resolve status of multiple {@link useCancelablePromise} hooks.
 *
 * This is useful for useCancelablePromise composition - when you want to wrap multiple useCancelablePromise hooks in another hook,
 * and keep the return value shape of the hook same as for useCancelablePromise.
 *
 * You can choose between 2 strategies to resolve the status (default strategy is "serial"):
 * - serial: Short-circuits to the first pending/loading/error status, and returns the last status
 *   only when all previous statuses are "success".
 * - parallel: Is resolved to the status which has the highest priority.
 *   Priority of the statuses has the following order (from highest to lowest): pending, loading, error, success.
 *   Examples:
 *     - ["pending", "loading"] will be resolved to "pending"
 *     - ["loading", "error"] will be resolved to "loading"
 *     - ["error", "success"] will be resolved to "error"
 *     - ["success", "success"] will be resolved to "success"
 *
 * @param states - cancelable promise states (useCancelablePromise return values)
 * @param options - optionally specify options for resolving the status
 * @returns resolved status
 * @beta
 */
export function resolveUseCancelablePromisesStatus(cancelablePromisesStates, options) {
    var _a;
    if (options === void 0) { options = {}; }
    var statuses = collectUseCancelablePromiseStatuses(cancelablePromisesStates);
    var strategy = (_a = options.strategy) !== null && _a !== void 0 ? _a : "serial";
    return strategy === "parallel"
        ? resolveUseCancelablePromisesStatusParallel(statuses)
        : resolveUseCancelablePromisesStatusSerial(statuses);
}
/**
 * Resolve error of multiple {@link useCancelablePromise} hooks - gets first error in the sequence of cancelable promise states.
 *
 * This is useful for useCancelablePromise composition - when you want to wrap multiple useCancelablePromise hooks in another hook,
 * and keep the return value shape of the hook same as for useCancelablePromise.
 *
 * @param states - cancelable promise states (useCancelablePromise return values)
 * @returns first error
 * @beta
 */
export function resolveUseCancelablePromisesError(states) {
    var errors = collectUseCancelablePromiseErrors(states);
    return errors.find(identity);
}
/**
 * @internal
 */
export function resolveUseCancelablePromisesStatusSerial(statuses) {
    return statuses.reduce(function (prevStatus, nextStatus) {
        switch (prevStatus) {
            case "pending":
            case "loading":
            case "error":
                return prevStatus;
            case "success":
                return nextStatus;
            default: {
                var a = prevStatus;
                throw new UnexpectedSdkError("Unknown useCancelablePromise status: " + a);
            }
        }
    });
}
var priorityByStatus = {
    pending: 0,
    loading: 1,
    error: 2,
    success: 3,
};
function compareStatus(a, b) {
    var aPriority = priorityByStatus[a];
    var bPriority = priorityByStatus[b];
    if (aPriority < bPriority) {
        return -1;
    }
    if (aPriority > bPriority) {
        return 1;
    }
    return 0;
}
/**
 * @internal
 */
export function resolveUseCancelablePromisesStatusParallel(statuses) {
    var _a = __read(__spread(statuses).sort(compareStatus), 1), finalStatus = _a[0];
    return finalStatus;
}
function collectUseCancelablePromiseStatuses(results) {
    return results.map(function (r) { return r.status; });
}
function collectUseCancelablePromiseErrors(results) {
    return results.map(function (r) { return r.error; });
}
//# sourceMappingURL=useCancelablePromiseUtils.js.map