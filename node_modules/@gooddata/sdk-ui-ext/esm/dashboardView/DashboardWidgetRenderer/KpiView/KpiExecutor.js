import { __assign } from "tslib";
// (C) 2020 GoodData Corporation
import React, { useCallback, useMemo, useState } from "react";
import { injectIntl } from "react-intl";
import compact from "lodash/compact";
import isNil from "lodash/isNil";
import isNumber from "lodash/isNumber";
import round from "lodash/round";
import { isMeasureFormatInPercent, } from "@gooddata/sdk-model";
import { convertDrillableItemsToPredicates, createNumberJsFormatter, ErrorComponent as DefaultError, isNoDataSdkError, isSomeHeaderPredicateMatched, LoadingComponent as DefaultLoading, NoDataSdkError, useDataView, useExecution, } from "@gooddata/sdk-ui";
import { filterContextItemsToFiltersForWidget, filterContextToFiltersForWidget } from "../../converters";
import { useCurrentUser, useUserWorkspacePermissions } from "../../hooks/internal";
import { DashboardItemHeadline, DashboardItemWithKpiAlert, evaluateAlertTriggered, getBrokenAlertFiltersBasicInfo, dashboardFilterToFilterContextItem, stripDateDatasets, } from "../../../internal";
import { useUserWorkspaceSettings } from "../../contexts";
import { useAlertDeleteHandler, useAlertSaveOrUpdateHandler, } from "./alertManipulationHooks";
import { KpiRenderer } from "./KpiRenderer";
import { KpiAlertDialogWrapper } from "./KpiAlertDialogWrapper";
var KpiExecutorCore = function (_a) {
    var _b;
    var dashboardRef = _a.dashboardRef, kpiWidget = _a.kpiWidget, primaryMeasure = _a.primaryMeasure, secondaryMeasure = _a.secondaryMeasure, alert = _a.alert, allFilters = _a.allFilters, effectiveFilters = _a.effectiveFilters, onFiltersChange = _a.onFiltersChange, drillableItems = _a.drillableItems, onDrill = _a.onDrill, onError = _a.onError, backend = _a.backend, workspace = _a.workspace, separators = _a.separators, disableDrillUnderline = _a.disableDrillUnderline, intl = _a.intl, isReadOnly = _a.isReadOnly, _c = _a.ErrorComponent, ErrorComponent = _c === void 0 ? DefaultError : _c, _d = _a.LoadingComponent, LoadingComponent = _d === void 0 ? DefaultLoading : _d;
    var execution = useExecution({
        seriesBy: compact([primaryMeasure, secondaryMeasure]),
        filters: effectiveFilters,
        backend: backend,
        workspace: workspace,
    });
    var _e = useDataView({ execution: execution, onError: onError }, [execution.fingerprint()]), error = _e.error, result = _e.result, status = _e.status;
    var userWorkspaceSettings = useUserWorkspaceSettings();
    var brokenAlertsBasicInfo = useMemo(function () { return (alert ? getBrokenAlertFiltersBasicInfo(alert, kpiWidget, allFilters) : undefined); }, [alert, kpiWidget, allFilters]);
    var isAlertBroken = !!(brokenAlertsBasicInfo === null || brokenAlertsBasicInfo === void 0 ? void 0 : brokenAlertsBasicInfo.length);
    var alertExecution = useExecution({
        seriesBy: [primaryMeasure],
        filters: alert
            ? (_b = filterContextToFiltersForWidget(alert.filterContext, kpiWidget)) !== null && _b !== void 0 ? _b : [] : effectiveFilters,
        backend: backend,
        workspace: workspace,
    });
    var _f = useDataView({
        execution: alert && !isAlertBroken ? alertExecution : null,
        onError: onError,
    }, [alert, alertExecution.fingerprint()]), alertError = _f.error, alertResult = _f.result, alertStatus = _f.status;
    var handleOnDrill = useCallback(function (drillContext) {
        if (!onDrill || !result) {
            return false;
        }
        // only return the definitions if there are no custom-specified drillableItems
        // if there are, we assume it was the custom drill
        var drillDefinitions = !(drillableItems === null || drillableItems === void 0 ? void 0 : drillableItems.length) && kpiWidget.drills.length > 0 ? kpiWidget.drills : undefined;
        return onDrill({
            dataView: result.dataView,
            drillContext: drillContext,
            drillDefinitions: drillDefinitions,
            widgetRef: kpiWidget.ref,
        });
    }, [onDrill, result]);
    var _g = useState(false), isAlertDialogOpen = _g[0], setIsAlertDialogOpen = _g[1];
    var closeAlertDialog = function () { return setIsAlertDialogOpen(false); };
    var alertManipulationHandlerConfig = {
        backend: backend,
        workspace: workspace,
        closeAlertDialog: closeAlertDialog,
    };
    var _h = useAlertDeleteHandler(alertManipulationHandlerConfig), alertDeletingStatus = _h.alertDeletingStatus, deleteAlert = _h.deleteAlert;
    var _j = useAlertSaveOrUpdateHandler(alertManipulationHandlerConfig), alertSavingStatus = _j.alertSavingStatus, saveOrUpdateAlert = _j.saveOrUpdateAlert;
    var currentUser = useCurrentUser({ backend: backend }).result;
    var permissions = useUserWorkspacePermissions({ backend: backend, workspace: workspace }).result;
    var canSetAlert = permissions === null || permissions === void 0 ? void 0 : permissions.canCreateScheduledMail;
    if (status === "loading" || status === "pending") {
        return React.createElement(LoadingComponent, null);
    }
    var kpiResult = getKpiResult(result, primaryMeasure, secondaryMeasure, separators);
    var kpiAlertResult = getKpiAlertResult(alertResult, primaryMeasure, separators);
    var _k = getAlertThresholdInfo(kpiResult, intl), isThresholdRepresentingPercent = _k.isThresholdRepresentingPercent, thresholdPlaceholder = _k.thresholdPlaceholder;
    var predicates = drillableItems ? convertDrillableItemsToPredicates(drillableItems) : [];
    var isDrillable = status !== "error" &&
        (kpiWidget.drills.length > 0 ||
            isSomeHeaderPredicateMatched(predicates, kpiResult.measureDescriptor, result));
    var enableCompactSize = userWorkspaceSettings.enableKDWidgetCustomHeight;
    return (React.createElement(DashboardItemWithKpiAlert, { kpi: kpiWidget, alert: alert, filters: effectiveFilters, userWorkspaceSettings: userWorkspaceSettings, kpiResult: kpiResult, renderHeadline: function (clientHeight) { return (React.createElement(DashboardItemHeadline, { title: kpiWidget.title, clientHeight: clientHeight })); }, kpiAlertResult: kpiAlertResult, canSetAlert: canSetAlert, isReadOnlyMode: isReadOnly, alertExecutionError: alertError !== null && alertError !== void 0 ? alertError : 
        /*
         * if alert is broken, behave as if its execution yielded no data (which is true, we do not execute it)
         * context: the problem is alerts on KPIs without dateDataset, their date filters are invalid
         * and we have no idea what date dataset to put there hence it is sometimes impossible
         * to execute them (unlike KPI Dashboards, we do not have the guarantee that there is a date
         * filter in the filters)
         */
        (isAlertBroken ? new NoDataSdkError() : undefined), isLoading: false /* content is always loaded at this point */, isAlertLoading: false /* alerts are always loaded at this point */, isAlertExecutionLoading: alertStatus === "loading", isAlertBroken: isAlertBroken, isAlertDialogOpen: isAlertDialogOpen, onAlertDialogOpenClick: function () { return setIsAlertDialogOpen(true); }, renderAlertDialog: function () { return (React.createElement(KpiAlertDialogWrapper, { alert: alert, dateFormat: userWorkspaceSettings.responsiveUiDateFormat, userEmail: currentUser === null || currentUser === void 0 ? void 0 : currentUser.email, onAlertDialogCloseClick: function () { return setIsAlertDialogOpen(false); }, onAlertDialogDeleteClick: function () { return deleteAlert(alert); }, onAlertDialogSaveClick: function (threshold, whenTriggered) {
                var _a;
                var toSave = alert
                    ? __assign(__assign({}, alert), { threshold: threshold,
                        whenTriggered: whenTriggered, isTriggered: evaluateAlertTriggered(kpiAlertResult.measureResult, threshold, whenTriggered) }) : {
                    dashboard: dashboardRef,
                    widget: kpiWidget.ref,
                    threshold: threshold,
                    whenTriggered: whenTriggered,
                    isTriggered: evaluateAlertTriggered((_a = kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureResult) !== null && _a !== void 0 ? _a : 0, threshold, whenTriggered),
                    filterContext: {
                        title: "filterContext",
                        description: "",
                        filters: effectiveFilters
                            .map(dashboardFilterToFilterContextItem)
                            .map(stripDateDatasets),
                    },
                    description: "",
                    title: "",
                };
                saveOrUpdateAlert(toSave);
            }, onAlertDialogUpdateClick: function () {
                var _a;
                saveOrUpdateAlert(__assign(__assign({}, alert), { 
                    // evaluate triggered as if the alert already used the correct filters (i.e. use the KPI execution itself)
                    isTriggered: evaluateAlertTriggered((_a = kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureResult) !== null && _a !== void 0 ? _a : 0, alert.threshold, alert.whenTriggered), 
                    // change the filters to the filters currently used by the KPI
                    filterContext: __assign(__assign({}, alert.filterContext), { filters: effectiveFilters
                            .map(dashboardFilterToFilterContextItem)
                            .map(stripDateDatasets) }) }));
            }, onApplyAlertFiltersClick: onFiltersChange
                ? function () {
                    var _a, _b;
                    return onFiltersChange(filterContextItemsToFiltersForWidget((_b = (_a = alert.filterContext) === null || _a === void 0 ? void 0 : _a.filters) !== null && _b !== void 0 ? _b : [], kpiWidget));
                }
                : undefined, isAlertLoading: alertStatus === "loading", alertDeletingStatus: alertDeletingStatus, alertSavingStatus: alertSavingStatus, alertUpdatingStatus: alertSavingStatus, filters: effectiveFilters, isThresholdRepresentingPercent: isThresholdRepresentingPercent, thresholdPlaceholder: thresholdPlaceholder, brokenAlertFiltersBasicInfo: brokenAlertsBasicInfo, backend: backend, workspace: workspace })); }, alertDeletingStatus: alertDeletingStatus, alertSavingStatus: alertSavingStatus }, function () {
        if (status === "error" && !isNoDataSdkError(error)) {
            return React.createElement(ErrorComponent, { message: error.message });
        }
        return (React.createElement(KpiRenderer, { kpi: kpiWidget, kpiResult: kpiResult, filters: effectiveFilters, disableDrillUnderline: disableDrillUnderline, isDrillable: isDrillable, onDrill: onDrill && handleOnDrill, separators: separators, enableCompactSize: enableCompactSize }));
    }));
};
/**
 * Executes the given measures and displays them as KPI
 * @internal
 */
export var KpiExecutor = injectIntl(KpiExecutorCore);
function getSeriesResult(series) {
    if (!series) {
        return null;
    }
    var value = series.dataPoints()[0].rawValue;
    if (isNil(value)) {
        return null;
    }
    if (isNumber(value)) {
        return value;
    }
    return Number.parseFloat(value);
}
function getKpiResult(result, primaryMeasure, secondaryMeasure, separators) {
    var series = result === null || result === void 0 ? void 0 : result.data({ valueFormatter: createNumberJsFormatter(separators) }).series();
    var primarySeries = series === null || series === void 0 ? void 0 : series.firstForMeasure(primaryMeasure);
    var secondarySeries = secondaryMeasure ? series === null || series === void 0 ? void 0 : series.firstForMeasure(secondaryMeasure) : undefined;
    return primarySeries
        ? {
            measureDescriptor: primarySeries.descriptor.measureDescriptor,
            measureFormat: primarySeries.measureFormat(),
            measureResult: getSeriesResult(primarySeries),
            measureForComparisonResult: getSeriesResult(secondarySeries),
        }
        : undefined;
}
function getKpiAlertResult(result, primaryMeasure, separators) {
    var alertSeries = result === null || result === void 0 ? void 0 : result.data({ valueFormatter: createNumberJsFormatter(separators) }).series();
    return alertSeries
        ? {
            measureFormat: alertSeries.firstForMeasure(primaryMeasure).measureFormat(),
            measureResult: getSeriesResult(alertSeries.firstForMeasure(primaryMeasure)),
        }
        : undefined;
}
function getAlertThresholdInfo(kpiResult, intl) {
    var isThresholdRepresentingPercent = kpiResult
        ? isMeasureFormatInPercent(kpiResult.measureFormat)
        : false;
    var value = round((kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureResult) || 0, 2); // sure about rounding?
    var thresholdPlaceholder = isThresholdRepresentingPercent
        ? intl.formatMessage({ id: "kpi.alertBox.example" }) + " " + value * 100
        : intl.formatMessage({ id: "kpi.alertBox.example" }) + " " + value; // TODO fix floating point multiply
    return {
        isThresholdRepresentingPercent: isThresholdRepresentingPercent,
        thresholdPlaceholder: thresholdPlaceholder,
    };
}
//# sourceMappingURL=KpiExecutor.js.map