import { __generator } from "tslib";
import { selectWidgetsMap } from "../../store/layout/layoutSelectors";
import { call, put, select } from "redux-saga/effects";
import { validateExistingKpiWidget } from "./validation/widgetValidations";
import { layoutActions } from "../../store/layout";
import { kpiWidgetMeasureChanged } from "../../events/kpi";
import { selectAllCatalogMeasuresMap } from "../../store/catalog/catalogSelectors";
import { invalidArgumentsProvided } from "../../events/general";
import { objRefToString } from "@gooddata/sdk-model";
import { batchActions } from "redux-batched-actions";
import { isWidgetHeader } from "../../types/widgetTypes";
import { queryDateDatasetsForMeasure } from "../../queries";
import { query } from "../../store/_infra/queryCall";
import { newCatalogDateDatasetMap } from "../../../_staging/metadata/objRefMap";
import isEmpty from "lodash/isEmpty";
function validateMeasure(ctx, cmd) {
    var measureRef, measures, measure;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                measureRef = cmd.payload.measureRef;
                return [4 /*yield*/, select(selectAllCatalogMeasuresMap)];
            case 1:
                measures = _a.sent();
                measure = measures.get(measureRef);
                if (!measure) {
                    throw invalidArgumentsProvided(ctx, cmd, "Attempting to use non-existent measure for KPI widget. " + objRefToString(measureRef) + " does not exist.");
                }
                return [2 /*return*/, measure];
        }
    });
}
function determineHeaderToUse(cmd, measure) {
    var header = cmd.payload.header;
    if (typeof header === "string" && header === "from-measure") {
        return {
            title: measure.measure.title,
        };
    }
    else if (isWidgetHeader(header)) {
        return header;
    }
    return undefined;
}
function determineDateDatasetToUse(widget, measure) {
    var measureDateDatasets, catalogDataSet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                if (!widget.dateDataSet) {
                    return [2 /*return*/, undefined];
                }
                return [4 /*yield*/, call(query, queryDateDatasetsForMeasure(measure.measure.ref))];
            case 1:
                measureDateDatasets = _a.sent();
                catalogDataSet = newCatalogDateDatasetMap(measureDateDatasets.dateDatasets).get(widget.dateDataSet);
                if (!catalogDataSet) {
                    if (!isEmpty(measureDateDatasets.dateDatasetsOrdered)) {
                        return [2 /*return*/, measureDateDatasets.dateDatasetsOrdered[0]];
                    }
                    return [2 /*return*/, undefined];
                }
                return [2 /*return*/, catalogDataSet];
        }
    });
}
/**
 * When switching measure used by the KPI the handler needs to deal with several things:
 *
 * -  Input validation; both KPI widget and the new measure must be valid
 * -  Determining what header to use for the KPI. The header may come either as part of the command or command may
 *    indicate to automatically use title from measure OR the command may not provide any header in which case the
 *    old header will be retained
 * -  Determining what date dataset to use for filtering. Different measures can use different date datasets for
 *    filtering - the existing dateDataSet setting on the KPI widget may not be valid in the context of the
 *    new measure.
 *
 *    Thus the command triggers logic (in generator) to query available date datasets for the metric, check if the
 *    existing dateDataSet is among the results of the query. If so, the existing date dataset will be kept. Otherwise
 *    code will pick the most-relevant date dataset.
 *
 *    If the KPI is not setup with date dataset, then nothing happens.
 *
 *
 */
export function changeKpiWidgetMeasureHandler(ctx, cmd) {
    var correlationId, widgets, kpiWidget, measure, header, dateDataset, actions, updatedWidgets, updatedKpiWidget;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                correlationId = cmd.correlationId;
                return [4 /*yield*/, select(selectWidgetsMap)];
            case 1:
                widgets = _a.sent();
                kpiWidget = validateExistingKpiWidget(widgets, cmd, ctx);
                return [4 /*yield*/, call(validateMeasure, ctx, cmd)];
            case 2:
                measure = _a.sent();
                header = determineHeaderToUse(cmd, measure);
                return [4 /*yield*/, call(determineDateDatasetToUse, kpiWidget, measure)];
            case 3:
                dateDataset = _a.sent();
                actions = [
                    layoutActions.replaceKpiWidgetMeasure({
                        ref: kpiWidget.ref,
                        measureRef: measure.measure.ref,
                        undo: {
                            cmd: cmd,
                        },
                    }),
                    layoutActions.replaceWidgetDateDataset({
                        ref: kpiWidget.ref,
                        dateDataSet: dateDataset === null || dateDataset === void 0 ? void 0 : dateDataset.dataSet.ref,
                        undo: {
                            cmd: cmd,
                        },
                    }),
                ];
                if (header) {
                    actions.push(layoutActions.replaceWidgetHeader({
                        ref: kpiWidget.ref,
                        header: header,
                        undo: {
                            cmd: cmd,
                        },
                    }));
                }
                return [4 /*yield*/, put(batchActions(actions, "@@CMD.UPDATE.KPI"))];
            case 4:
                _a.sent();
                return [4 /*yield*/, select(selectWidgetsMap)];
            case 5:
                updatedWidgets = _a.sent();
                updatedKpiWidget = updatedWidgets.get(kpiWidget.ref);
                return [2 /*return*/, kpiWidgetMeasureChanged(ctx, kpiWidget.ref, updatedKpiWidget, measure.measure, header, correlationId)];
        }
    });
}
//# sourceMappingURL=changeKpiWidgetMeasureHandler.js.map