/**
 * Types defined here exactly match types accepted by the executeAfm resource.
 *
 * Types currently map executeAfm version 3.
 *
 * @public
 */
export declare namespace GdcExecuteAFM {
    interface IExecution {
        execution: {
            afm: IAfm;
            resultSpec?: IResultSpec;
        };
    }
    interface IAfm {
        attributes?: IAttribute[];
        measures?: IMeasure[];
        filters?: CompatibilityFilter[];
        nativeTotals?: INativeTotalItem[];
    }
    interface IResultSpec {
        dimensions?: IDimension[];
        sorts?: SortItem[];
    }
    interface IAttribute {
        localIdentifier: Identifier;
        displayForm: ObjQualifier;
        alias?: string;
    }
    interface IMeasure {
        localIdentifier: Identifier;
        definition: MeasureDefinition;
        alias?: string;
        format?: string;
    }
    type MeasureDefinition = ISimpleMeasureDefinition | IArithmeticMeasureDefinition | IPopMeasureDefinition | IPreviousPeriodMeasureDefinition;
    interface ISimpleMeasureDefinition {
        measure: ISimpleMeasure;
    }
    interface IArithmeticMeasureDefinition {
        arithmeticMeasure: IArithmeticMeasure;
    }
    interface IPopMeasureDefinition {
        popMeasure: IPopMeasure;
    }
    interface IPreviousPeriodMeasureDefinition {
        previousPeriodMeasure: IPreviousPeriodMeasure;
    }
    type SimpleMeasureAggregation = "sum" | "count" | "avg" | "min" | "max" | "median" | "runsum";
    interface ISimpleMeasure {
        item: ObjQualifier;
        aggregation?: SimpleMeasureAggregation;
        filters?: FilterItem[];
        computeRatio?: boolean;
    }
    type ArithmeticMeasureOperator = "sum" | "difference" | "multiplication" | "ratio" | "change";
    interface IArithmeticMeasure {
        measureIdentifiers: Identifier[];
        operator: ArithmeticMeasureOperator;
    }
    interface IPopMeasure {
        measureIdentifier: Identifier;
        popAttribute: ObjQualifier;
    }
    interface IPreviousPeriodMeasure {
        measureIdentifier: Identifier;
        dateDataSets: IPreviousPeriodDateDataSet[];
    }
    interface IPreviousPeriodDateDataSet {
        dataSet: ObjQualifier;
        periodsAgo: number;
    }
    type Identifier = string;
    type ObjQualifier = IObjUriQualifier | IObjIdentifierQualifier;
    interface IObjIdentifierQualifier {
        identifier: string;
    }
    interface IObjUriQualifier {
        uri: string;
    }
    type ExtendedFilter = FilterItem | IMeasureValueFilter | IRankingFilter;
    type CompatibilityFilter = IExpressionFilter | ExtendedFilter;
    type FilterItem = DateFilterItem | AttributeFilterItem;
    type AttributeFilterItem = IPositiveAttributeFilter | INegativeAttributeFilter;
    type DateFilterItem = IAbsoluteDateFilter | IRelativeDateFilter;
    interface IAttributeElementsByRef {
        uris: string[];
    }
    interface IAttributeElementsByValue {
        values: string[];
    }
    type AttributeElements = string[] | IAttributeElementsByRef | IAttributeElementsByValue;
    interface IPositiveAttributeFilter {
        positiveAttributeFilter: {
            displayForm: ObjQualifier;
            in: AttributeElements;
        };
    }
    interface INegativeAttributeFilter {
        negativeAttributeFilter: {
            displayForm: ObjQualifier;
            notIn: AttributeElements;
        };
    }
    interface IAbsoluteDateFilter {
        absoluteDateFilter: {
            dataSet: ObjQualifier;
            from: string;
            to: string;
        };
    }
    interface IRelativeDateFilter {
        relativeDateFilter: {
            dataSet: ObjQualifier;
            granularity: string;
            from: number;
            to: number;
        };
    }
    type ComparisonConditionOperator = "GREATER_THAN" | "GREATER_THAN_OR_EQUAL_TO" | "LESS_THAN" | "LESS_THAN_OR_EQUAL_TO" | "EQUAL_TO" | "NOT_EQUAL_TO";
    interface IComparisonCondition {
        comparison: {
            operator: ComparisonConditionOperator;
            value: number;
            treatNullValuesAs?: number;
        };
    }
    type RangeConditionOperator = "BETWEEN" | "NOT_BETWEEN";
    interface IRangeCondition {
        range: {
            operator: RangeConditionOperator;
            from: number;
            to: number;
            treatNullValuesAs?: number;
        };
    }
    type MeasureValueFilterCondition = IComparisonCondition | IRangeCondition;
    interface ILocalIdentifierQualifier {
        localIdentifier: string;
    }
    type Qualifier = ObjQualifier | ILocalIdentifierQualifier;
    interface IMeasureValueFilter {
        measureValueFilter: {
            measure: Qualifier;
            condition?: MeasureValueFilterCondition;
        };
    }
    type RankingFilterOperator = "TOP" | "BOTTOM";
    interface IRankingFilter {
        rankingFilter: {
            measures: Qualifier[];
            attributes?: Qualifier[];
            operator: RankingFilterOperator;
            value: number;
        };
    }
    /**
     * @deprecated Expression filter in AFM can be used only by legacy code
     */
    interface IExpressionFilter {
        expression: {
            value: string;
        };
    }
    interface ITotalItem {
        measureIdentifier: Identifier;
        type: TotalType;
        attributeIdentifier: Identifier;
    }
    type TotalType = "sum" | "avg" | "max" | "min" | "nat" | "med";
    interface INativeTotalItem {
        measureIdentifier: Identifier;
        attributeIdentifiers: Identifier[];
    }
    interface IDimension {
        itemIdentifiers: Identifier[];
        totals?: ITotalItem[];
    }
    type SortItem = IAttributeSortItem | IMeasureSortItem;
    type SortDirection = "asc" | "desc";
    interface IAttributeSortItem {
        attributeSortItem: {
            direction: SortDirection;
            attributeIdentifier: Identifier;
            aggregation?: "sum";
        };
    }
    type VisualizationStyleType = "common" | "table" | "line" | "column" | "bar" | "area";
    interface IVisualizationStyle {
        visualizationStyle: {
            type: VisualizationStyleType;
            colorPalette: {
                measure?: {
                    color: string;
                    periodOverPeriod: string;
                };
                stack?: any;
            };
        };
    }
    interface IMeasureSortItem {
        measureSortItem: {
            direction: SortDirection;
            locators: LocatorItem[];
        };
    }
    type LocatorItem = IAttributeLocatorItem | IMeasureLocatorItem;
    interface IAttributeLocatorItem {
        attributeLocatorItem: {
            attributeIdentifier: Identifier;
            element: string;
        };
    }
    interface IMeasureLocatorItem {
        measureLocatorItem: {
            measureIdentifier: Identifier;
        };
    }
    function isObjectUriQualifier(qualifier: GdcExecuteAFM.ObjQualifier): qualifier is GdcExecuteAFM.IObjUriQualifier;
    function isObjIdentifierQualifier(qualifier: GdcExecuteAFM.ObjQualifier): qualifier is GdcExecuteAFM.IObjIdentifierQualifier;
    function isLocalIdentifierQualifier(qualifier: unknown): qualifier is ILocalIdentifierQualifier;
    function isSimpleMeasureDefinition(definition: GdcExecuteAFM.MeasureDefinition): definition is GdcExecuteAFM.ISimpleMeasureDefinition;
    function isArithmeticMeasureDefinition(definition: GdcExecuteAFM.MeasureDefinition): definition is GdcExecuteAFM.IArithmeticMeasureDefinition;
    function isPopMeasureDefinition(definition: GdcExecuteAFM.MeasureDefinition): definition is GdcExecuteAFM.IPopMeasureDefinition;
    function isPreviousPeriodMeasureDefinition(definition: GdcExecuteAFM.MeasureDefinition): definition is GdcExecuteAFM.IPreviousPeriodMeasureDefinition;
    function isAttributeSortItem(sortItem: GdcExecuteAFM.SortItem): sortItem is GdcExecuteAFM.IAttributeSortItem;
    function isMeasureSortItem(sortItem: GdcExecuteAFM.SortItem): sortItem is GdcExecuteAFM.IMeasureSortItem;
    function isAttributeLocatorItem(locator: GdcExecuteAFM.LocatorItem): locator is GdcExecuteAFM.IAttributeLocatorItem;
    function isMeasureLocatorItem(locator: GdcExecuteAFM.LocatorItem): locator is GdcExecuteAFM.IMeasureLocatorItem;
    function isDateFilter(filter: GdcExecuteAFM.CompatibilityFilter): filter is GdcExecuteAFM.DateFilterItem;
    function isRelativeDateFilter(filter: GdcExecuteAFM.CompatibilityFilter): filter is GdcExecuteAFM.IRelativeDateFilter;
    function isAbsoluteDateFilter(filter: GdcExecuteAFM.CompatibilityFilter): filter is GdcExecuteAFM.IAbsoluteDateFilter;
    function isAttributeFilter(filter: GdcExecuteAFM.CompatibilityFilter): filter is GdcExecuteAFM.AttributeFilterItem;
    function isPositiveAttributeFilter(filter: GdcExecuteAFM.CompatibilityFilter): filter is GdcExecuteAFM.IPositiveAttributeFilter;
    function isNegativeAttributeFilter(filter: GdcExecuteAFM.CompatibilityFilter): filter is GdcExecuteAFM.INegativeAttributeFilter;
    function isMeasureValueFilter(filter: GdcExecuteAFM.CompatibilityFilter): filter is GdcExecuteAFM.IMeasureValueFilter;
    function isRankingFilter(filter: GdcExecuteAFM.CompatibilityFilter): filter is GdcExecuteAFM.IRankingFilter;
    function isExpressionFilter(filter: GdcExecuteAFM.CompatibilityFilter): filter is GdcExecuteAFM.IExpressionFilter;
    function isAttributeElementsArray(attributeElements: AttributeElements): attributeElements is string[];
    function isAttributeElementsByRef(attributeElements: GdcExecuteAFM.AttributeElements): attributeElements is GdcExecuteAFM.IAttributeElementsByRef;
    function isAttributeElementsByValue(attributeElements: GdcExecuteAFM.AttributeElements): attributeElements is GdcExecuteAFM.IAttributeElementsByValue;
}
//# sourceMappingURL=GdcExecuteAFM.d.ts.map