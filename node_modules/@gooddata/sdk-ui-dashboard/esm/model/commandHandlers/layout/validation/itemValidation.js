import { __assign, __generator, __values } from "tslib";
import { areObjRefsEqual, insightRef, objRefToString } from "@gooddata/sdk-model";
import { isDashboardAttributeFilterReference, isInsightWidget, isKpiWidget, } from "@gooddata/sdk-backend-spi";
import invariant from "ts-invariant";
import { resolveInsights } from "../../../utils/insightResolver";
import { call, select } from "redux-saga/effects";
import isEmpty from "lodash/isEmpty";
import { invalidArgumentsProvided } from "../../../events/general";
import { extractInsightRefsFromItems } from "../../../utils/dashboardItemUtils";
import { insightSelectDateDataset, queryDateDatasetsForInsight, queryDateDatasetsForMeasure, } from "../../../queries";
import { query } from "../../../store/_infra/queryCall";
import { validateAttributeFiltersToIgnore, validateDatasetForInsightWidgetDateFilter, validateDatasetForKpiWidgetDateFilter, } from "../../widgets/validation/filterValidation";
import { selectFilterContextAttributeFilters } from "../../../store/filterContext/filterContextSelectors";
function normalizeItems(items, insights) {
    return items.map(function (item) {
        if (isInsightWidget(item.widget)) {
            var existingInsight = insights.get(item.widget.insight);
            invariant(existingInsight);
            return __assign(__assign({}, item), { widget: __assign(__assign({}, item.widget), { insight: insightRef(existingInsight) }) });
        }
        return item;
    });
}
/**
 * Given resolved items that should be added onto a dashboard, this function will ensure that items that reference
 * either KPI or Insight widgets reference valid insights or measures.
 *
 * Once the validity of used insights and measures is established, the code will additionally normalize the widget
 * definitions so that they use the native object `ref`s included in the referenced objects.
 *
 * This generator function will consult with backend on the existence of insights and measures if they are not
 * already stored in the state. If an insight is not found in the state but is available on the backend, the
 * insight will be retrieved and returned in the final validation result.
 */
export function validateAndNormalizeWidgetItems(ctx, items, cmd) {
    var insightRefs, resolvedInsights;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                insightRefs = extractInsightRefsFromItems(items.resolved);
                return [4 /*yield*/, call(resolveInsights, ctx, insightRefs)];
            case 1:
                resolvedInsights = _a.sent();
                if (!isEmpty(resolvedInsights.missing)) {
                    throw invalidArgumentsProvided(ctx, cmd, "Attempting to add dashboard items that reference missing insights: " + resolvedInsights.missing
                        .map(objRefToString)
                        .join(", "));
                }
                return [2 /*return*/, {
                        normalizedItems: __assign(__assign({}, items), { resolved: normalizeItems(items.resolved, resolvedInsights.resolved) }),
                        resolvedInsights: resolvedInsights,
                    }];
        }
    });
}
function validateAndResolveInsightWidgetFilters(ctx, cmd, widget, autoDateDataset, resolvedInsight) {
    var ignoredFilterRefs, insightDateDatasets;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                ignoredFilterRefs = widget.ignoreDashboardFilters
                    .filter(isDashboardAttributeFilterReference)
                    .map(function (f) { return f.displayForm; });
                return [4 /*yield*/, call(validateAttributeFiltersToIgnore, ctx, cmd, widget, ignoredFilterRefs)];
            case 1:
                _b.sent();
                if (!widget.dateDataSet) return [3 /*break*/, 3];
                return [4 /*yield*/, call(validateDatasetForInsightWidgetDateFilter, ctx, cmd, widget, widget.dateDataSet, resolvedInsight)];
            case 2:
                _b.sent();
                return [2 /*return*/, widget];
            case 3:
                if (!autoDateDataset) return [3 /*break*/, 5];
                return [4 /*yield*/, call(query, queryDateDatasetsForInsight(resolvedInsight))];
            case 4:
                insightDateDatasets = _b.sent();
                return [2 /*return*/, __assign(__assign({}, widget), { dateDataSet: (_a = insightSelectDateDataset(insightDateDatasets)) === null || _a === void 0 ? void 0 : _a.dataSet.ref })];
            case 5: return [2 /*return*/, widget];
        }
    });
}
function validateAndResolveKpiFilters(ctx, cmd, widget, autoDateDataset) {
    var ignoredFilterRefs, measureDateDatasets;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                ignoredFilterRefs = widget.ignoreDashboardFilters
                    .filter(isDashboardAttributeFilterReference)
                    .map(function (f) { return f.displayForm; });
                return [4 /*yield*/, call(validateAttributeFiltersToIgnore, ctx, cmd, widget, ignoredFilterRefs)];
            case 1:
                _b.sent();
                if (!widget.dateDataSet) return [3 /*break*/, 3];
                return [4 /*yield*/, call(validateDatasetForKpiWidgetDateFilter, ctx, cmd, widget, widget.dateDataSet)];
            case 2:
                _b.sent();
                return [2 /*return*/, widget];
            case 3:
                if (!autoDateDataset) return [3 /*break*/, 5];
                return [4 /*yield*/, call(query, queryDateDatasetsForMeasure(widget.kpi.metric))];
            case 4:
                measureDateDatasets = _b.sent();
                return [2 /*return*/, __assign(__assign({}, widget), { dateDataSet: (_a = measureDateDatasets[0]) === null || _a === void 0 ? void 0 : _a.dataSet.ref })];
            case 5: return [2 /*return*/, widget];
        }
    });
}
function removeObsoleteAttributeFilterIgnores(widget, attributeFilters) {
    var onlyExistingFilterIgnores = widget.ignoreDashboardFilters.filter(function (filterRef) {
        if (isDashboardAttributeFilterReference(filterRef)) {
            return attributeFilters.find(function (filter) {
                return areObjRefsEqual(filter.attributeFilter.displayForm, filterRef.displayForm);
            });
        }
        return true;
    });
    return __assign(__assign({}, widget), { ignoreDashboardFilters: onlyExistingFilterIgnores });
}
/**
 * This generator function will ensure that Insight and KPI widgets that are included in the `items`
 * have valid filter settings:
 *
 * -  the date dataset to use for filtering is correct
 * -  the attribute filters to ignore are correct and reference existing attribute filters
 *
 * Additionally, if the widget does not have dateDataSet to use for filtering set AND the `autoDateDataset` is true,
 * the generator will automatically update the widget with date dataset to use for filtering. It does this by
 * performing the necessary query to obtain relevant date dataset and then picking the most relevant one.
 *
 * @param ctx - dashboard context in which filter validation & resolution is done
 * @param items - items that are about to be added to the dashboard
 * @param cmd - command that is adding the items to the dashboard
 * @param autoDateDataset - indicates whether to automatically resolve and set date dataset to use for filtering for
 * KPI and Insight widgets.
 */
export function validateAndResolveItemFilterSettings(ctx, cmd, items, autoDateDataset) {
    var attributeFilters, resolvedInsights, normalizedItems, updatedItems, i, _a, _b, item, widget, isNew, updatedWidget, resolvedInsight, updatedWidget, updatedWidget, e_1_1;
    var e_1, _c;
    if (autoDateDataset === void 0) { autoDateDataset = false; }
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0: return [4 /*yield*/, select(selectFilterContextAttributeFilters)];
            case 1:
                attributeFilters = _d.sent();
                resolvedInsights = items.resolvedInsights, normalizedItems = items.normalizedItems;
                updatedItems = [];
                i = 0;
                _d.label = 2;
            case 2:
                _d.trys.push([2, 12, 13, 14]);
                _a = __values(normalizedItems.resolved), _b = _a.next();
                _d.label = 3;
            case 3:
                if (!!_b.done) return [3 /*break*/, 11];
                item = _b.value;
                widget = item.widget;
                isNew = normalizedItems.newItemBitmap[i];
                if (!!isNew) return [3 /*break*/, 4];
                /*
                 * processing an existing item; this is the case when some items from the layout got stashed and
                 * are now being retrieved from stash and added back onto the dashboard.
                 *
                 * the stashed items were already thoroughly validated & normalized the first time they were added onto the
                 * dashboard so the code does not have to re-do all the validations.
                 */
                if (isInsightWidget(widget) || isKpiWidget(widget)) {
                    updatedWidget = removeObsoleteAttributeFilterIgnores(widget, attributeFilters);
                    updatedItems.push(__assign(__assign({}, item), { widget: updatedWidget }));
                }
                else {
                    updatedItems.push(item);
                }
                return [3 /*break*/, 9];
            case 4:
                if (!isInsightWidget(widget)) return [3 /*break*/, 6];
                resolvedInsight = resolvedInsights.resolved.get(widget.insight);
                // if code gets here and the insight for the widget is not found it means either the resolution logic
                // or the logic to verify resolution result has failed. normally if insight widget references missing
                // insight the handler should find this and fail way sooner
                invariant(resolvedInsight);
                return [4 /*yield*/, call(validateAndResolveInsightWidgetFilters, ctx, cmd, widget, autoDateDataset, resolvedInsight)];
            case 5:
                updatedWidget = _d.sent();
                updatedItems.push(__assign(__assign({}, item), { widget: updatedWidget }));
                return [3 /*break*/, 9];
            case 6:
                if (!isKpiWidget(widget)) return [3 /*break*/, 8];
                return [4 /*yield*/, call(validateAndResolveKpiFilters, ctx, cmd, widget, autoDateDataset)];
            case 7:
                updatedWidget = _d.sent();
                updatedItems.push(__assign(__assign({}, item), { widget: updatedWidget }));
                return [3 /*break*/, 9];
            case 8:
                updatedItems.push(item);
                _d.label = 9;
            case 9:
                i++;
                _d.label = 10;
            case 10:
                _b = _a.next();
                return [3 /*break*/, 3];
            case 11: return [3 /*break*/, 14];
            case 12:
                e_1_1 = _d.sent();
                e_1 = { error: e_1_1 };
                return [3 /*break*/, 14];
            case 13:
                try {
                    if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                }
                finally { if (e_1) throw e_1.error; }
                return [7 /*endfinally*/];
            case 14: return [2 /*return*/, updatedItems];
        }
    });
}
//# sourceMappingURL=itemValidation.js.map