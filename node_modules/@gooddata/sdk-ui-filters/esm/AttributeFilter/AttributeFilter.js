import { __awaiter, __generator } from "tslib";
// (C) 2007-2018 GoodData Corporation
import React, { useEffect } from "react";
import { injectIntl } from "react-intl";
import MediaQuery from "react-responsive";
import { filterAttributeElements, isAttributeElementsByRef, isPositiveAttributeFilter, newNegativeAttributeFilter, newPositiveAttributeFilter, } from "@gooddata/sdk-model";
import { AttributeDropdown } from "./AttributeDropdown/AttributeDropdown";
import { defaultErrorHandler, IntlTranslationsProvider, IntlWrapper, useCancelablePromise, usePlaceholder, useResolveValueWithPlaceholders, withContexts, } from "@gooddata/sdk-ui";
import { MediaQueries } from "../constants";
import { attributeElementsToAttributeElementArray, getObjRef, getParentFilterTitles, getValidElementsFilters, } from "./utils/AttributeFilterUtils";
import invariant from "ts-invariant";
import stringify from "json-stable-stringify";
var DefaultFilterError = injectIntl(function (_a) {
    var intl = _a.intl;
    var text = intl.formatMessage({ id: "gs.filter.error" });
    return React.createElement("div", { className: "gd-message error s-button-error" }, text);
});
var AttributeFilterCore = function (props) {
    invariant(!(props.filter && props.connectToPlaceholder), "It's not possible to combine 'filter' property with 'connectToPlaceholder' property. Either provide a value, or a placeholder.");
    invariant(!(props.filter && !props.onApply), "It's not possible to use 'filter' property without 'onApply' property. Either provide 'onApply' callback or use placeholders.");
    var locale = props.locale, workspace = props.workspace, backend = props.backend, _a = props.FilterError, FilterError = _a === void 0 ? DefaultFilterError : _a, title = props.title, _b = props.titleWithSelection, titleWithSelection = _b === void 0 ? false : _b, _c = props.fullscreenOnMobile, fullscreenOnMobile = _c === void 0 ? false : _c, identifier = props.identifier, filter = props.filter, parentFilters = props.parentFilters, connectToPlaceholder = props.connectToPlaceholder, parentFilterOverAttribute = props.parentFilterOverAttribute, _d = props.onError, onError = _d === void 0 ? defaultErrorHandler : _d, onApply = props.onApply;
    var resolvedParentFilters = useResolveValueWithPlaceholders(parentFilters);
    var _e = usePlaceholder(connectToPlaceholder), resolvedPlaceholder = _e[0], setPlaceholderValue = _e[1];
    var currentFilter = resolvedPlaceholder || filter;
    var getBackend = function () {
        return backend.withTelemetry("AttributeFilter", props);
    };
    var _f = useCancelablePromise({
        promise: function () { return __awaiter(void 0, void 0, void 0, function () {
            var attributes, displayForm, attribute;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        attributes = getBackend().workspace(workspace).attributes();
                        return [4 /*yield*/, attributes.getAttributeDisplayForm(getObjRef(currentFilter, identifier))];
                    case 1:
                        displayForm = _a.sent();
                        return [4 /*yield*/, attributes.getAttribute(displayForm.attribute)];
                    case 2:
                        attribute = _a.sent();
                        return [2 /*return*/, attribute.title];
                }
            });
        }); },
    }, [identifier, workspace]), attributeTitle = _f.result, attributeError = _f.error, attributeStatus = _f.status;
    var _g = useCancelablePromise({
        promise: function () { return getParentFilterTitles(resolvedParentFilters !== null && resolvedParentFilters !== void 0 ? resolvedParentFilters : [], getBackend(), props.workspace); },
    }, [props.backend, props.workspace, stringify(resolvedParentFilters)]), parentFilterTitlesError = _g.error, parentFilterTitles = _g.result, parentFilterTitlesStatus = _g.status;
    var onFilterApply = function (selectedItems, isInverted) {
        var useUriElements = currentFilter && isAttributeElementsByRef(filterAttributeElements(currentFilter));
        var filterFactory = isInverted ? newNegativeAttributeFilter : newPositiveAttributeFilter;
        var filter = filterFactory(getObjRef(currentFilter, identifier), useUriElements
            ? { uris: selectedItems.map(function (item) { return item.uri; }) }
            : { values: selectedItems.map(function (item) { return item.title; }) });
        if (connectToPlaceholder) {
            setPlaceholderValue(filter);
        }
        return onApply === null || onApply === void 0 ? void 0 : onApply(filter);
    };
    useEffect(function () {
        if (attributeError || parentFilterTitlesError) {
            onError(attributeError || parentFilterTitlesError);
        }
    }, [attributeError, parentFilterTitlesError]);
    var getInitialDropdownSelection = function () {
        if (!currentFilter) {
            return {
                isInverted: true,
                selectedItems: [],
            };
        }
        var elements = filterAttributeElements(currentFilter);
        return {
            isInverted: !isPositiveAttributeFilter(currentFilter),
            selectedItems: attributeElementsToAttributeElementArray(elements),
        };
    };
    var _h = getInitialDropdownSelection(), selectedItems = _h.selectedItems, isInverted = _h.isInverted;
    return (React.createElement(IntlWrapper, { locale: locale }, attributeError || parentFilterTitlesError ? (React.createElement(FilterError, { error: attributeError || parentFilterTitlesError })) : (React.createElement(MediaQuery, { query: MediaQueries.IS_MOBILE_DEVICE }, function (isMobile) { return (React.createElement(IntlTranslationsProvider, null, function (translationProps) {
        return (React.createElement(AttributeDropdown, { titleWithSelection: titleWithSelection, displayForm: getObjRef(currentFilter, identifier), backend: backend, workspace: workspace, onApply: onFilterApply, title: title || attributeTitle, isInverted: isInverted, selectedItems: selectedItems, isLoading: attributeStatus === "pending" ||
                attributeStatus === "loading" ||
                parentFilterTitlesStatus == "pending" ||
                parentFilterTitlesStatus === "loading", translationProps: translationProps, isMobile: isMobile, fullscreenOnMobile: fullscreenOnMobile, parentFilters: getValidElementsFilters(resolvedParentFilters, parentFilterOverAttribute), parentFilterTitles: parentFilterTitles }));
    })); }))));
};
/**
 * AttributeFilter is a component that renders a dropdown populated with attribute values
 * for specified attribute display form.
 *
 * @public
 */
export var AttributeFilter = withContexts(AttributeFilterCore);
//# sourceMappingURL=AttributeFilter.js.map