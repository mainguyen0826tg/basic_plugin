import { __assign } from "tslib";
// (C) 2007-2021 GoodData Corporation
import { BucketNames } from "@gooddata/sdk-ui";
import { isBarChart, isBubbleChart, isHeatmap, isOneOfTypes, isScatterPlot, unwrap } from "../_util/common";
import { supportedDualAxesChartTypes } from "./chartCapabilities";
import isEmpty from "lodash/isEmpty";
import compact from "lodash/compact";
import findIndex from "lodash/findIndex";
import range from "lodash/range";
import includes from "lodash/includes";
function preprocessMeasureGroupItems(measureGroup, defaultValues) {
    return measureGroup.items.map(function (item, index) {
        var unwrapped = unwrap(item);
        return index
            ? {
                label: unwrapped.name,
                format: unwrapped.format,
            }
            : {
                label: defaultValues.label || unwrapped.name,
                format: defaultValues.format || unwrapped.format,
            };
    });
}
export function getXAxes(dv, config, measureGroup, viewByAttribute) {
    var type = config.type;
    if (isScatterPlot(type) || isBubbleChart(type)) {
        var measureGroupItems = preprocessMeasureGroupItems(measureGroup, {
            label: config.xLabel,
            format: config.xFormat,
        });
        var firstMeasureGroupItem = measureGroupItems[0];
        var noPrimaryMeasures = dv.def().isBucketEmpty(BucketNames.MEASURES);
        if (noPrimaryMeasures) {
            return [
                {
                    label: "",
                },
            ];
        }
        else {
            return [
                {
                    label: firstMeasureGroupItem.label || "",
                    format: firstMeasureGroupItem.format || "",
                },
            ];
        }
    }
    var xLabel = config.xLabel || (viewByAttribute ? viewByAttribute.formOf.name : "");
    return [
        {
            label: xLabel,
        },
    ];
}
export function getYAxes(dv, config, measureGroup, stackByAttribute) {
    var type = config.type;
    var measureGroupItems = preprocessMeasureGroupItems(measureGroup, {
        label: config.yLabel,
        format: config.yFormat,
    });
    var firstMeasureGroupItem = measureGroupItems[0];
    var secondMeasureGroupItem = measureGroupItems[1];
    var hasMoreThanOneMeasure = measureGroupItems.length > 1;
    var noPrimaryMeasures = dv.def().isBucketEmpty(BucketNames.MEASURES);
    var _a = ((isBarChart(type) ? config.secondary_xaxis : config.secondary_yaxis) || {}).measures, secondaryAxisMeasures = _a === void 0 ? [] : _a;
    var yAxes = [];
    if (isScatterPlot(type) || isBubbleChart(type)) {
        var hasSecondaryMeasure = !dv.def().isBucketEmpty(BucketNames.SECONDARY_MEASURES);
        if (hasSecondaryMeasure) {
            if (noPrimaryMeasures) {
                yAxes = [
                    __assign({}, firstMeasureGroupItem),
                ];
            }
            else {
                yAxes = [
                    __assign({}, secondMeasureGroupItem),
                ];
            }
        }
        else {
            yAxes = [{ label: "" }];
        }
    }
    else if (isHeatmap(type)) {
        yAxes = [
            {
                label: stackByAttribute ? stackByAttribute.formOf.name : "",
            },
        ];
    }
    else if (isOneOfTypes(type, supportedDualAxesChartTypes) &&
        !isEmpty(measureGroupItems) &&
        !isEmpty(secondaryAxisMeasures)) {
        var _b = assignMeasuresToAxes(secondaryAxisMeasures, measureGroup), measuresInFirstAxis = _b.measuresInFirstAxis, measuresInSecondAxis = _b.measuresInSecondAxis;
        var firstAxis = createYAxisItem(measuresInFirstAxis, false);
        var secondAxis = createYAxisItem(measuresInSecondAxis, true);
        if (firstAxis) {
            firstAxis = __assign(__assign({}, firstAxis), { seriesIndices: measuresInFirstAxis.map(function (_a) {
                    var index = _a.index;
                    return index;
                }) });
        }
        if (secondAxis) {
            secondAxis = __assign(__assign({}, secondAxis), { seriesIndices: measuresInSecondAxis.map(function (_a) {
                    var index = _a.index;
                    return index;
                }) });
        }
        yAxes = compact([firstAxis, secondAxis]);
    }
    else {
        // if more than one measure and NOT dual, then have empty item name
        var nonDualMeasureAxis = hasMoreThanOneMeasure
            ? {
                label: "",
            }
            : {};
        yAxes = [
            __assign(__assign(__assign({}, firstMeasureGroupItem), nonDualMeasureAxis), { seriesIndices: range(measureGroupItems.length) }),
        ];
    }
    return yAxes;
}
function assignMeasuresToAxes(secondMeasures, measureGroup) {
    return measureGroup.items.reduce(function (result, _a, index) {
        var _b = _a.measureHeaderItem, name = _b.name, format = _b.format, localIdentifier = _b.localIdentifier;
        if (includes(secondMeasures, localIdentifier)) {
            result.measuresInSecondAxis.push({ name: name, format: format, index: index });
        }
        else {
            result.measuresInFirstAxis.push({ name: name, format: format, index: index });
        }
        return result;
    }, {
        measuresInFirstAxis: [],
        measuresInSecondAxis: [],
    });
}
function createYAxisItem(measuresInAxis, opposite) {
    if (opposite === void 0) { opposite = false; }
    var length = measuresInAxis.length;
    if (length) {
        var _a = measuresInAxis[0], name_1 = _a.name, format = _a.format;
        return {
            label: length === 1 ? name_1 : "",
            format: format,
            opposite: opposite,
        };
    }
    return null;
}
export function assignYAxes(series, yAxes) {
    return series.reduce(function (result, item, index) {
        var yAxisIndex = findIndex(yAxes, function (axis) {
            var _a;
            return includes((_a = axis.seriesIndices) !== null && _a !== void 0 ? _a : [], index);
        });
        // for case viewBy and stackBy have one attribute, and one measure is sliced to multiple series
        // then 'yAxis' in other series should follow the first one
        var firstYAxisIndex = result.length > 0 ? result[0].yAxis : 0;
        var seriesItem = __assign(__assign({}, item), { yAxis: yAxisIndex !== -1 ? yAxisIndex : firstYAxisIndex });
        result.push(seriesItem);
        return result;
    }, []);
}
//# sourceMappingURL=chartAxes.js.map