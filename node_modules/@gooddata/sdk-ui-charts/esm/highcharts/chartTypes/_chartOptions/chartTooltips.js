import { colors2Object, numberFormat } from "@gooddata/numberjs";
import { customEscape, isCssMultiLineTruncationSupported, isOneOfTypes, isTreemap } from "../_util/common";
import { formatValueForTooltip, getFormattedValueForTooltip } from "./tooltip";
import { multiMeasuresAlternatingTypes } from "./chartCapabilities";
import cx from "classnames";
var TOOLTIP_PADDING = 10;
var renderTooltipHTML = function (textData, maxTooltipContentWidth) {
    var maxItemWidth = maxTooltipContentWidth - TOOLTIP_PADDING * 2;
    var titleMaxWidth = maxItemWidth;
    var multiLineTruncationSupported = isCssMultiLineTruncationSupported();
    var threeDotsWidth = 16;
    var valueMaxWidth = multiLineTruncationSupported ? maxItemWidth : maxItemWidth - threeDotsWidth;
    var titleStyle = "style=\"max-width: " + titleMaxWidth + "px;\"";
    var valueStyle = "style=\"max-width: " + valueMaxWidth + "px;\"";
    var itemClass = cx("gd-viz-tooltip-item", {
        "multiline-supported": multiLineTruncationSupported,
    });
    var valueClass = cx("gd-viz-tooltip-value", {
        "clamp-two-line": multiLineTruncationSupported,
    });
    return textData
        .map(function (item) {
        // the third span is hidden, that help to have tooltip work with max-width
        return "<div class=\"" + itemClass + "\">\n                        <span class=\"gd-viz-tooltip-title\" " + titleStyle + ">" + item[0] + "</span>\n                        <div class=\"gd-viz-tooltip-value-wraper\" " + titleStyle + ">\n                            <span class=\"" + valueClass + "\" " + valueStyle + ">" + item[1] + "</span>\n                        </div>\n                        <div class=\"gd-viz-tooltip-value-wraper\" " + titleStyle + ">\n                            <span class=\"gd-viz-tooltip-value-max-content\" " + valueStyle + ">" + item[1] + "</span>\n                        </div>\n                    </div>";
    })
        .join("\n");
};
function isPointOnOppositeAxis(point) {
    var _a, _b;
    return (_b = (_a = point.series) === null || _a === void 0 ? void 0 : _a.yAxis.opposite) !== null && _b !== void 0 ? _b : false;
}
function getMeasureTextData(measure, formattedValue) {
    if (measure) {
        return [[customEscape(measure.measureHeaderItem.name), formattedValue]];
    }
    return [];
}
function getTextDataWithStackByAttribute(measure, formattedValue, stackByAttribute, point) {
    var textData = getMeasureTextData(measure, formattedValue);
    textData.unshift([
        customEscape(stackByAttribute.formOf.name),
        customEscape(customEscape(point.series.name)),
    ]);
    return textData;
}
export function buildTooltipFactory(viewByAttribute, type, config, isDualAxis, measure, stackByAttribute) {
    if (config === void 0) { config = {}; }
    if (isDualAxis === void 0) { isDualAxis = false; }
    var separators = config.separators, _a = config.stackMeasuresToPercent, stackMeasuresToPercent = _a === void 0 ? false : _a;
    return function (point, maxTooltipContentWidth, percentageValue) {
        var isDualChartWithRightAxis = isDualAxis && isPointOnOppositeAxis(point);
        var formattedValue = getFormattedValueForTooltip(isDualChartWithRightAxis, stackMeasuresToPercent, point, separators, percentageValue);
        var textData = [[customEscape(point.series.name), formattedValue]];
        if (stackByAttribute) {
            textData = getTextDataWithStackByAttribute(measure, formattedValue, stackByAttribute, point);
        }
        if (viewByAttribute) {
            // For some reason, highcharts ommit categories for pie charts with attribute. Use point.name instead.
            // use attribute name instead of attribute display form name
            textData.unshift([
                customEscape(viewByAttribute.formOf.name),
                // since applying 'grouped-categories' plugin,
                // 'category' type is replaced from string to object in highchart
                customEscape((point.category && point.category.name) || point.name),
            ]);
        }
        else if (isOneOfTypes(type, multiMeasuresAlternatingTypes)) {
            // Pie charts with measure only have to use point.name instead of series.name to get the measure name
            textData[0][0] = customEscape(point.name);
        }
        return renderTooltipHTML(textData, maxTooltipContentWidth);
    };
}
export function buildTooltipForTwoAttributesFactory(viewByAttribute, viewByParentAttribute, config, isDualAxis, measure, stackByAttribute) {
    if (config === void 0) { config = {}; }
    if (isDualAxis === void 0) { isDualAxis = false; }
    var separators = config.separators, _a = config.stackMeasuresToPercent, stackMeasuresToPercent = _a === void 0 ? false : _a;
    return function (point, maxTooltipContentWidth, percentageValue) {
        var category = point.category;
        var isDualChartWithRightAxis = isDualAxis && isPointOnOppositeAxis(point);
        var formattedValue = getFormattedValueForTooltip(isDualChartWithRightAxis, stackMeasuresToPercent, point, separators, percentageValue);
        var textData = [[customEscape(point.series.name), formattedValue]];
        if (stackByAttribute) {
            textData = getTextDataWithStackByAttribute(measure, formattedValue, stackByAttribute, point);
        }
        if (category) {
            if (viewByAttribute) {
                textData.unshift([customEscape(viewByAttribute.formOf.name), customEscape(category.name)]);
            }
            if (viewByParentAttribute && category.parent) {
                textData.unshift([
                    customEscape(viewByParentAttribute.formOf.name),
                    customEscape(category.parent.name),
                ]);
            }
        }
        return renderTooltipHTML(textData, maxTooltipContentWidth);
    };
}
export function generateTooltipXYFn(measures, stackByAttribute, config) {
    if (config === void 0) { config = {}; }
    var separators = config.separators;
    return function (point, maxTooltipContentWidth) {
        var textData = [];
        var name = point.name ? point.name : point.series.name;
        if (stackByAttribute) {
            textData.unshift([customEscape(stackByAttribute.formOf.name), customEscape(name)]);
        }
        if (measures[0]) {
            textData.push([
                customEscape(measures[0].measureHeaderItem.name),
                formatValueForTooltip(point.x, measures[0].measureHeaderItem.format, separators),
            ]);
        }
        if (measures[1]) {
            textData.push([
                customEscape(measures[1].measureHeaderItem.name),
                formatValueForTooltip(point.y, measures[1].measureHeaderItem.format, separators),
            ]);
        }
        if (measures[2]) {
            textData.push([
                customEscape(measures[2].measureHeaderItem.name),
                formatValueForTooltip(point.z, measures[2].measureHeaderItem.format, separators),
            ]);
        }
        return renderTooltipHTML(textData, maxTooltipContentWidth);
    };
}
export function generateTooltipHeatmapFn(viewByAttribute, stackByAttribute, config) {
    if (config === void 0) { config = {}; }
    var separators = config.separators;
    var formatValue = function (val, format) {
        return colors2Object(val === null ? "-" : numberFormat(val, format, undefined, separators));
    };
    return function (point, maxTooltipContentWidth) {
        var formattedValue = customEscape(formatValue(point.value, point.series.userOptions.dataLabels.formatGD).label);
        var textData = [];
        textData.unshift([customEscape(point.series.name), formattedValue]);
        if (viewByAttribute) {
            textData.unshift([
                customEscape(viewByAttribute.formOf.name),
                customEscape(viewByAttribute.items[point.x].attributeHeaderItem.name),
            ]);
        }
        if (stackByAttribute) {
            textData.unshift([
                customEscape(stackByAttribute.formOf.name),
                customEscape(stackByAttribute.items[point.y].attributeHeaderItem.name),
            ]);
        }
        return renderTooltipHTML(textData, maxTooltipContentWidth);
    };
}
export function buildTooltipTreemapFactory(viewByAttribute, stackByAttribute, config) {
    if (config === void 0) { config = {}; }
    var separators = config.separators;
    return function (point, maxTooltipContentWidth) {
        // show tooltip for leaf node only
        if (!point.node || point.node.isLeaf === false) {
            return null;
        }
        var formattedValue = formatValueForTooltip(point.value, point.format, separators);
        var textData = [];
        if (stackByAttribute) {
            textData.push([
                customEscape(stackByAttribute.formOf.name),
                customEscape(stackByAttribute.items[point.y].attributeHeaderItem.name),
            ]);
        }
        if (viewByAttribute) {
            textData.unshift([
                customEscape(viewByAttribute.formOf.name),
                customEscape(viewByAttribute.items[point.x].attributeHeaderItem.name),
            ]);
            textData.push([customEscape(point.series.name), formattedValue]);
        }
        else {
            textData.push([customEscape(point.category && point.category.name), formattedValue]);
        }
        return renderTooltipHTML(textData, maxTooltipContentWidth);
    };
}
export function getTooltipFactory(isViewByTwoAttributes, viewByAttribute, viewByParentAttribute, stackByAttribute, measure, config, isDualAxis) {
    if (config === void 0) { config = {}; }
    if (isDualAxis === void 0) { isDualAxis = false; }
    var type = config.type;
    if (isTreemap(type)) {
        return buildTooltipTreemapFactory(viewByAttribute, stackByAttribute, config);
    }
    if (isViewByTwoAttributes) {
        return buildTooltipForTwoAttributesFactory(viewByAttribute, viewByParentAttribute, config, isDualAxis, measure, stackByAttribute);
    }
    return buildTooltipFactory(viewByAttribute, type, config, isDualAxis, measure, stackByAttribute);
}
//# sourceMappingURL=chartTooltips.js.map