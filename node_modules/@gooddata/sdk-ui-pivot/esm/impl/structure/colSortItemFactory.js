// (C) 2021 GoodData Corporation
import { isSeriesCol, isSliceCol } from "./tableDescriptorTypes";
import { invariant, InvariantError } from "ts-invariant";
import { isAttributeAreaSort, isAttributeSort, newAttributeAreaSort, newAttributeSort, } from "@gooddata/sdk-model";
import zip from "lodash/zip";
function createAttributeLocator(attribute, header) {
    // if this bombs it means something is wrong with the col descriptors or in very bad case in the DVF data access logic.
    // by contract, all data series have same number of descriptors & headers. therefore the zipping logic should never
    // run into situation where the arrays are of different size.
    invariant(attribute && header);
    return {
        attributeLocatorItem: {
            attributeIdentifier: attribute.attributeHeader.localIdentifier,
            element: header.attributeHeaderItem.uri,
        },
    };
}
function createMeasureLocator(measure) {
    return {
        measureLocatorItem: {
            measureIdentifier: measure.measureHeaderItem.localIdentifier,
        },
    };
}
/**
 * Creates a SortItem for the provided column, sorting in particular direction. Depending on the column type,
 * this factory will create either an attribute sort item or measure sort item with appropriate locators.
 *
 * Note the originalSorts. These are optional, if provided they are used when creating an attribute sort to
 * determine whether to create 'normal' or area sort for that column.
 *
 * @param col - col to get sort item for
 * @param direction - sort direction
 * @param originalSorts - original sorts, optional, to determine if area sort indicator should be transferred.
 */
export function createSortItemForCol(col, direction, originalSorts) {
    if (originalSorts === void 0) { originalSorts = []; }
    if (isSliceCol(col)) {
        var attributeLocalId_1 = col.attributeDescriptor.attributeHeader.localIdentifier;
        var matchingOriginalSortItem = originalSorts.find(function (s) { return isAttributeSort(s) && s.attributeSortItem.attributeIdentifier === attributeLocalId_1; });
        return isAttributeAreaSort(matchingOriginalSortItem)
            ? newAttributeAreaSort(attributeLocalId_1, direction)
            : newAttributeSort(attributeLocalId_1, direction);
    }
    else if (isSeriesCol(col)) {
        var locators_1 = [];
        if (col.seriesDescriptor.attributeDescriptors && col.seriesDescriptor.attributeHeaders) {
            var descriptorAndHeaders = zip(col.seriesDescriptor.attributeDescriptors, col.seriesDescriptor.attributeHeaders);
            descriptorAndHeaders.forEach(function (_a) {
                var descriptor = _a[0], header = _a[1];
                return locators_1.push(createAttributeLocator(descriptor, header));
            });
        }
        locators_1.push(createMeasureLocator(col.seriesDescriptor.measureDescriptor));
        return {
            measureSortItem: {
                direction: direction,
                locators: locators_1,
            },
        };
    }
    throw new InvariantError("cannot get sort item for the column type " + col.type);
}
//# sourceMappingURL=colSortItemFactory.js.map