import { __assign, __awaiter, __generator, __spreadArrays } from "tslib";
// (C) 2007-2021 GoodData Corporation
import find from "lodash/find";
import omit from "lodash/omit";
import omitBy from "lodash/omitBy";
import isEmpty from "lodash/isEmpty";
import cloneDeep from "lodash/cloneDeep";
import { omitEmpty } from "./util";
var REQUEST_DEFAULTS = {
    types: ["attribute", "metric", "fact"],
    paging: {
        offset: 0,
    },
};
var LOAD_DATE_DATASET_DEFAULTS = {
    includeUnavailableDateDataSetsCount: true,
    includeAvailableDateAttributes: true,
};
/**
 * Convert specific params in options to "requiredDataSets" structure. For more details look into
 * res file https://github.com/gooddata/gdc-bear/blob/develop/resources/specification/internal/catalog.res
 *
 * @param options Supported keys in options are:
 * <ul>
 * <li>dataSetIdentifier - in value is string identifier of dataSet - this leads to CUSTOM type
 * <li>returnAllDateDataSets - true value means to return ALL values without dataSet differentiation
 * <li>returnAllRelatedDateDataSets - only related date dataSets are loaded across all dataSets
 * <li>by default we get PRODUCTION dataSets
 * </ul>
 * @returns {Object} "requiredDataSets" object hash.
 */
var getRequiredDataSets = function (options) {
    if (options === void 0) { options = {}; }
    if (options.returnAllRelatedDateDataSets) {
        return {};
    }
    if (options.returnAllDateDataSets) {
        return { requiredDataSets: { type: "ALL" } };
    }
    if (options.dataSetIdentifier) {
        return {
            requiredDataSets: {
                type: "CUSTOM",
                customIdentifiers: [options.dataSetIdentifier],
            },
        };
    }
    return { requiredDataSets: { type: "PRODUCTION" } };
};
var buildItemDescriptionObjects = function (_a) {
    var columns = _a.columns, definitions = _a.definitions;
    if (!columns) {
        return [];
    }
    return columns.map(function (column) {
        var _a;
        var definition = find(definitions, function (_a) {
            var metricDefinition = _a.metricDefinition;
            return metricDefinition.identifier === column;
        });
        var maql = (_a = definition === null || definition === void 0 ? void 0 : definition.metricDefinition) === null || _a === void 0 ? void 0 : _a.expression;
        if (maql) {
            return { expression: maql };
        }
        return { uri: column };
    });
};
var isStoredItemDescription = function (itemDescription) {
    return !!itemDescription.uri;
};
var isAdHocItemDescription = function (itemDescription) {
    return !!itemDescription.expression;
};
var unwrapItemDescriptionObject = function (itemDescription) {
    if (isStoredItemDescription(itemDescription)) {
        return itemDescription.uri;
    }
    if (isAdHocItemDescription(itemDescription)) {
        return itemDescription.expression;
    }
    throw new Error("Item description can only have expression or uri");
};
// When the limit is more than 500,
// catalog items endpoint returns status of 500
var CATALOG_ITEMS_LIMIT = 500;
var CatalogueModule = /** @class */ (function () {
    function CatalogueModule(xhr, execution) {
        this.xhr = xhr;
        this.execution = execution;
    }
    /**
     * Load all catalog items
     * @param projectId string
     * @param options GdcCatalog.ILoadCatalogItemsParams
     */
    CatalogueModule.prototype.loadAllItems = function (projectId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var sanitizedOptions, loadAll;
            var _this = this;
            return __generator(this, function (_a) {
                sanitizedOptions = omitEmpty(options);
                loadAll = function (requestOptions, items) {
                    if (items === void 0) { items = []; }
                    return __awaiter(_this, void 0, void 0, function () {
                        var result, resultItems, updatedItems, updatedRequestOptions;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, this.xhr.getParsed("/gdc/internal/projects/" + projectId + "/catalog/items", {
                                        data: requestOptions,
                                    })];
                                case 1:
                                    result = _a.sent();
                                    resultItems = result.catalogItems.items;
                                    updatedItems = __spreadArrays(items, resultItems);
                                    if (resultItems.length === requestOptions.limit) {
                                        updatedRequestOptions = __assign(__assign({}, requestOptions), { offset: result.catalogItems.paging.offset + requestOptions.limit });
                                        return [2 /*return*/, loadAll(updatedRequestOptions, updatedItems)];
                                    }
                                    return [2 /*return*/, updatedItems];
                            }
                        });
                    });
                };
                return [2 /*return*/, loadAll(__assign({ offset: 0, limit: CATALOG_ITEMS_LIMIT }, sanitizedOptions))];
            });
        });
    };
    /**
     * Load catalog groups
     * @param projectId string
     * @param options GdcCatalog.ILoadCatalogGroupsParams
     */
    CatalogueModule.prototype.loadGroups = function (projectId, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.xhr.getParsed("/gdc/internal/projects/" + projectId + "/catalog/groups", {
                            data: omitEmpty(options),
                        })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.catalogGroups];
                }
            });
        });
    };
    /**
     * Load available item uris by already used uris and expressions
     * @param projectId string
     * @param options GdcCatalog.ILoadAvailableCatalogItemsParams
     */
    CatalogueModule.prototype.loadAvailableItemUris = function (projectId, options) {
        return __awaiter(this, void 0, void 0, function () {
            var sanitizedCatalogQueryRequest, result;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        sanitizedCatalogQueryRequest = omitBy(options.catalogQueryRequest, isEmpty);
                        return [4 /*yield*/, this.xhr.postParsed("/gdc/internal/projects/" + projectId + "/catalog/query", {
                                data: {
                                    catalogQueryRequest: sanitizedCatalogQueryRequest,
                                },
                            })];
                    case 1:
                        result = _a.sent();
                        return [2 /*return*/, result.catalogAvailableItems.items];
                }
            });
        });
    };
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    CatalogueModule.prototype.loadItems = function (projectId, options) {
        var _this = this;
        var _a;
        if (options === void 0) { options = {}; }
        var request = omit(__assign(__assign(__assign({}, REQUEST_DEFAULTS), options), getRequiredDataSets(options)), ["dataSetIdentifier", "returnAllDateDataSets", "attributesMap"]);
        var mdObj = (_a = cloneDeep(options)) === null || _a === void 0 ? void 0 : _a.bucketItems;
        var attributesMap = options === null || options === void 0 ? void 0 : options.attributesMap;
        var hasBuckets = (mdObj === null || mdObj === void 0 ? void 0 : mdObj.buckets) !== undefined;
        if (hasBuckets) {
            return this.loadItemDescriptions(projectId, mdObj, attributesMap).then(function (bucketItems) {
                return _this.loadCatalog(projectId, __assign(__assign({}, request), { bucketItems: bucketItems }));
            });
        }
        return this.loadCatalog(projectId, request);
    };
    CatalogueModule.prototype.loadDateDataSets = function (projectId, options) {
        return __awaiter(this, void 0, void 0, function () {
            var mdObj, bucketItems, _a, omittedOptions, request;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        mdObj = cloneDeep(options).bucketItems;
                        if (!mdObj) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.loadItemDescriptions(projectId, mdObj, options.attributesMap)];
                    case 1:
                        _a = _b.sent();
                        return [3 /*break*/, 3];
                    case 2:
                        _a = undefined;
                        _b.label = 3;
                    case 3:
                        bucketItems = _a;
                        omittedOptions = [
                            "filter",
                            "types",
                            "paging",
                            "dataSetIdentifier",
                            "returnAllDateDataSets",
                            "returnAllRelatedDateDataSets",
                            "attributesMap",
                        ];
                        // includeObjectsWithTags has higher priority than excludeObjectsWithTags,
                        // so when present omit excludeObjectsWithTags
                        if (options.includeObjectsWithTags) {
                            omittedOptions.push("excludeObjectsWithTags");
                        }
                        request = omit(__assign(__assign(__assign(__assign(__assign({}, LOAD_DATE_DATASET_DEFAULTS), REQUEST_DEFAULTS), options), getRequiredDataSets(options)), { bucketItems: bucketItems }), omittedOptions);
                        return [2 /*return*/, this.requestDateDataSets(projectId, request)];
                }
            });
        });
    };
    /**
     * Loads item description objects and returns them
     *
     * @internal
     * @private
     *
     * @param projectId {string}
     * @param mdObj metadata object containing buckets, visualization class, properties etc.
     * @param attributesMap contains map of attributes where the keys are the attributes display forms URIs
     * @param removeDateItems {boolean} skip date items
     * @return ItemDescription which is either `{ uri: string }` or `{ expression: string }`
     */
    CatalogueModule.prototype.loadItemDescriptionObjects = function (projectId, mdObj, attributesMap, removeDateItems) {
        if (attributesMap === void 0) { attributesMap = {}; }
        if (removeDateItems === void 0) { removeDateItems = false; }
        return __awaiter(this, void 0, void 0, function () {
            var definitionsAndColumns;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.execution.mdToExecutionDefinitionsAndColumns(projectId, mdObj, { attributesMap: attributesMap, removeDateItems: removeDateItems })];
                    case 1:
                        definitionsAndColumns = _a.sent();
                        return [2 /*return*/, buildItemDescriptionObjects(definitionsAndColumns)];
                }
            });
        });
    };
    /**
     * ItemDescription is either URI or MAQL expression
     * https://github.com/gooddata/gdc-bear/blob/185.4/resources/specification/md/obj.res#L284
     *
     * @param projectId {string}
     * @param mdObj metadata object containing buckets, visualization class, properties etc.
     * @param attributesMap contains map of attributes where the keys are the attributes display forms URIs
     * @param removeDateItems {boolean} skip date items
     * @deprecated
     */
    CatalogueModule.prototype.loadItemDescriptions = function (projectId, 
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    mdObj, attributesMap, removeDateItems) {
        if (removeDateItems === void 0) { removeDateItems = false; }
        return __awaiter(this, void 0, void 0, function () {
            var itemDescriptions;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.loadItemDescriptionObjects(projectId, mdObj, attributesMap, removeDateItems)];
                    case 1:
                        itemDescriptions = _a.sent();
                        return [2 /*return*/, itemDescriptions.map(unwrapItemDescriptionObject)];
                }
            });
        });
    };
    /**
     * Loads all available data sets.
     * @param projectId
     */
    CatalogueModule.prototype.loadDataSets = function (projectId) {
        return __awaiter(this, void 0, void 0, function () {
            var uri, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        uri = "/gdc/dataload/internal/projects/" + projectId + "/csv/datasets";
                        return [4 /*yield*/, this.xhr.getParsed(uri)];
                    case 1:
                        response = _a.sent();
                        return [2 /*return*/, response.datasets.items];
                }
            });
        });
    };
    CatalogueModule.prototype.requestDateDataSets = function (projectId, dateDataSetsRequest) {
        var uri = "/gdc/internal/projects/" + projectId + "/loadDateDataSets";
        return this.xhr
            .postParsed(uri, { data: { dateDataSetsRequest: dateDataSetsRequest } })
            .then(function (data) { return data.dateDataSetsResponse; });
    };
    CatalogueModule.prototype.loadCatalog = function (projectId, catalogRequest) {
        var uri = "/gdc/internal/projects/" + projectId + "/loadCatalog";
        return this.xhr
            .post(uri, { data: { catalogRequest: catalogRequest } })
            .then(function (r) { return r.getData(); })
            .then(function (data) { return data.catalogResponse; });
    };
    return CatalogueModule;
}());
export { CatalogueModule };
//# sourceMappingURL=catalogue.js.map