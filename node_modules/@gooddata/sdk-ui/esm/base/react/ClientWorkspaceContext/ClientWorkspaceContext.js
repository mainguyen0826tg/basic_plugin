// (C) 2019 GoodData Corporation
import React from "react";
import { useBackendStrict } from "../BackendContext";
import { useCancelablePromise, } from "../useCancelablePromise";
import isEmpty from "lodash/isEmpty";
import { resolveLCMWorkspaceIdentifiers } from "./resolveLCMWorkspaceIdentifiers";
import { useWorkspace, WorkspaceProvider } from "../WorkspaceContext";
import invariant from "ts-invariant";
var ClientWorkspaceContext = React.createContext({
    status: "pending",
    error: undefined,
    result: undefined,
});
ClientWorkspaceContext.displayName = "ClientWorkspace";
/**
 * ClientWorkspaceProvider can be used as a replacement of the {@link WorkspaceProvider},
 * if you want to work with the workspace in LCM context.
 *
 * It allows you to:
 * - Use dataProduct and client identifier as a replacement of the workspace identifier.
 *   Workspace identifier is resolved and provided to the {@link WorkspaceProvider} automatically.
 *
 * - Use workspace identifier to obtain dataProduct, client and segment identifiers by the {@link useClientWorkspaceIdentifiers} hooks.
 *
 * If the backend does not support clientId / dataProduct LCM provisioning,
 * or the workspace is not provisioned via LCM, segment / client / dataProduct values will be undefined.
 *
 * To read more details about LCM, see: {@link https://help.gooddata.com/pages/viewpage.action?pageId=86796865}
 *
 * @alpha
 */
export var ClientWorkspaceProvider = function (props) {
    var _a;
    var children = props.children, customBackend = props.backend;
    var _b = getInputLCMIdentifiersFromProps(props), client = _b.client, dataProduct = _b.dataProduct, customWorkspace = _b.workspace;
    var backend = useBackendStrict(customBackend, "ClientWorkspaceProvider");
    var workspace = useWorkspace(customWorkspace);
    var lcmIdentifiers = useCancelablePromise({
        promise: function () { return resolveLCMWorkspaceIdentifiers(backend, { client: client, dataProduct: dataProduct, workspace: workspace }); },
    }, [client, dataProduct, workspace, backend]);
    var ws = (_a = lcmIdentifiers.result) === null || _a === void 0 ? void 0 : _a.workspace;
    return (React.createElement(ClientWorkspaceContext.Provider, { value: lcmIdentifiers },
        React.createElement(WorkspaceProvider, { workspace: ws }, children)));
};
/**
 * ResolvedClientWorkspaceProvider can be used as a replacement of the {@link WorkspaceProvider}, if you are accessing
 * workspace in LCM context.
 *
 * This provider expects that the client workspace is already resolved on input to the provider. The provider
 * will then establish a client workspace and workspace contexts so that the resolved information can
 * be accessed by the children.
 *
 * Note: check out the {@link ClientWorkspaceProvider} for version of provider that performs the resolution of
 * client workspace identifiers to workspace.
 *
 * @alpha
 */
export var ResolvedClientWorkspaceProvider = function (props) {
    invariant(props.dataProduct);
    invariant(props.client);
    invariant(props.workspace);
    var context = {
        status: "success",
        result: props,
        error: undefined,
    };
    return (React.createElement(ClientWorkspaceContext.Provider, { value: context },
        React.createElement(WorkspaceProvider, { workspace: props.workspace }, props.children)));
};
/**
 * Hook to obtain loading status of the {@link ClientWorkspaceProvider} - "success", "error", "loading" or "pending".
 * @alpha
 */
export var useClientWorkspaceStatus = function () {
    var context = React.useContext(ClientWorkspaceContext);
    return context.status;
};
/**
 * Hook to obtain loading error of the {@link ClientWorkspaceProvider}.
 * @alpha
 */
export var useClientWorkspaceError = function () {
    var context = React.useContext(ClientWorkspaceContext);
    return context.error;
};
/**
 * Hook to obtain all resolved identifiers from the {@link ClientWorkspaceProvider} - workspace, segment, dataProduct and client.
 * @alpha
 */
export var useClientWorkspaceIdentifiers = function () {
    var _a;
    var context = React.useContext(ClientWorkspaceContext);
    return (_a = context.result) !== null && _a !== void 0 ? _a : {};
};
//
//
//
function hasWorkspaceProp(obj) {
    return !isEmpty(obj) && !!obj.workspace;
}
function getInputLCMIdentifiersFromProps(props) {
    if (hasWorkspaceProp(props)) {
        return {
            workspace: props.workspace,
        };
    }
    invariant(props.client && props.dataProduct, "ClientWorkspaceProvider: You must specify either - the workspace identifier, or the client and dataProduct identifier.");
    return {
        client: props.client,
        dataProduct: props.dataProduct,
    };
}
//# sourceMappingURL=ClientWorkspaceContext.js.map