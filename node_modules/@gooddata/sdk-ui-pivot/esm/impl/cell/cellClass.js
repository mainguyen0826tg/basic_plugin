import isEmpty from "lodash/isEmpty";
import cx from "classnames";
import { invariant } from "ts-invariant";
import { isSeriesCol, isRootCol } from "../structure/tableDescriptorTypes";
import { convertDrillableItemsToPredicates } from "@gooddata/sdk-ui";
import { ROW_SUBTOTAL, ROW_TOTAL, MEASURE_COLUMN } from "../base/constants";
import { isCellDrillable } from "../drilling/cellDrillabilityPredicate";
import last from "lodash/last";
import { getCellClassNames } from "./cellUtils";
export function cellClassFactory(table, props, classList) {
    return function (cellClassParams) {
        var rowIndex = cellClassParams.rowIndex, data = cellClassParams.data;
        var row = data;
        var isEmptyCell = !cellClassParams.value;
        // hide empty sticky cells
        var isTopPinned = cellClassParams.node.rowPinned === "top";
        if (isEmpty(row)) {
            // ag-grid calls getCellClass before the data is available & rows are created - there will be no
            // data in the cellClassParams. not sure what is the purpose or whether that is a bug. anyway it
            // does not make sense to proceed further.
            //
            // ag-grid may call this with either data undefined or data being empty object
            // empty row data are also possible for pinned row, when no cell should be visible
            return cx(classList, isTopPinned && isEmptyCell ? "gd-hidden-sticky-column" : null);
        }
        var dv = table.getDrillDataContext();
        var colDef = cellClassParams.colDef;
        var col = table.tableDescriptor.getCol(colDef);
        invariant(!isRootCol(col));
        var drillablePredicates = convertDrillableItemsToPredicates(props.drillableItems);
        var isRowTotal = row.type === ROW_TOTAL;
        var isRowSubtotal = row.type === ROW_SUBTOTAL;
        var hasDrillableHeader = false;
        var cellAllowsDrill = !isEmptyCell || colDef.type === MEASURE_COLUMN;
        if (!isRowTotal && !isRowSubtotal && cellAllowsDrill) {
            hasDrillableHeader = isCellDrillable(col, row, dv, drillablePredicates);
        }
        var colIndex = table.tableDescriptor.getAbsoluteLeafColIndex(col);
        var measureIndex = isSeriesCol(col) ? last(col.fullIndexPathToHere) : undefined;
        var isPinnedRow = cellClassParams.node.isRowPinned();
        var hiddenCell = !isPinnedRow && table.getGroupingProvider().isRepeatedValue(col.id, rowIndex);
        var rowSeparator = !hiddenCell && table.getGroupingProvider().isGroupBoundary(rowIndex);
        var subtotalStyle = row === null || row === void 0 ? void 0 : row.subtotalStyle;
        return cx(classList, measureIndex !== undefined ? "gd-column-measure-" + measureIndex : null, getCellClassNames(rowIndex, colIndex, hasDrillableHeader), "gd-column-index-" + colIndex, isRowTotal ? "gd-row-total" : null, subtotalStyle ? "gd-table-row-subtotal gd-table-row-subtotal-" + subtotalStyle : null, hiddenCell ? "gd-cell-hide s-gd-cell-hide" : null, rowSeparator ? "gd-table-row-separator s-gd-table-row-separator" : null, isTopPinned && isEmptyCell ? "gd-hidden-sticky-column" : null);
    };
}
//# sourceMappingURL=cellClass.js.map