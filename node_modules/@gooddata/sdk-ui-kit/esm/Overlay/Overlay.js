import { __extends, __read, __spread } from "tslib";
// (C) 2020 GoodData Corporation
import React, { createRef } from "react";
import cx from "classnames";
import { Portal } from "react-portal";
import bindAll from "lodash/bindAll";
import pick from "lodash/pick";
import isEqual from "lodash/isEqual";
import findIndex from "lodash/findIndex";
import debounce from "lodash/debounce";
import noop from "lodash/noop";
import "element-closest-polyfill";
import { DEFAULT_ALIGN_POINTS, getOptimalAlignment } from "../utils/overlay";
import { elementRegion, isFixedPosition } from "../utils/domUtilities";
import { ENUM_KEY_CODE } from "../typings/utilities";
var events = [
    { name: "click", handler: "closeOnOutsideClick", target: document },
    {
        name: "mousedown",
        handler: "onDocumentMouseDown",
        target: document,
        requiredProp: "closeOnOutsideClick",
    },
    { name: "goodstrap.scrolled", handler: "closeOnParentScroll" },
    { name: "goodstrap.drag", handler: "closeOnMouseDrag" },
    { name: "keydown", handler: "closeOnEscape" },
];
var eventProps = events.map(function (event) { return event.handler; });
var ALIGN_TIMEOUT_MS = 10;
var INIT_STATE_ALIGN = -500;
export var POSITION_SAME_AS_TARGET = "sameAsTarget";
function exceedsThreshold(firstNumber, secondNumber) {
    return Math.abs(firstNumber - secondNumber) > 2;
}
function alignExceedsThreshold(firstAlignment, secondAlignment) {
    return (exceedsThreshold(firstAlignment.top, secondAlignment.top) ||
        exceedsThreshold(firstAlignment.left, secondAlignment.left) ||
        exceedsThreshold(firstAlignment.right, secondAlignment.right));
}
var stopPropagation = function (e) { return e.stopPropagation(); };
/**
 * @internal
 */
var Overlay = /** @class */ (function (_super) {
    __extends(Overlay, _super);
    function Overlay(props) {
        var _this = _super.call(this, props) || this;
        _this.overlayRef = createRef();
        _this.containerRef = createRef();
        _this.resizeHandler = debounce(function () { return _this.align(); }, 100);
        _this.portalNode = null;
        _this.align = function () {
            var _a = _this.props, alignPoints = _a.alignPoints, alignTo = _a.alignTo, positionType = _a.positionType;
            var overlay = _this.overlayRef.current;
            if (!alignPoints || !overlay) {
                return;
            }
            var isSameAsTarget = _this.isSameAsTargetPosition(positionType);
            var optimalAlign = getOptimalAlignment({
                targetRegion: elementRegion(alignTo, isSameAsTarget),
                selfRegion: elementRegion(overlay),
                alignPoints: alignPoints,
                ignoreScrollOffsets: isSameAsTarget,
            });
            if (alignExceedsThreshold(_this.state.alignment, optimalAlign.alignment)) {
                _this.setState({
                    alignment: optimalAlign.alignment,
                }, function () {
                    _this.props.onAlign(optimalAlign.alignment);
                });
            }
            else {
                _this.props.onAlign(optimalAlign.alignment);
            }
        };
        _this.onMaskClick = function (e) {
            if (!_this.props.closeOnOutsideClick) {
                e.stopPropagation();
            }
        };
        _this.getOverlayStyles = function () {
            var _a = _this.props, alignTo = _a.alignTo, positionType = _a.positionType, zIndex = _a.zIndex;
            var alignment = _this.state.alignment;
            var position = _this.isSameAsTargetPosition(positionType)
                ? isFixedPosition(alignTo)
                    ? "fixed"
                    : "absolute"
                : positionType;
            return {
                position: position,
                left: alignment.left,
                top: alignment.top,
                zIndex: zIndex,
                visibility: _this.isAligned() ? undefined : "hidden",
            };
        };
        _this.getOverlayClasses = function () {
            return cx(_this.props.className, _this.getAlignClasses(), {
                "overlay-wrapper": true,
            });
        };
        /**
         * Add CSS classes to overlay wrapper, so they can be used
         * for position of arrows and stuff
         */
        _this.getAlignClasses = function () {
            var align = _this.state.alignment.align.split(" ");
            return "target-" + align[0] + " self-" + align[1];
        };
        _this.isSameAsTargetPosition = function (positionType) {
            return positionType === POSITION_SAME_AS_TARGET;
        };
        _this.isEventOnParent = function (event) {
            var node = _this.containerRef.current;
            var eventNode = (event.detail && event.detail.node) || event.target;
            return eventNode.contains(node);
        };
        _this.shouldCloseOnClick = function (e) {
            if (!_this.isComponentMounted) {
                return false;
            }
            if (!_this.isAligned()) {
                return false;
            }
            // an ignored node has been clicked, always keep the overlay open
            if (_this.hasClickedOnIgnoredNode(e)) {
                return false;
            }
            // non-ignored node clicked, give shouldCloseOnClick the chance
            // to override closing the dialog
            return _this.props.shouldCloseOnClick(e);
        };
        _this.hasClickedOnIgnoredNode = function (e) {
            if (e.defaultPrevented) {
                // Ignore event if it should be prevented (e.q. by click in child component)
                return true;
            }
            var clickedElement = e.target;
            if (_this.isElementInChildOverlay(clickedElement) || _this.clickedInside) {
                return true;
            }
            var ignoredRefElements = __spread([_this.overlayRef.current], _this.props.ignoreClicksOn);
            var clickInsideIgnoredRefElement = ignoredRefElements.some(function (ref) {
                return ref && ref.contains(clickedElement);
            });
            if (clickInsideIgnoredRefElement) {
                return true;
            }
            return _this.props.ignoreClicksOnByClass.some(function (selector) { return clickedElement.closest(selector); });
        };
        _this.isAligned = function () {
            return _this.state.alignment.left !== INIT_STATE_ALIGN && _this.state.alignment.top != INIT_STATE_ALIGN;
        };
        // makes assumption that overlays later in the DOM are child overlays
        _this.isElementInChildOverlay = function (element) {
            var overlays = Array.from(document.querySelectorAll(".overlay-wrapper"));
            var thisOverlayIndex = findIndex(overlays, function (overlay) { return overlay === _this.overlayRef.current; });
            return overlays.slice(thisOverlayIndex + 1).some(function (overlay) { return overlay.contains(element); });
        };
        _this.closeOnMouseDrag = function () {
            if (!_this.isComponentMounted) {
                return;
            }
            _this.props.onClose();
        };
        _this.updateListeners = function (method, props) {
            events.forEach(function (event) {
                if (props[event.handler] || props[event.requiredProp]) {
                    var handler = _this[event.handler];
                    if (handler) {
                        (event.target || window)[method + "EventListener"](event.name, handler);
                    }
                }
            });
        };
        _this.addListeners = function (props) {
            _this.updateListeners("add", props);
        };
        _this.removeListeners = function (props) {
            _this.updateListeners("remove", props);
        };
        _this.renderMask = function () {
            return _this.props.isModal ? (React.createElement("div", { className: "modalityPlugin-mask modalityPlugin-mask-visible", onClick: _this.onMaskClick })) : (false);
        };
        _this.state = {
            alignment: {
                align: props.alignPoints[0].align,
                left: INIT_STATE_ALIGN,
                top: INIT_STATE_ALIGN,
                right: 0,
            },
        };
        _this.isComponentMounted = false;
        _this.clickedInside = false;
        bindAll(_this, events.map(function (event) { return event.handler; }));
        _this.createPortalNode();
        return _this;
    }
    Overlay.prototype.componentDidMount = function () {
        var _this = this;
        this.isComponentMounted = true;
        window.addEventListener("resize", this.resizeHandler);
        this.addListeners(this.props);
        setTimeout(function () {
            _this.align();
        }, ALIGN_TIMEOUT_MS);
    };
    Overlay.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        if (!isEqual(pick(this.props, eventProps), pick(nextProps, eventProps))) {
            this.removeListeners(this.props);
            this.addListeners(nextProps);
        }
    };
    Overlay.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var propsChanged = !isEqual(this.props, nextProps);
        var positionChanged = !isEqual(this.state.alignment, nextState.alignment);
        return propsChanged || positionChanged;
    };
    Overlay.prototype.componentDidUpdate = function () {
        var _this = this;
        setTimeout(function () {
            _this.align();
        }, ALIGN_TIMEOUT_MS);
    };
    Overlay.prototype.componentWillUnmount = function () {
        this.isComponentMounted = false;
        window.removeEventListener("resize", this.resizeHandler);
        this.removeListeners(this.props);
        this.removePortalNodeAfterAllTreeUnmount();
    };
    Overlay.prototype.render = function () {
        // Need stop propagation of events from Portal thats new behavior of react 16
        // https://github.com/facebook/react/issues/11387
        return (React.createElement("span", { className: "s-portal-scroll-anchor", ref: this.containerRef },
            React.createElement(Portal, { node: this.portalNode },
                React.createElement("div", { className: this.props.containerClassName, onClick: this.props.onClick, onMouseOver: this.props.onMouseOver, onMouseUp: this.props.onMouseUp },
                    this.renderMask(),
                    React.createElement("div", { ref: this.overlayRef, style: this.getOverlayStyles(), className: this.getOverlayClasses() }, this.props.children)))));
    };
    Overlay.prototype.createPortalNode = function () {
        this.portalNode = document.createElement("div");
        document.body.appendChild(this.portalNode);
    };
    Overlay.prototype.removePortalNodeAfterAllTreeUnmount = function () {
        var _this = this;
        setTimeout(function () {
            if (_this.portalNode && document.body.contains(_this.portalNode)) {
                document.body.removeChild(_this.portalNode);
            }
            _this.portalNode = null;
        });
    };
    Overlay.prototype.onDocumentMouseDown = function (e) {
        this.clickedInside = this.overlayRef.current.contains(e.target);
        if (this.clickedInside) {
            e.stopPropagation();
        }
    };
    Overlay.prototype.closeOnParentScroll = function (e) {
        if (!this.isComponentMounted) {
            return;
        }
        if (this.isEventOnParent(e)) {
            this.props.onClose();
        }
    };
    Overlay.prototype.closeOnOutsideClick = function (e) {
        if (this.shouldCloseOnClick(e)) {
            this.props.onClose();
        }
    };
    Overlay.prototype.closeOnEscape = function (e) {
        if (this.isComponentMounted &&
            this.props.closeOnEscape &&
            e.keyCode === ENUM_KEY_CODE.KEY_CODE_ESCAPE) {
            this.props.onClose();
        }
    };
    Overlay.defaultProps = {
        alignPoints: DEFAULT_ALIGN_POINTS,
        alignTo: "body",
        children: false,
        className: "",
        containerClassName: "",
        positionType: "absolute",
        ignoreClicksOn: [],
        ignoreClicksOnByClass: [],
        shouldCloseOnClick: function () { return true; },
        onClick: stopPropagation,
        onMouseOver: stopPropagation,
        onMouseUp: stopPropagation,
        onAlign: noop,
        onClose: noop,
    };
    return Overlay;
}(React.Component));
export { Overlay };
//# sourceMappingURL=Overlay.js.map