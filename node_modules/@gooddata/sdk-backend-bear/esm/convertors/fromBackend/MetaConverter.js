// (C) 2019-2021 GoodData Corporation
import { GdcMetadata } from "@gooddata/api-model-bear";
import { uriRef } from "@gooddata/sdk-model";
import { UnexpectedError } from "@gooddata/sdk-backend-spi";
import { newAttributeDisplayFormMetadataObject, newAttributeMetadataObject, newDataSetMetadataObject, newFactMetadataObject, newMeasureMetadataObject, newVariableMetadataObject, } from "@gooddata/sdk-backend-base";
var supportedMetadataObjectsTypeGuards = [
    GdcMetadata.isAttribute,
    GdcMetadata.isAttributeDisplayForm,
    GdcMetadata.isMetric,
    GdcMetadata.isFact,
    GdcMetadata.isDataSet,
    GdcMetadata.isPrompt,
    GdcMetadata.isTheme,
];
var isSupportedMetadataObject = function (obj) {
    return supportedMetadataObjectsTypeGuards.some(function (isType) { return isType(obj); });
};
export var convertMetadataObject = function (obj) {
    if (!isSupportedMetadataObject(obj)) {
        throw new UnexpectedError("Cannot convert metadata object, convertor not found! (" + JSON.stringify(obj, null, 4) + ")");
    }
    var ref = uriRef(obj.meta.uri);
    var commonModifications = function (builder) {
        return builder
            .title(obj.meta.title)
            .description(obj.meta.summary)
            .id(obj.meta.identifier)
            .production(obj.meta.isProduction === 1)
            .uri(obj.meta.uri);
    };
    if (GdcMetadata.isAttribute(obj)) {
        var attributeDisplayForms_1 = obj.content.displayForms.map(function (displayForm) {
            return newAttributeDisplayFormMetadataObject(uriRef(displayForm.meta.uri), function (df) {
                return df
                    .attribute(ref)
                    .title(displayForm.meta.title)
                    .description(displayForm.meta.summary)
                    .id(displayForm.meta.identifier)
                    .uri(displayForm.meta.uri)
                    .displayFormType(displayForm.content.type);
            });
        });
        return newAttributeMetadataObject(ref, function (a) {
            return a.modify(commonModifications).displayForms(attributeDisplayForms_1);
        });
    }
    else if (GdcMetadata.isAttributeDisplayForm(obj)) {
        return newAttributeDisplayFormMetadataObject(ref, function (a) {
            return a
                .modify(commonModifications)
                .attribute(uriRef(obj.content.formOf))
                .displayFormType(obj.content.type);
        });
    }
    else if (GdcMetadata.isMetric(obj)) {
        return newMeasureMetadataObject(ref, function (m) {
            return m
                .modify(commonModifications)
                .expression(obj.content.expression)
                .format(obj.content.format || "##,#");
        });
    }
    else if (GdcMetadata.isFact(obj)) {
        return newFactMetadataObject(ref, function (f) { return f.modify(commonModifications); });
    }
    else if (GdcMetadata.isDataSet(obj)) {
        return newDataSetMetadataObject(ref, function (ds) { return ds.modify(commonModifications); });
    }
    else {
        // is prompt
        return newVariableMetadataObject(ref, function (v) { return v.modify(commonModifications); });
    }
};
/**
 * Converts xref entry (result of using/usedBy) into IMetadataObject. There's one gotcha: the production indicator
 * is not available in xref entry. Instead of calling out to the backend, this function will hammer in 'true' - which
 * will be right guess in vast majority of cases (hunt me down when this starts causing bugs :)).
 *
 * @param type - specify object type of the xref entry (code ignores the xref category)
 * @param entry - xref entry
 */
export var convertMetadataObjectXrefEntry = function (type, entry) {
    var ref = uriRef(entry.link);
    return {
        type: type,
        uri: entry.link,
        id: entry.identifier,
        ref: ref,
        title: entry.title,
        description: entry.summary,
        production: true,
        unlisted: entry.unlisted === 1,
        deprecated: entry.deprecated === "1",
    };
};
//# sourceMappingURL=MetaConverter.js.map