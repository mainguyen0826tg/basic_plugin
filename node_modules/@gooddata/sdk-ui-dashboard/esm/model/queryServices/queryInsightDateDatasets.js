import { __generator, __read, __spread } from "tslib";
import { call, select } from "redux-saga/effects";
import compact from "lodash/compact";
import fromPairs from "lodash/fromPairs";
import uniqBy from "lodash/uniqBy";
import { invariant } from "ts-invariant";
import { filterObjRef, insightFilters, insightRef, isDateFilter, isObjRef, objRefToString, serializeObjRef, } from "@gooddata/sdk-model";
import { isCatalogDateDataset } from "@gooddata/sdk-backend-spi";
import { createCachedQueryService } from "../store/_infra/queryService";
import { queryInsightAttributesMeta, } from "../queries";
import { selectInsightByRef } from "../store/insights/insightsSelectors";
import { invalidQueryArguments } from "../events/general";
import { query } from "../store/_infra/queryCall";
import { selectAllCatalogDateDatasetsMap, selectCatalogDateAttributeToDataset, } from "../store/catalog/catalogSelectors";
import { selectBackendCapabilities } from "../store/backendCapabilities/backendCapabilitiesSelectors";
import { newDisplayFormMap } from "../../_staging/metadata/objRefMap";
import { sanitizeDateDatasetTitle, sortByRelevanceAndTitle, } from "../../_staging/catalog/dateDatasetOrdering";
import { loadDateDatasetsForInsight } from "./loadAvailableDateDatasets";
export var QueryDateDatasetsForInsightService = createCachedQueryService("GDC.DASH/QUERY.INSIGHT.DATE.DATASETS", queryService, function (query) {
    var insightOrRef = query.payload.insightOrRef;
    var ref = isObjRef(insightOrRef) ? insightOrRef : insightRef(insightOrRef);
    return serializeObjRef(ref);
});
/**
 * Selector that will return date datasets for insight. The input to the selector is the dashboard query that is used
 * to obtain and cache the data.
 *
 * This selector will return undefined if the query to obtain the data for particular insight was not yet fired or
 * processed. Otherwise will return object containing `status` of the data retrieval; if the `status` is
 * `'success'` then the `result` prop will contain the data.
 *
 * @remarks see {@link QueryInsightDateDatasets}
 * @internal
 */
export var selectDateDatasetsForInsight = QueryDateDatasetsForInsightService.cache.selectQueryResult;
//
// Query implementation
//
/**
 * Given insight and a list of available cataloged date datasets, this function looks up date datasets that are used
 * in insight's global date filters. Date datasets
 *
 * @param insight - insight to lookup date dataset for
 * @param datasets - all cataloged date datasets
 */
function lookupDatasetsUsedInDateFilters(insight, datasets) {
    var dateFilters = insightFilters(insight).filter(isDateFilter);
    return dateFilters.map(function (filter) {
        var datasetRef = filterObjRef(filter);
        var dateDataset = datasets.get(datasetRef);
        // if this happens then either component is using wrong catalog or metadata is inconsistent (and insight thus un-renderable)
        invariant(dateDataset, "cannot find metadata for date dataset " + objRefToString(datasetRef));
        return dateDataset;
    });
}
/**
 * Given insight and list of available cataloged date datasets, this generator will first query usage & metadata about
 * used display forms and attributes. With this, the function will lookup date datasets for each display form
 * used in insight's attribute buckets and attribute filters.
 *
 * Note: that cataloged date datasets already contain mapping of dataset -> attribute -> default display form. However
 * this cannot be used because the code cannot expect that the insights only use date dataset's default display forms.
 *
 * @param insight - insight work with
 * @param attributeToDataset - lookup table of date attributes to datasets
 */
function lookupDatasetsUsedInAttributesAndFilters(insight, attributeToDataset) {
    var insightAttributes, _a, inAttributes, inFilters, displayForms, capabilities, displayFormsMap, datasetLookup;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, call(query, queryInsightAttributesMeta(insight))];
            case 1:
                insightAttributes = _b.sent();
                _a = insightAttributes.usage, inAttributes = _a.inAttributes, inFilters = _a.inFilters, displayForms = insightAttributes.displayForms;
                return [4 /*yield*/, select(selectBackendCapabilities)];
            case 2:
                capabilities = _b.sent();
                displayFormsMap = newDisplayFormMap(displayForms, capabilities.hasTypeScopedIdentifiers);
                datasetLookup = function (ref) {
                    var _a;
                    var displayForm = displayFormsMap.get(ref);
                    // if this bombs then the query insight attributes is messed up as it does not include display forms meta
                    // for some display form used in the insight
                    invariant(displayForm);
                    var attributeRef = displayForm.attribute;
                    return (_a = attributeToDataset.get(attributeRef)) === null || _a === void 0 ? void 0 : _a.dataset;
                };
                return [2 /*return*/, {
                        usedInAttributes: compact(inAttributes.map(datasetLookup)),
                        usedInAttributeFilters: compact(inFilters.map(datasetLookup)),
                    }];
        }
    });
}
function lookupDatasetsInInsight(insight) {
    var catalogDateDatasets, catalogDateAttributeToDatasets, usedInDateFilters, usedInAttributesAndFilters, usedInAttributes, usedInAttributeFilters;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, select(selectAllCatalogDateDatasetsMap)];
            case 1:
                catalogDateDatasets = _a.sent();
                return [4 /*yield*/, select(selectCatalogDateAttributeToDataset)];
            case 2:
                catalogDateAttributeToDatasets = _a.sent();
                usedInDateFilters = lookupDatasetsUsedInDateFilters(insight, catalogDateDatasets);
                return [4 /*yield*/, call(lookupDatasetsUsedInAttributesAndFilters, insight, catalogDateAttributeToDatasets)];
            case 3:
                usedInAttributesAndFilters = _a.sent();
                usedInAttributes = usedInAttributesAndFilters.usedInAttributes, usedInAttributeFilters = usedInAttributesAndFilters.usedInAttributeFilters;
                return [2 /*return*/, {
                        usedInDateFilters: usedInDateFilters,
                        usedInAttributes: usedInAttributes,
                        usedInAttributeFilters: usedInAttributeFilters,
                    }];
        }
    });
}
function queryService(ctx, query) {
    var insightOrRef, correlationId, insight, dateDatasets, usedInInsight, usedInDateFilters, usedInAttributes, usedInAttributeFilters, mostImportantFromInsight, allAvailableDateDatasets, dateDatasetDisplayNames;
    var _a, _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                insightOrRef = query.payload.insightOrRef, correlationId = query.correlationId;
                if (!isObjRef(insightOrRef)) return [3 /*break*/, 2];
                return [4 /*yield*/, select(selectInsightByRef(insightOrRef))];
            case 1:
                insight = _c.sent();
                if (!insight) {
                    throw invalidQueryArguments(ctx, "Insight with ref " + objRefToString(insightOrRef) + " does not exist on the dashboard", correlationId);
                }
                return [3 /*break*/, 3];
            case 2:
                insight = insightOrRef;
                _c.label = 3;
            case 3: return [4 /*yield*/, call(loadDateDatasetsForInsight, ctx, insight)];
            case 4:
                dateDatasets = _c.sent();
                return [4 /*yield*/, call(lookupDatasetsInInsight, insight)];
            case 5:
                usedInInsight = _c.sent();
                usedInDateFilters = usedInInsight.usedInDateFilters, usedInAttributes = usedInInsight.usedInAttributes, usedInAttributeFilters = usedInInsight.usedInAttributeFilters;
                mostImportantFromInsight = (_b = (_a = usedInDateFilters[0]) !== null && _a !== void 0 ? _a : usedInAttributes[0]) !== null && _b !== void 0 ? _b : usedInAttributeFilters[0];
                allAvailableDateDatasets = uniqBy(__spread(dateDatasets, usedInDateFilters, usedInAttributes, usedInAttributeFilters).filter(isCatalogDateDataset), function (d) { return serializeObjRef(d.dataSet.ref); });
                dateDatasetDisplayNames = fromPairs(allAvailableDateDatasets.map(function (d) { return [d.dataSet.title, sanitizeDateDatasetTitle(d)]; }));
                return [2 /*return*/, {
                        dateDatasets: dateDatasets,
                        dateDatasetsOrdered: sortByRelevanceAndTitle(dateDatasets, dateDatasetDisplayNames),
                        usedInDateFilters: usedInDateFilters,
                        usedInAttributes: usedInAttributes,
                        usedInAttributeFilters: usedInAttributeFilters,
                        dateDatasetDisplayNames: dateDatasetDisplayNames,
                        mostImportantFromInsight: mostImportantFromInsight,
                        allAvailableDateDatasets: allAvailableDateDatasets,
                    }];
        }
    });
}
//# sourceMappingURL=queryInsightDateDatasets.js.map