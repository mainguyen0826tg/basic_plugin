import { __read } from "tslib";
// (C) 2021 GoodData Corporation
import produce, { applyPatches, enablePatches, original, produceWithPatches } from "immer";
import { invariant } from "ts-invariant";
import flatMap from "lodash/flatMap";
/*
 * Undo relies on immer's patching functionality. It has to be turned on explicitly.
 */
enablePatches();
/**
 * Initial value of the undo state.
 */
export var InitialUndoState = {
    _undo: {
        undoPointer: -1,
        undoStack: [],
    },
};
/**
 * Decorates a reducer with capability to construct undo and redo patches for the state modification done by the underlying reducer.
 *
 * The essential undo metadata will be stored next to the modified state in the `undo` section.
 *
 * @param originalReducer - reducer to decorate
 */
export var withUndo = function (originalReducer) {
    var undoable = function (state, action) {
        var undo = action.payload.undo;
        var originalState = original(state);
        var _a = __read(produceWithPatches(originalState, function (draft) {
            originalReducer(draft, action);
        }), 3), nextState = _a[0], redoPatches = _a[1], undoPatches = _a[2];
        return produce(nextState, function (draft) {
            draft._undo.undoPointer++;
            draft._undo.undoStack.push({
                /*
                 * TODO: Getting this error, struggling to type things correctly
                 *
                 * Type 'IDashboardCommand' is not assignable to type 'Draft<Immutable<TCmd>>'
                 */
                cmd: undo.cmd,
                redoPatches: redoPatches,
                undoPatches: undoPatches,
            });
        });
    };
    /*
     * TODO: Getting this error, struggling to type things correctly so the shortcut.
     *
     * 'WritableDraft<UndoEnhancedState>' is assignable to the constraint of type 'TState', but 'TState' could be
     * instantiated with a different subtype of constraint 'UndoEnhancedState'.
     */
    return undoable;
};
/**
 * A generic undo reducer that works with any UndoEnhancedState and the undo stack stored within. When triggered,
 * it will roll the state back to particular point in history.
 *
 * Note that this reducer is not concerned by the transaction boundaries of command processing. It is responsibility
 * of the caller to create an undo action that
 *
 * @param state
 * @param action
 */
export var undoReducer = function (state, action) {
    var undoDownTo = action.payload.undoDownTo;
    var originalState = original(state);
    var _undo = originalState._undo;
    // if this happens then the issuer has incorrectly calculated point to which to rollback.
    invariant(undoDownTo <= _undo.undoStack.length, "invalid undo point " + undoDownTo + " while the undo stack has " + _undo.undoStack.length + " item(s)");
    /*
     * Get entries to apply, they are on the stack from oldest to the newest. The undo 'unwinds' from the newest up to the
     * 'undoDownTo' index. Slice everything from that index to the end of stack, then reverse to get the right order.
     */
    var entriesToUndo = _undo.undoStack.slice(undoDownTo);
    entriesToUndo.reverse();
    /*
     * Concat all the undo patches from all undo stack entries. Since the entries are ordered from the newest to the
     * oldest order, this naturally translates to ordering of the patches.
     */
    var allPatches = flatMap(entriesToUndo, function (entry) { return entry.undoPatches; });
    /*
     * Apply patches to restore the state.
     */
    var restoredState = applyPatches(originalState, allPatches);
    return produce(restoredState, function (draft) {
        draft._undo.undoPointer = undoDownTo - 1;
        // see: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/length#shortening_an_array
        draft._undo.undoStack.length = undoDownTo;
    });
};
/**
 * A reducer to reset the undo state. This will clear the undo stack (the 'history').
 *
 * @param state - undo enhanced state whose undo to reset
 */
export var resetUndoReducer = function (state) {
    state._undo = InitialUndoState._undo;
};
/**
 * Given the undo information stored in state, this function produces an array of commands that can be un-done. The commands
 * are ordered from the newest (0 index) to the oldest.
 *
 * For each command, the function includes pointer to the undo stack up-to which the undo should be done in order
 * to roll back the command's effects.
 */
export function createUndoableCommandsMapping(state) {
    var result = [];
    var lastCmdUuid = "";
    var seenCmdUuids = new Set();
    state._undo.undoStack.forEach(function (entry, idx) {
        var cmd = entry.cmd, _a = entry.cmd.meta, uuid = (_a === void 0 ? {} : _a).uuid;
        // if this bombs then the command stamping middleware does not do its job properly
        invariant(uuid);
        if (lastCmdUuid !== uuid) {
            // if this bombs then things are getting serious as it means command handlers execute in a way that
            // the reducer actions from two commands interleave which leads to undo stack containing 'zipped'
            // entries (entry for cmd A, entry from cmd B, entry from cmd A). Undo will lead to undesired
            // results.
            invariant(!seenCmdUuids.has(uuid), "jackpot winner ðŸ¥³");
            result.unshift({
                cmd: cmd,
                firstOccurrenceOnStack: idx,
            });
            lastCmdUuid = uuid;
            seenCmdUuids.add(uuid);
        }
    });
    return result;
}
//# sourceMappingURL=undoEnhancer.js.map