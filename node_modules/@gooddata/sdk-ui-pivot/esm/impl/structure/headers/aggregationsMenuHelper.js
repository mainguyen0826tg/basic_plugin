import { __spreadArrays } from "tslib";
import { AVAILABLE_TOTALS } from "../../base/constants";
import findIndex from "lodash/findIndex";
import intersection from "lodash/intersection";
import isEqual from "lodash/isEqual";
import sortBy from "lodash/sortBy";
import uniq from "lodash/uniq";
function getTotalsForMeasureAndType(totals, type, measureLocalIdentifier) {
    return totals.filter(function (total) { return total.measureIdentifier === measureLocalIdentifier && total.type === type; });
}
function getAttributeIntersection(totals, type, measureLocalIdentifiers) {
    var attributeGroups = measureLocalIdentifiers.map(function (measure) {
        var filteredTotals = getTotalsForMeasureAndType(totals, type, measure);
        return filteredTotals.map(function (total) { return total.attributeIdentifier; });
    });
    return intersection.apply(void 0, attributeGroups);
}
function getUniqueMeasures(totals, type) {
    var totalsOfType = totals.filter(function (total) { return total.type === type; });
    return uniq(totalsOfType.map(function (total) { return total.measureIdentifier; }));
}
function areMeasuresSame(measureLocalIdentifiers1, measureLocalIdentifiers2) {
    var sameMeasureLocalIdentifiers = intersection(measureLocalIdentifiers1, measureLocalIdentifiers2);
    return sameMeasureLocalIdentifiers.length === measureLocalIdentifiers2.length;
}
function getTotalsForAttributeHeader(totals, measureLocalIdentifiers) {
    return AVAILABLE_TOTALS.reduce(function (columnTotals, type) {
        var uniqueMeasureLocalIdentifiers = getUniqueMeasures(totals, type);
        if (areMeasuresSame(uniqueMeasureLocalIdentifiers, measureLocalIdentifiers)) {
            var attributeLocalIdentifiers = getAttributeIntersection(totals, type, uniqueMeasureLocalIdentifiers);
            if (attributeLocalIdentifiers.length) {
                columnTotals.push({
                    type: type,
                    attributes: attributeLocalIdentifiers,
                });
            }
        }
        return columnTotals;
    }, []);
}
function getTotalsForMeasureHeader(totals, measureLocalIdentifier) {
    return totals.reduce(function (turnedOnAttributes, total) {
        if (total.measureIdentifier === measureLocalIdentifier) {
            var totalHeaderType = turnedOnAttributes.find(function (turned) { return turned.type === total.type; });
            if (totalHeaderType === undefined) {
                turnedOnAttributes.push({
                    type: total.type,
                    attributes: [total.attributeIdentifier],
                });
            }
            else {
                totalHeaderType.attributes.push(total.attributeIdentifier);
            }
        }
        return turnedOnAttributes;
    }, []);
}
function isTotalEnabledForAttribute(attributeLocalIdentifier, totalType, columnTotals) {
    return columnTotals.some(function (total) {
        return total.type === totalType && total.attributes.includes(attributeLocalIdentifier);
    });
}
function includeTotals(columnTotals, columnTotalsChanged) {
    var columnTotalsChangedUnique = columnTotalsChanged.filter(function (totalChanged) { return !columnTotals.some(function (total) { return isEqual(total, totalChanged); }); });
    return __spreadArrays(columnTotals, columnTotalsChangedUnique);
}
function excludeTotals(columnTotals, columnTotalsChanged) {
    return columnTotals.filter(function (total) { return !columnTotalsChanged.find(function (totalChanged) { return isEqual(totalChanged, total); }); });
}
export function getUpdatedColumnTotals(columnTotals, menuAggregationClickConfig) {
    var type = menuAggregationClickConfig.type, measureIdentifiers = menuAggregationClickConfig.measureIdentifiers, attributeIdentifier = menuAggregationClickConfig.attributeIdentifier, include = menuAggregationClickConfig.include;
    var columnTotalsChanged = measureIdentifiers.map(function (measureIdentifier) { return ({
        type: type,
        measureIdentifier: measureIdentifier,
        attributeIdentifier: attributeIdentifier,
    }); });
    var updatedColumnTotals = include
        ? includeTotals(columnTotals, columnTotalsChanged)
        : excludeTotals(columnTotals, columnTotalsChanged);
    return sortBy(updatedColumnTotals, function (total) {
        return findIndex(AVAILABLE_TOTALS, function (rankedItem) { return rankedItem === total.type; });
    });
}
export default {
    getTotalsForAttributeHeader: getTotalsForAttributeHeader,
    getTotalsForMeasureHeader: getTotalsForMeasureHeader,
    isTotalEnabledForAttribute: isTotalEnabledForAttribute,
    getUpdatedColumnTotals: getUpdatedColumnTotals,
};
//# sourceMappingURL=aggregationsMenuHelper.js.map