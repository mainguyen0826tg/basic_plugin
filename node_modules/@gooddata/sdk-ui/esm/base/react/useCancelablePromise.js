import { __read } from "tslib";
// (C) 2019-2021 GoodData Corporation
import { useEffect, useState } from "react";
import { makeCancelable } from "./CancelablePromise";
import noop from "lodash/noop";
import { UnexpectedSdkError } from "../errors/GoodDataSdkError";
import { safeSerialize } from "./safeSerialize";
/**
 * This hook provides easy way to work with Promise.
 * You can:
 * - watch it's status (pending/loading/success/error)
 * - get it's result/error when the Promise is resolved/rejected,
 * - attach convenient callbacks to it
 * - be sure, that when the dependency list changes, result will be still relevant (if previous Promise is still running, it's "canceled").
 *
 * @beta
 */
export function useCancelablePromise(options, deps) {
    var promise = options.promise, _a = options.onLoading, onLoading = _a === void 0 ? noop : _a, _b = options.onPending, onPending = _b === void 0 ? noop : _b, _c = options.onCancel, onCancel = _c === void 0 ? noop : _c, _d = options.onSuccess, onSuccess = _d === void 0 ? noop : _d, _e = options.onError, onError = _e === void 0 ? noop : _e;
    var getInitialState = function () { return ({
        result: undefined,
        error: undefined,
        status: promise ? "loading" : "pending",
    }); };
    var _f = __read(useState(getInitialState()), 2), state = _f[0], setState = _f[1];
    useEffect(function () {
        if (!promise) {
            if (state.status !== "pending") {
                setState({
                    status: "pending",
                    result: undefined,
                    error: undefined,
                });
            }
            onPending();
            return;
        }
        else {
            if (state.status !== "loading") {
                setState({
                    result: undefined,
                    error: undefined,
                    status: "loading",
                });
            }
            onLoading();
        }
        var cancelablePromise = makeCancelable(promise());
        cancelablePromise.promise
            .then(function (result) {
            // Because promises have their own lifecycle independent on react lifecycle,
            // we need to check if cancelable promise was not canceled before it's resolution
            // and our results are still relevant.
            if (!cancelablePromise.getHasCanceled()) {
                setState({
                    status: "success",
                    result: result,
                    error: undefined,
                });
                onSuccess(result);
            }
        })
            .catch(function (error) {
            // Because promises have their own lifecycle independent on react lifecycle,
            // we need to check if cancelable promise was not canceled before it's resolution
            // and our results are still relevant.
            if (!cancelablePromise.getHasCanceled()) {
                setState({
                    status: "error",
                    result: undefined,
                    error: error,
                });
                onError(error);
            }
        });
        return function () {
            // If promise was not fulfilled before dependencies change, cancel it.
            // Important notice - request itself is not canceled - we just don't care about unrelevant results anymore.
            if (!cancelablePromise.getHasFulfilled()) {
                cancelablePromise.cancel();
                onCancel();
            }
        };
    }, deps);
    // We want to avoid the return of the old state when some dependency has changed,
    // before another useEffect hook round starts.
    var _g = __read(useState(deps), 2), prevDeps = _g[0], setDeps = _g[1];
    if ((prevDeps === null || prevDeps === void 0 ? void 0 : prevDeps.length) !== (deps === null || deps === void 0 ? void 0 : deps.length)) {
        throw new UnexpectedSdkError("The final argument passed to useCancelablePromise changed size between renders. The order and size of this array must remain constant.\n\nPrevious: " + safeSerialize(prevDeps) + "\nIncoming: " + safeSerialize(deps));
    }
    if (deps === null || deps === void 0 ? void 0 : deps.some(function (dep, i) { return dep !== (prevDeps === null || prevDeps === void 0 ? void 0 : prevDeps[i]); })) {
        setDeps(deps);
        var currentState = getInitialState();
        setState(currentState);
        return currentState;
    }
    return state;
}
//# sourceMappingURL=useCancelablePromise.js.map