import { __extends } from "tslib";
// (C) 2007-2021 GoodData Corporation
import React, { Component } from "react";
import { FormattedMessage } from "react-intl";
import cx from "classnames";
import { isNoDataSdkError } from "@gooddata/sdk-ui";
import { Bubble, BubbleHoverTrigger } from "@gooddata/sdk-ui-kit";
import { DashboardItemKpi } from "../../../../presentationComponents";
import { isAlertingTemporarilyDisabledForGivenFilter } from "./utils/filterUtils";
// adapted from jQuery:
// https://github.com/jquery/jquery/blob/a503c691dc06c59acdafef6e54eca2613c6e4032/src/offset.js#L83-L97
function getNodeDocumentRelativeOffsetTop(node) {
    var _a;
    // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
    // Support: IE <=11+
    // Running getBoundingClientRect on a
    // disconnected node in IE throws an error
    if (!node.getClientRects().length) {
        return 0;
    }
    // Get document-relative position by adding viewport scroll to viewport-relative gBCR
    var rect = node.getBoundingClientRect();
    var win = node.ownerDocument.defaultView;
    return rect.top + ((_a = win === null || win === void 0 ? void 0 : win.pageYOffset) !== null && _a !== void 0 ? _a : 0);
}
var disabledBubbleAlignPoints = [{ align: "cr cl" }, { align: "cl cr" }];
var enabledBubbleAlignPoints = [{ align: "tc bc" }, { align: "tc br" }];
var DashboardItemWithKpiAlert = /** @class */ (function (_super) {
    __extends(DashboardItemWithKpiAlert, _super);
    function DashboardItemWithKpiAlert() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.timeouts = {};
        _this.isScrolledToHighlightedAlert = false;
        _this.node = React.createRef();
        _this.state = {
            isKpiAlertAfterSaving: false,
            isKpiAlertAfterDeleting: false,
            isAlertHighlighted: false,
        };
        _this.renderAlertBox = function () {
            var isAlertingTemporarilyDisabled = isAlertingTemporarilyDisabledForGivenFilter(_this.props.kpi, _this.props.filters, _this.props.userWorkspaceSettings);
            var alertIconClasses = cx("dash-item-action", "dash-item-action-alert", "s-dash-item-action-alert", "gd-icon-bell", {
                "alert-set": _this.state.isKpiAlertAfterSaving,
                "alert-deleted": _this.state.isKpiAlertAfterDeleting,
            });
            // TODO: Remove "isAlertingTemporarilyDisabledForGivenFilter" when alerts support absolute filters (RAIL-1456, RAIL-1457).
            //       When alert is set, we allow opening the alert box so user can edit/delete it.
            if (_this.props.isReadOnlyMode ||
                !_this.props.canSetAlert ||
                (isAlertingTemporarilyDisabled && !_this.props.alert)) {
                var bubbleMessage = _this.props.isReadOnlyMode ? (React.createElement(FormattedMessage, { id: "kpi.alertBox.disabledInReadOnly" })) : (React.createElement(FormattedMessage, { id: !isAlertingTemporarilyDisabled
                        ? "kpi.alertBox.unverifiedEmail"
                        : "visualization.alert_not_supported" }));
                return (React.createElement(BubbleHoverTrigger, { showDelay: 0, hideDelay: 0, tagName: "div", className: cx(alertIconClasses, "disabled") },
                    React.createElement(Bubble, { className: "bubble-primary", alignPoints: disabledBubbleAlignPoints }, bubbleMessage)));
            }
            return (React.createElement("div", { onClick: _this.onAlertDialogOpenClick },
                React.createElement(BubbleHoverTrigger, { className: alertIconClasses, showDelay: 500, hideDelay: 0, tagName: "div" },
                    React.createElement(Bubble, { className: "bubble-primary", alignPoints: enabledBubbleAlignPoints },
                        React.createElement(FormattedMessage, { id: "kpi.alertBox.title" })))));
        };
        _this.onAlertDialogOpenClick = function (e) {
            e.stopPropagation();
            _this.props.onAlertDialogOpenClick();
        };
        return _this;
    }
    DashboardItemWithKpiAlert.prototype.componentDidMount = function () {
        // handle cases when this component is rendered already highlighted
        if (this.props.isAlertHighlighted) {
            this.updateStatePropertyForTime("isAlertHighlighted", 5000);
        }
    };
    DashboardItemWithKpiAlert.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        if (this.isKpiAlertSaved(nextProps)) {
            this.updateStatePropertyForTime("isKpiAlertAfterSaving", 1000);
        }
        if (this.isKpiAlertDeleted(nextProps)) {
            this.updateStatePropertyForTime("isKpiAlertAfterDeleting", 1000);
        }
        if (!this.props.isAlertHighlighted && nextProps.isAlertHighlighted) {
            this.updateStatePropertyForTime("isAlertHighlighted", 5000);
        }
    };
    DashboardItemWithKpiAlert.prototype.componentDidUpdate = function () {
        if (this.props.isAlertHighlighted && !this.isScrolledToHighlightedAlert) {
            this.isScrolledToHighlightedAlert = true;
            var node = this.node.current;
            if (node) {
                window.scrollTo(0, getNodeDocumentRelativeOffsetTop(node));
            }
        }
    };
    DashboardItemWithKpiAlert.prototype.componentWillUnmount = function () {
        this.clearUpdatingTimeout();
    };
    // toggle property to true for given amount of time
    DashboardItemWithKpiAlert.prototype.updateStatePropertyForTime = function (name, timeout) {
        var _a;
        var _this = this;
        var _b = this.state, isKpiAlertAfterSaving = _b.isKpiAlertAfterSaving, isKpiAlertAfterDeleting = _b.isKpiAlertAfterDeleting, isAlertHighlighted = _b.isAlertHighlighted;
        this.clearUpdatingTimeout(name);
        this.setState((_a = {
                isKpiAlertAfterSaving: isKpiAlertAfterSaving,
                isKpiAlertAfterDeleting: isKpiAlertAfterDeleting,
                isAlertHighlighted: isAlertHighlighted
            },
            _a[name] = true,
            _a));
        this.timeouts[name] = setTimeout(function () {
            var _a;
            _this.setState((_a = {
                    isKpiAlertAfterSaving: isKpiAlertAfterSaving,
                    isKpiAlertAfterDeleting: isKpiAlertAfterDeleting,
                    isAlertHighlighted: isAlertHighlighted
                },
                _a[name] = false,
                _a));
        }, timeout);
    };
    DashboardItemWithKpiAlert.prototype.clearUpdatingTimeout = function (name) {
        var _this = this;
        if (name && this.timeouts[name]) {
            clearTimeout(this.timeouts[name]);
            delete this.timeouts[name];
        }
        else {
            Object.keys(this.timeouts).forEach(function (key) { return clearTimeout(_this.timeouts[key]); });
            this.timeouts = {};
        }
    };
    DashboardItemWithKpiAlert.prototype.isKpiAlertSaved = function (nextProps) {
        return (!this.state.isKpiAlertAfterSaving &&
            this.props.alertSavingStatus === "inProgress" &&
            nextProps.alertSavingStatus === "idle");
    };
    DashboardItemWithKpiAlert.prototype.isKpiAlertDeleted = function (nextProps) {
        return (!this.state.isKpiAlertAfterDeleting &&
            this.props.alertDeletingStatus === "inProgress" &&
            nextProps.alertDeletingStatus === "idle");
    };
    DashboardItemWithKpiAlert.prototype.getClassNames = function () {
        var _a;
        var kpiAlertResult = this.props.kpiAlertResult;
        var isNoData = isNoDataSdkError(this.props.alertExecutionError);
        var hasEvaluationResult = isNoData || (kpiAlertResult === null || kpiAlertResult === void 0 ? void 0 : kpiAlertResult.measureResult) !== undefined;
        var content = cx(this.props.contentClassName, {
            "is-alert-dialog": this.props.isAlertDialogOpen,
            "has-set-alert": !!this.props.alert,
            "is-alert-triggered": hasEvaluationResult && ((_a = this.props.alert) === null || _a === void 0 ? void 0 : _a.isTriggered) && !this.props.suppressAlertTriggered,
            "is-alert-broken": hasEvaluationResult && this.props.isAlertBroken,
            "is-alert-highlighted": this.state.isAlertHighlighted,
            "is-alert-evaluating": this.props.isAlertExecutionLoading,
        });
        var kpi = cx(this.props.kpiClassName, "s-dashboard-kpi-component", "widget-loaded", "visualization", {
            "kpi-with-pop": this.props.kpi.kpi.comparisonType !== "none",
            "content-loading": this.props.isLoading,
            "content-loaded": !this.props.isLoading,
        });
        return {
            content: content,
            kpi: kpi,
        };
    };
    DashboardItemWithKpiAlert.prototype.render = function () {
        var _this = this;
        var classnames = this.getClassNames();
        return (React.createElement(DashboardItemKpi, { contentClassName: classnames.content, visualizationClassName: classnames.kpi, contentRef: this.node, renderAfterContent: function () { return _this.props.isAlertDialogOpen && _this.props.renderAlertDialog(); }, renderHeadline: function (clientHeight) { return (React.createElement(React.Fragment, null,
                _this.renderAlertBox(),
                _this.props.renderHeadline(clientHeight))); } }, this.props.children));
    };
    DashboardItemWithKpiAlert.defaultProps = {
        isAlertHighlighted: false,
        filters: [],
        alertDeletingStatus: "idle",
        alertSavingStatus: "idle",
        alertUpdatingStatus: "idle",
        suppressAlertTriggered: false,
        isReadOnlyMode: false,
    };
    return DashboardItemWithKpiAlert;
}(Component));
export { DashboardItemWithKpiAlert };
//# sourceMappingURL=DashboardItemWithKpiAlert.js.map