// (C) 2019-2020 GoodData Corporation
import { __awaiter, __generator } from "tslib";
import { widgetUri, } from "@gooddata/sdk-backend-spi";
import { GdcMetadataObject } from "@gooddata/api-model-bear";
import { getObjectIdFromUri } from "../../../utils/api";
import { convertMetadataObject } from "../../../convertors/fromBackend/MetaConverter";
import isEmpty from "lodash/isEmpty";
import keyBy from "lodash/keyBy";
import { convertMetric } from "../../../convertors/fromBackend/CatalogConverter";
var objectTypeToObjectCategory = function (type) {
    if (type === "measure") {
        return "metric";
    }
    return type;
};
var WidgetReferencesQuery = /** @class */ (function () {
    function WidgetReferencesQuery(authCall, workspace, widget, requestedTypes) {
        var _this = this;
        this.authCall = authCall;
        this.workspace = workspace;
        this.widget = widget;
        this.requestedTypes = requestedTypes;
        this.run = function () { return __awaiter(_this, void 0, void 0, function () {
            var xrefs, objects;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (isEmpty(this.typesForXref)) {
                            return [2 /*return*/, {}];
                        }
                        return [4 /*yield*/, this.findReferencedObjects()];
                    case 1:
                        xrefs = _a.sent();
                        return [4 /*yield*/, this.loadObjects(xrefs)];
                    case 2:
                        objects = _a.sent();
                        return [2 /*return*/, this.createResult(objects)];
                }
            });
        }); };
        //
        //
        //
        /**
         * Uses the query resource to obtain all objects of the desired types which are used by the insight.
         */
        this.findReferencedObjects = function () { return __awaiter(_this, void 0, void 0, function () {
            var categories, allDirectObjects;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        categories = this.typesForXref.map(objectTypeToObjectCategory);
                        return [4 /*yield*/, this.authCall(function (sdk) {
                                return sdk.xhr.getParsed("/gdc/md/" + _this.workspace + "/using2/" + _this.objectId + "?types=" + categories.join(","));
                            })];
                    case 1:
                        allDirectObjects = (_a.sent()).entries;
                        return [2 /*return*/, allDirectObjects];
                }
            });
        }); };
        /**
         * Give the discovered references, bulk load data for objects of those types that the caller is interested in.
         */
        this.loadObjects = function (xrefs) { return __awaiter(_this, void 0, void 0, function () {
            var categories, objectUrisToObtain;
            var _this = this;
            return __generator(this, function (_a) {
                categories = this.typesForLoad.map(objectTypeToObjectCategory);
                objectUrisToObtain = xrefs
                    .filter(function (i) { return categories.includes(i.category); })
                    .map(function (meta) { return meta.link; });
                return [2 /*return*/, this.authCall(function (sdk) { return sdk.md.getObjects(_this.workspace, objectUrisToObtain); })];
            });
        }); };
        var uri = widgetUri(this.widget);
        this.objectId = getObjectIdFromUri(uri);
        this.typesForXref = this.requestedTypes;
        this.typesForLoad = this.requestedTypes;
    }
    //
    //
    //
    WidgetReferencesQuery.prototype.createResult = function (objects) {
        var unwrappedObjects = objects.map(GdcMetadataObject.unwrapMetadataObject);
        var convertedObjects = unwrappedObjects.map(convertMetadataObject);
        var objectsByUri = keyBy(unwrappedObjects, function (obj) { return obj.meta.uri; });
        var catalogItems = [];
        convertedObjects.forEach(function (obj) {
            var fullObject = objectsByUri[obj.uri];
            if (obj.type === "measure") {
                catalogItems.push(convertMetric({ metric: fullObject }));
            }
        });
        return {
            catalogItems: catalogItems,
        };
    };
    return WidgetReferencesQuery;
}());
export { WidgetReferencesQuery };
//# sourceMappingURL=widgetReferences.js.map