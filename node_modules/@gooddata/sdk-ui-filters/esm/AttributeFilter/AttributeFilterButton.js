import { __assign, __awaiter, __generator } from "tslib";
// (C) 2021 GoodData Corporation
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import cx from "classnames";
import { injectIntl } from "react-intl";
import { filterAttributeElements, filterObjRef, isAttributeElementsByRef, isNegativeAttributeFilter, newNegativeAttributeFilter, newPositiveAttributeFilter, } from "@gooddata/sdk-model";
import { NoData, Dropdown } from "@gooddata/sdk-ui-kit";
import { AttributeDropdownBody, } from "./AttributeDropdown/AttributeDropdownBody";
import compact from "lodash/compact";
import debounce from "lodash/debounce";
import isEmpty from "lodash/isEmpty";
import isEqual from "lodash/isEqual";
import isNil from "lodash/isNil";
import { MAX_SELECTION_SIZE } from "./AttributeDropdown/AttributeDropdownList";
import { mergeElementQueryResults } from "./AttributeDropdown/mergeElementQueryResults";
import { IntlWrapper, useCancelablePromise, usePlaceholder, useResolveValueWithPlaceholders, withContexts, } from "@gooddata/sdk-ui";
import MediaQuery from "react-responsive";
import { MediaQueries } from "../constants";
import { attributeElementsToAttributeElementArray, getAllExceptTitle, getAllTitle, getElementTotalCount, getFilteringTitleIntl, getItemsTitles, getLoadingTitleIntl, getNoneTitleIntl, getObjRef, getParentFilterTitles, getValidElementsFilters, isParentFilteringEnabled, isParentFiltersElementsByRef, needsLoading, showAllFilteredMessage, showItemsFilteredMessage, updateSelectedOptionsWithDataByMap, } from "./utils/AttributeFilterUtils";
import invariant from "ts-invariant";
import stringify from "json-stable-stringify";
import { isNonEmptyListItem } from "./AttributeDropdown/types";
import { AttributeDropdownAllFilteredOutBody } from "./AttributeDropdown/AttributeDropdownAllFilteredOutBody";
import { ShortenedText } from "@gooddata/sdk-ui-kit";
var DefaultFilterError = injectIntl(function (_a) {
    var intl = _a.intl;
    var text = intl.formatMessage({ id: "gs.filter.error" });
    return React.createElement("div", { className: "gd-message error s-button-error" }, text);
});
var tooltipAlignPoints = [
    { align: "tc bc", offset: { x: 0, y: -2 } },
    { align: "cc tc", offset: { x: 0, y: 10 } },
    { align: "bl tr", offset: { x: -2, y: -8 } },
];
var DropdownButton = function (_a) {
    var isMobile = _a.isMobile, isOpen = _a.isOpen, title = _a.title, subtitleItemCount = _a.subtitleItemCount, subtitleText = _a.subtitleText;
    var subtitleSelectedItemsRef = useRef(null);
    var _b = useState(false), displayItemCount = _b[0], setDisplayItemCount = _b[1];
    var _c = useState(""), subtitle = _c[0], setSubtitle = _c[1];
    useEffect(function () {
        if (!isEmpty(subtitleText) && subtitleText !== subtitle) {
            setSubtitle(subtitleText);
        }
    }, [subtitleText]);
    useEffect(function () {
        var element = subtitleSelectedItemsRef.current;
        if (!element) {
            return;
        }
        var roundedWidth = Math.ceil(element.getBoundingClientRect().width);
        var displayItemCount = roundedWidth < element.scrollWidth;
        setDisplayItemCount(displayItemCount);
    }, [subtitle]);
    return (React.createElement("div", { className: cx("attribute-filter-button", "s-attribute-filter", {
            "is-active": isOpen,
            "gd-attribute-filter-button-mobile": isMobile,
        }) },
        React.createElement("div", { className: "button-content" },
            React.createElement("div", { className: "button-title" },
                React.createElement(ShortenedText, { tooltipAlignPoints: tooltipAlignPoints }, title)),
            React.createElement("div", { className: "button-subtitle" },
                React.createElement("span", { className: "button-selected-items", ref: subtitleSelectedItemsRef }, subtitle),
                displayItemCount && (React.createElement("span", { className: "button-selected-items-count" }, "(" + subtitleItemCount + ")"))))));
};
var LIMIT = MAX_SELECTION_SIZE + 50;
export var AttributeFilterButtonCore = function (props) {
    var _a, _b, _c, _d, _e, _f;
    invariant(!(props.filter && props.connectToPlaceholder), "It's not possible to combine 'filter' property with 'connectToPlaceholder' property. Either provide a value, or a placeholder.");
    invariant(!(props.filter && !props.onApply), "It's not possible to use 'filter' property without 'onApply' property. Either provide 'onApply' callback or use placeholders.");
    var _g = usePlaceholder(props.connectToPlaceholder), resolvedPlaceholder = _g[0], setPlaceholderValue = _g[1];
    var currentFilter = resolvedPlaceholder || props.filter;
    var filterRef = filterObjRef(currentFilter);
    var currentFilterObjRef = useMemo(function () { return filterRef; }, [stringify(filterRef)]);
    var getInitialSelectedOptions = function () {
        // the as any cast is ok here, the data will get fixed once the element load completes
        // this serves only to have some initial state here so that when full element data is loaded
        // it automatically sets the props.filter.elements as selected
        return currentFilter
            ? attributeElementsToAttributeElementArray(filterAttributeElements(currentFilter))
            : [];
    };
    var getInitialIsInverted = function () {
        return currentFilter ? isNegativeAttributeFilter(currentFilter) : true;
    };
    var _h = useState(function () {
        var initialSelection = getInitialSelectedOptions();
        var initialIsInverted = getInitialIsInverted();
        return {
            selectedFilterOptions: initialSelection,
            appliedFilterOptions: initialSelection,
            isInverted: initialIsInverted,
            appliedIsInverted: initialIsInverted,
            firstLoad: true,
            searchString: "",
            offset: 0,
            limit: LIMIT,
            isDropdownOpen: false,
            validOptions: null,
            uriToAttributeElementMap: new Map(),
        };
    }), state = _h[0], setState = _h[1];
    useEffect(function () {
        setState(function (prevState) {
            return __assign(__assign({}, prevState), { uriToAttributeElementMap: new Map() });
        });
    }, [props.backend, props.workspace, props.identifier, stringify(currentFilterObjRef)]);
    useEffect(function () {
        setState(function (prevValue) {
            var initialSelection = getInitialSelectedOptions();
            var initialIsInverted = getInitialIsInverted();
            var selectedOptionsUris = prevValue.selectedFilterOptions.map(function (opt) { return opt.uri; });
            var appliedOptionsUris = prevValue.appliedFilterOptions.map(function (opt) { return opt.uri; });
            var initialSelectionUris = initialSelection.map(function (opt) { return opt.uri; });
            var resultState = prevValue;
            if (!isEqual(selectedOptionsUris, initialSelectionUris)) {
                resultState = __assign(__assign({}, resultState), { selectedFilterOptions: initialSelection });
            }
            if (!isEqual(appliedOptionsUris, initialSelectionUris)) {
                resultState = __assign(__assign({}, resultState), { appliedFilterOptions: initialSelection });
            }
            if (prevValue.isInverted !== initialIsInverted) {
                resultState = __assign(__assign({}, resultState), { isInverted: initialIsInverted, appliedIsInverted: initialIsInverted });
            }
            // if no change returning prevValue effectively skips the setState
            return resultState;
        });
    }, [currentFilter]);
    var resolvedParentFilters = useResolveValueWithPlaceholders(props.parentFilters);
    /*
     * This cancelable promise is used to fetch attribute filter elements for the initial selected options.
     * It's only called on component mounting to ensure we have attribute element titles for elements out of
     * limits in case of huge element number.
     */
    var uriToAttributeElementMapError = useCancelablePromise({
        promise: isEmpty(state.selectedFilterOptions)
            ? null
            : function () { return __awaiter(void 0, void 0, void 0, function () { return __generator(this, function (_a) {
                return [2 /*return*/, prepareElementsTitleQuery().query()];
            }); }); },
        onSuccess: function (initialElements) {
            setState(function (prevState) {
                var _a;
                var uriToAttributeElementMap = new Map(prevState.uriToAttributeElementMap);
                (_a = initialElements.items) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
                    uriToAttributeElementMap.set(item.uri, item);
                });
                return __assign(__assign({}, prevState), { uriToAttributeElementMap: uriToAttributeElementMap });
            });
        },
    }, [props.backend, props.workspace, props.identifier, stringify(currentFilterObjRef)]).error;
    // this cancelable promise loads missing page of data if needed and in the onSuccess callback
    // it merges the newly loaded data into the already loaded data
    var _j = useCancelablePromise({
        promise: needsLoading(state.validOptions, state.offset, state.limit)
            ? function () { return __awaiter(void 0, void 0, void 0, function () {
                var preparedElementQuery;
                return __generator(this, function (_a) {
                    preparedElementQuery = prepareElementsQuery(state.offset, state.limit);
                    return [2 /*return*/, preparedElementQuery.query()];
                });
            }); }
            : null,
        onSuccess: function (newElements) {
            setState(function (prevState) {
                var mergedValidElements = mergeElementQueryResults(prevState.validOptions, newElements);
                var newUriToAttributeElementMap = new Map(prevState.uriToAttributeElementMap);
                var items = mergedValidElements.items;
                items.filter(isNonEmptyListItem).forEach(function (item) {
                    newUriToAttributeElementMap.set(item.uri, item);
                });
                // make sure that selected items have both title and uri, otherwise selection in InvertableList won't work
                // TODO we could maybe use the InvertableList's getItemKey and just use title or uri for example
                var updatedSelectedItems = updateSelectedOptionsWithDataByMap(prevState.selectedFilterOptions, newUriToAttributeElementMap);
                var updatedAppliedItems = updateSelectedOptionsWithDataByMap(prevState.appliedFilterOptions, newUriToAttributeElementMap);
                var validOptions = (resolvedParentFilters === null || resolvedParentFilters === void 0 ? void 0 : resolvedParentFilters.length) ? newElements : mergedValidElements;
                return __assign(__assign({}, prevState), { selectedFilterOptions: compact(updatedSelectedItems), appliedFilterOptions: compact(updatedAppliedItems), validOptions: validOptions, firstLoad: false, uriToAttributeElementMap: newUriToAttributeElementMap });
            });
        },
    }, [
        state.selectedFilterOptions,
        state.appliedFilterOptions,
        state.validOptions,
        state.offset,
        state.limit,
        resolvedParentFilters,
    ]), elementsError = _j.error, elementsStatus = _j.status;
    var _k = useCancelablePromise({
        promise: function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, getElementTotalCount(props.workspace, props.backend, getObjRef(currentFilter, props.identifier), "", // we need to get all available elements count in every case possible
                    getValidElementsFilters(resolvedParentFilters, props.parentFilterOverAttribute))];
            });
        }); },
    }, [props.backend, props.workspace, props.identifier, stringify(resolvedParentFilters), currentFilter]), originalTotalCountError = _k.error, originalTotalCount = _k.result, originalTotalCountStatus = _k.status;
    var _l = useCancelablePromise({
        promise: function () { return __awaiter(void 0, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, getElementTotalCount(props.workspace, props.backend, getObjRef(currentFilter, props.identifier), state.searchString, getValidElementsFilters(resolvedParentFilters, props.parentFilterOverAttribute))];
            });
        }); },
    }, [
        props.backend,
        props.workspace,
        props.identifier,
        stringify(resolvedParentFilters),
        state.searchString,
        currentFilter,
    ]), totalCountError = _l.error, totalCount = _l.result, totalCountStatus = _l.status;
    var _m = useCancelablePromise({
        promise: function () { return getParentFilterTitles(resolvedParentFilters !== null && resolvedParentFilters !== void 0 ? resolvedParentFilters : [], getBackend(), props.workspace); },
    }, [props.backend, props.workspace, stringify(resolvedParentFilters)]), parentFilterTitlesError = _m.error, parentFilterTitles = _m.result, parentFilterTitlesStatus = _m.status;
    var invalidate = function (parentFilterChanged) {
        var _a;
        if (parentFilterChanged === void 0) { parentFilterChanged = false; }
        var nullStateValues = {
            validOptions: null,
            offset: 0,
            limit: LIMIT,
        };
        if (parentFilterChanged) {
            var emptyFilter = createFilter(currentFilter, true);
            if (props.connectToPlaceholder) {
                setPlaceholderValue(emptyFilter);
            }
            var isInverted_1 = isNegativeAttributeFilter(currentFilter);
            (_a = props.onApply) === null || _a === void 0 ? void 0 : _a.call(props, emptyFilter, isInverted_1);
            setState(function (s) {
                return __assign(__assign(__assign({}, s), nullStateValues), { selectedFilterOptions: [], appliedFilterOptions: [], isInverted: isInverted_1, appliedIsInverted: isInverted_1 });
            });
        }
        else {
            setState(function (s) {
                return __assign(__assign({}, s), nullStateValues);
            });
        }
    };
    useEffect(function () {
        if (!state.firstLoad && !isElementsLoading()) {
            invalidate(true);
        }
    }, [stringify(resolvedParentFilters)]);
    useEffect(function () {
        invalidate();
    }, [props.workspace, props.backend, state.searchString]);
    var _o = useCancelablePromise({
        promise: function () { return __awaiter(void 0, void 0, void 0, function () {
            var attributes, displayForm;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        attributes = getBackend().workspace(props.workspace).attributes();
                        return [4 /*yield*/, attributes.getAttributeDisplayForm(getObjRef(currentFilter, props.identifier))];
                    case 1:
                        displayForm = _a.sent();
                        return [2 /*return*/, attributes.getAttribute(displayForm.attribute)];
                }
            });
        }); },
    }, [stringify(currentFilterObjRef), props.workspace, props.backend, props.identifier]), attributeError = _o.error, attribute = _o.result, attributeStatus = _o.status;
    useEffect(function () {
        if (props.onError && (attributeError || elementsError)) {
            props.onError(attributeError || elementsError);
        }
    }, [attributeError, elementsError]);
    var prepareElementsQuery = function (offset, limit) {
        var workspace = props.workspace;
        var preparedElementQuery = getBackend()
            .workspace(workspace)
            .attributes()
            .elements()
            .forDisplayForm(getObjRef(currentFilter, props.identifier))
            .withOptions(__assign({}, (!isEmpty(state.searchString) ? { filter: state.searchString } : {})))
            .withOffset(offset)
            .withLimit(limit);
        if (isParentFilteringEnabled(getBackend())) {
            if (resolvedParentFilters && !isParentFiltersElementsByRef(resolvedParentFilters)) {
                // eslint-disable-next-line no-console
                console.error("Parent filters must be defined by uris to enable parent-child filtering feature");
            }
            else {
                preparedElementQuery.withAttributeFilters(getValidElementsFilters(resolvedParentFilters, props.parentFilterOverAttribute));
            }
        }
        return preparedElementQuery;
    };
    var prepareElementsTitleQuery = function () {
        return getBackend()
            .workspace(props.workspace)
            .attributes()
            .elements()
            .forDisplayForm(getObjRef(currentFilter, props.identifier))
            .withOptions({
            uris: state.selectedFilterOptions.map(function (opt) { return opt.uri; }),
        });
    };
    /**
     * getters
     */
    var getBackend = function () {
        return props.backend.withTelemetry("AttributeFilter", props);
    };
    var isElementsLoading = function () {
        // pending means idle in this context
        return elementsStatus === "loading";
    };
    var isTotalCountLoading = function () {
        return totalCountStatus === "pending" || totalCountStatus === "loading";
    };
    var isOriginalTotalCountLoading = function () {
        return originalTotalCountStatus === "pending" || originalTotalCountStatus === "loading";
    };
    var isParentFilterTitlesLoading = function () {
        return parentFilterTitlesStatus === "pending" || parentFilterTitlesStatus === "loading";
    };
    var isAllFiltered = showAllFilteredMessage(isElementsLoading(), resolvedParentFilters, originalTotalCount);
    var getSubtitle = function () {
        if (isElementsLoading() && !isEmpty(state.searchString)) {
            return "";
        }
        if (isTotalCountLoading()) {
            if (state.firstLoad) {
                return getLoadingTitleIntl(props.intl);
            }
            else if (!isEmpty(props.parentFilters)) {
                return getFilteringTitleIntl(props.intl);
            }
        }
        if (isAllFiltered) {
            return getAllTitle(props.intl);
        }
        var displayForm = getObjRef(currentFilter, props.identifier);
        if (state.uriToAttributeElementMap.size > 0 && !isNil(originalTotalCount) && displayForm) {
            var empty = getNumberOfSelectedItems() === 0 && originalTotalCount > 0;
            var all = getNumberOfSelectedItems() === originalTotalCount;
            var getAllPartIntl = all ? getAllTitle(props.intl) : getAllExceptTitle(props.intl);
            if (empty) {
                return getNoneTitleIntl(props.intl);
            }
            if (all) {
                return getAllPartIntl;
            }
            return state.isInverted
                ? getAllPartIntl + " " + getItemsTitles(state.selectedFilterOptions, state.uriToAttributeElementMap)
                : "" + getItemsTitles(state.selectedFilterOptions, state.uriToAttributeElementMap);
        }
        return "";
    };
    /**
     * callbacks
     */
    var onSearch = useCallback(debounce(function (query) {
        setState(function (s) { return (__assign(__assign({}, s), { searchString: query })); });
    }, 500), []);
    var createFilter = function (filter, emptyFilter) {
        if (emptyFilter === void 0) { emptyFilter = false; }
        var useUriElements = filter && isAttributeElementsByRef(filterAttributeElements(filter));
        var filterFactory = state.isInverted || emptyFilter ? newNegativeAttributeFilter : newPositiveAttributeFilter;
        var items = emptyFilter ? [] : state.selectedFilterOptions;
        return filterFactory(getObjRef(filter, props.identifier), useUriElements
            ? { uris: items.map(function (item) { return item.uri; }) }
            : { values: items.map(function (item) { return item.title; }) });
    };
    var backupIsInverted = function () {
        setState(function (state) { return (__assign(__assign({}, state), { appliedIsInverted: state.isInverted })); });
    };
    var onApply = function (closeDropdown) {
        var _a;
        backupIsInverted();
        var filter = createFilter(currentFilter);
        if (props.connectToPlaceholder) {
            setPlaceholderValue(filter);
        }
        (_a = props.onApply) === null || _a === void 0 ? void 0 : _a.call(props, filter, state.isInverted);
        return closeDropdown();
    };
    var onSelect = function (selectedFilterOptions, isInverted) {
        setState(function (s) { return (__assign(__assign({}, s), { selectedFilterOptions: selectedFilterOptions, isInverted: isInverted })); });
    };
    var onRangeChange = function (_searchString, from, to) {
        // only react to range changes after initial load to properly handle offset shifts on search
        if (state.validOptions) {
            setState(function (s) { return (__assign(__assign({}, s), { offset: from, limit: to - from })); });
        }
    };
    /**
     * utilities
     */
    var onDropdownClosed = function () {
        setState(function (s) {
            return __assign(__assign({}, s), { selectedFilterOptions: s.appliedFilterOptions, isInverted: s.appliedIsInverted, searchString: "", isDropdownOpen: false });
        });
    };
    var onDropdownOpen = function () {
        setState(function (s) { return (__assign(__assign({}, s), { isDropdownOpen: true })); });
    };
    var onDropdownOpenStateChanged = function (isOpen) {
        isOpen ? onDropdownOpen() : onDropdownClosed();
    };
    var getNumberOfSelectedItems = function () {
        if (state.isInverted) {
            return originalTotalCount - state.selectedFilterOptions.length;
        }
        return state.selectedFilterOptions.length;
    };
    var hasNoData = !isParentFilterTitlesLoading() &&
        !(parentFilterTitles === null || parentFilterTitles === void 0 ? void 0 : parentFilterTitles.length) &&
        !isElementsLoading() &&
        originalTotalCount === 0;
    function renderDefaultBody(bodyProps, closeDropdown) {
        return isAllFiltered ? (React.createElement(MediaQuery, { query: MediaQueries.IS_MOBILE_DEVICE }, function (isMobile) { return (React.createElement(AttributeDropdownAllFilteredOutBody, { parentFilterTitles: parentFilterTitles, onApplyButtonClick: function () {
                onApply(closeDropdown);
            }, onCancelButtonClick: closeDropdown, isMobile: isMobile })); })) : hasNoData ? (React.createElement(NoData, { noDataLabel: props.intl.formatMessage({ id: "attributesDropdown.noData" }) })) : (React.createElement(AttributeDropdownBody, __assign({}, bodyProps)));
    }
    var renderAttributeDropdown = function () {
        var getDropdownBodyProps = function (onApplyButtonClicked, onCloseButtonClicked) {
            var _a, _b, _c;
            return ({
                items: (_b = (_a = state.validOptions) === null || _a === void 0 ? void 0 : _a.items) !== null && _b !== void 0 ? _b : [],
                totalCount: totalCount !== null && totalCount !== void 0 ? totalCount : LIMIT,
                onSelect: onSelect,
                onRangeChange: onRangeChange,
                onSearch: onSearch,
                selectedItems: state.selectedFilterOptions,
                isInverted: state.isInverted,
                isLoading: (!((_c = state.validOptions) === null || _c === void 0 ? void 0 : _c.items) && isElementsLoading()) ||
                    isTotalCountLoading() ||
                    isOriginalTotalCountLoading() ||
                    isParentFilterTitlesLoading() ||
                    isOriginalTotalCountLoading(),
                searchString: state.searchString,
                applyDisabled: getNumberOfSelectedItems() === 0,
                showItemsFilteredMessage: showItemsFilteredMessage(isElementsLoading(), resolvedParentFilters),
                parentFilterTitles: parentFilterTitles,
                onApplyButtonClicked: onApplyButtonClicked,
                onCloseButtonClicked: onCloseButtonClicked,
            });
        };
        return (React.createElement(Dropdown, { closeOnParentScroll: true, closeOnMouseDrag: true, closeOnOutsideClick: true, enableEventPropagation: true, alignPoints: [
                { align: "bl tl" },
                { align: "tr tl" },
                { align: "br tr", offset: { x: -11 } },
                { align: "tr tl", offset: { x: 0, y: -100 } },
                { align: "tr tl", offset: { x: 0, y: -50 } },
            ], renderButton: function (_a) {
                var toggleDropdown = _a.toggleDropdown;
                return (React.createElement(MediaQuery, { query: MediaQueries.IS_MOBILE_DEVICE }, function (isMobile) { return (React.createElement("span", { onClick: toggleDropdown },
                    React.createElement(DropdownButton, { isOpen: state.isDropdownOpen, isMobile: isMobile, title: props.title ||
                            (attributeStatus !== "loading" && attributeStatus !== "pending")
                            ? attribute.title
                            : getLoadingTitleIntl(props.intl), subtitleText: getSubtitle(), subtitleItemCount: state.selectedFilterOptions.length }))); }));
            }, onOpenStateChanged: onDropdownOpenStateChanged, renderBody: function (_a) {
                var _b;
                var closeDropdown = _a.closeDropdown;
                return props.renderBody
                    ? props.renderBody(__assign(__assign({}, getDropdownBodyProps(function () {
                        onApply(closeDropdown);
                    }, function () {
                        closeDropdown();
                    })), { isElementsLoading: !((_b = state.validOptions) === null || _b === void 0 ? void 0 : _b.items) && isElementsLoading(), isLoaded: !isOriginalTotalCountLoading(), onConfigurationChange: function () { }, attributeFilterRef: null }))
                    : renderDefaultBody(getDropdownBodyProps(function () {
                        onApply(closeDropdown);
                    }, function () {
                        closeDropdown();
                    }), closeDropdown);
            } }));
    };
    var FilterError = props.FilterError;
    return elementsError ||
        attributeError ||
        totalCountError ||
        parentFilterTitlesError ||
        originalTotalCountError ||
        uriToAttributeElementMapError ? (React.createElement(FilterError, { error: (_f = (_e = (_d = (_c = (_b = (_a = elementsError === null || elementsError === void 0 ? void 0 : elementsError.message) !== null && _a !== void 0 ? _a : attributeError === null || attributeError === void 0 ? void 0 : attributeError.message) !== null && _b !== void 0 ? _b : totalCountError === null || totalCountError === void 0 ? void 0 : totalCountError.message) !== null && _c !== void 0 ? _c : parentFilterTitlesError === null || parentFilterTitlesError === void 0 ? void 0 : parentFilterTitlesError.message) !== null && _d !== void 0 ? _d : originalTotalCountError === null || originalTotalCountError === void 0 ? void 0 : originalTotalCountError.message) !== null && _e !== void 0 ? _e : uriToAttributeElementMapError === null || uriToAttributeElementMapError === void 0 ? void 0 : uriToAttributeElementMapError.message) !== null && _f !== void 0 ? _f : "Unknown error" })) : (renderAttributeDropdown());
};
AttributeFilterButtonCore.defaultProps = {
    FilterError: DefaultFilterError,
};
var IntlAttributeFilterButton = withContexts(injectIntl(AttributeFilterButtonCore));
/**
 * @public
 */
export var AttributeFilterButton = function (props) {
    return (React.createElement(IntlWrapper, { locale: props.locale },
        React.createElement(IntlAttributeFilterButton, __assign({}, props))));
};
//# sourceMappingURL=AttributeFilterButton.js.map