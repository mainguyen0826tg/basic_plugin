// (C) 2019-2020 GoodData Corporation
import { __extends } from "tslib";
import { defaultDimensionsGenerator, defWithDimensions, newDefForBuckets, newDefForInsight, newDefForItems, isInsight, } from "@gooddata/sdk-model";
import { DecoratedExecutionFactory } from "../decoratedBackend/execution";
/**
 * Abstract base class that can be extended to implement concrete execution factories for different
 * backend implementations.
 *
 * This class implements the convenience methods which do not need to change in implementations.
 *
 * Note: the `forInsightByRef` is implemented as fallback to freeform execution done by `forInsight`. The
 * rationale is that most backends do not support that anyway so it is a safe default behavior. If the backend
 * supports execute-by-reference, then overload the method with your own implementation (see sdk-backend-bear for
 * inspiration)
 *
 * @internal
 */
var AbstractExecutionFactory = /** @class */ (function () {
    function AbstractExecutionFactory(workspace) {
        this.workspace = workspace;
    }
    AbstractExecutionFactory.prototype.forItems = function (items, filters) {
        var def = defWithDimensions(newDefForItems(this.workspace, items, filters), defaultDimensionsGenerator);
        return this.forDefinition(def);
    };
    AbstractExecutionFactory.prototype.forBuckets = function (buckets, filters) {
        var def = defWithDimensions(newDefForBuckets(this.workspace, buckets, filters), defaultDimensionsGenerator);
        return this.forDefinition(def);
    };
    AbstractExecutionFactory.prototype.forInsight = function (insight, filters) {
        var def = defWithDimensions(newDefForInsight(this.workspace, insight, filters), defaultDimensionsGenerator);
        return this.forDefinition(def);
    };
    AbstractExecutionFactory.prototype.forInsightByRef = function (insight, filters) {
        return this.forInsight(insight, filters);
    };
    return AbstractExecutionFactory;
}());
export { AbstractExecutionFactory };
/**
 * This implementation of execution factory allows transparent injection of fixed set of filters to all
 * executions started through it.
 *
 * This factory will not perform any filter merging. All it does is ensure some filters are always passed
 * to the underlying factory. The responsibility to do the filter merging lies in the underlying factory.
 *
 * @internal
 */
var ExecutionFactoryWithFixedFilters = /** @class */ (function (_super) {
    __extends(ExecutionFactoryWithFixedFilters, _super);
    function ExecutionFactoryWithFixedFilters(decorated, filters) {
        if (filters === void 0) { filters = []; }
        var _this = _super.call(this, decorated) || this;
        _this.filters = filters;
        return _this;
    }
    ExecutionFactoryWithFixedFilters.prototype.forItems = function (items, filters) {
        if (filters === void 0) { filters = []; }
        return _super.prototype.forItems.call(this, items, this.filters.concat(filters));
    };
    ExecutionFactoryWithFixedFilters.prototype.forBuckets = function (buckets, filters) {
        if (filters === void 0) { filters = []; }
        return _super.prototype.forBuckets.call(this, buckets, this.filters.concat(filters));
    };
    ExecutionFactoryWithFixedFilters.prototype.forInsight = function (insight, filters) {
        if (filters === void 0) { filters = []; }
        return _super.prototype.forInsight.call(this, insight, this.filters.concat(filters));
    };
    ExecutionFactoryWithFixedFilters.prototype.forInsightByRef = function (insight, filters) {
        if (filters === void 0) { filters = []; }
        return _super.prototype.forInsightByRef.call(this, insight, this.filters.concat(filters));
    };
    return ExecutionFactoryWithFixedFilters;
}(DecoratedExecutionFactory));
export { ExecutionFactoryWithFixedFilters };
/**
 * This implementation of execution factory will transparently upgrade any `forInsight` execution
 * to `forInsightByRef` execution IF the argument to `forInsight` is actually a persisted insight (`IInsight` which
 * is subtype of `IInsightDefinition`).
 *
 * @internal
 */
var ExecutionFactoryUpgradingToExecByReference = /** @class */ (function (_super) {
    __extends(ExecutionFactoryUpgradingToExecByReference, _super);
    function ExecutionFactoryUpgradingToExecByReference(decorated) {
        return _super.call(this, decorated) || this;
    }
    ExecutionFactoryUpgradingToExecByReference.prototype.forInsight = function (insight, filters) {
        if (isInsight(insight)) {
            return this.forInsightByRef(insight, filters);
        }
        return _super.prototype.forInsight.call(this, insight, filters);
    };
    return ExecutionFactoryUpgradingToExecByReference;
}(DecoratedExecutionFactory));
export { ExecutionFactoryUpgradingToExecByReference };
//# sourceMappingURL=execution.js.map