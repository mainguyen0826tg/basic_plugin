// (C) 2007-2020 GoodData Corporation
import qs from "qs";
import { ProjectModule } from "./project";
import { parseSettingItemValue } from "./util";
var UserModule = /** @class */ (function () {
    function UserModule(xhr) {
        this.xhr = xhr;
    }
    /**
     * Find out whether a user is logged in
     *
     * @return {Promise} resolves with true if user logged in, false otherwise
     * @method isLoggedIn
     */
    UserModule.prototype.isLoggedIn = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.xhr.get("/gdc/account/token").then(function (r) {
                if (r.response.ok) {
                    resolve(true);
                }
                resolve(false);
            }, function (err) {
                if (err.response.status === 401) {
                    resolve(false);
                }
                else {
                    reject(err);
                }
            });
        });
    };
    /**
     * Find out whether a specified project is available to a currently logged user
     *
     * @method isLoggedInProject
     * @param {String} projectId A project identifier
     * @return {Promise} Resolves with true if user logged in and project available,
     *                   resolves with false if user logged in and project not available,
     *                   rejects if user not logged in
     */
    UserModule.prototype.isLoggedInProject = function (projectId) {
        var _this = this;
        return this.getCurrentProfile().then(function (profile) {
            return new Promise(function (resolve, reject) {
                var projectModule = new ProjectModule(_this.xhr);
                projectModule.getProjects(profile.links.self.split("/")[4]).then(function (projects) {
                    if (projects.find(function (p) { return p.links.self === "/gdc/projects/" + projectId; })) {
                        resolve(true);
                    }
                    else {
                        resolve(false);
                    }
                }, function (err) {
                    reject(err);
                });
            });
        });
    };
    /**
     * This function provides an authentication entry point to the GD API. It is needed to authenticate
     * by calling this function prior any other API calls. After providing valid credentials
     * every subsequent API call in a current session will be authenticated.
     *
     * @method login
     * @param {String} username
     * @param {String} password
     */
    UserModule.prototype.login = function (username, password) {
        return this.xhr
            .post("/gdc/account/login", {
            body: JSON.stringify({
                postUserLogin: {
                    login: username,
                    password: password,
                    remember: 1,
                    captcha: "",
                    verifyCaptcha: "",
                },
            }),
        })
            .then(function (r) { return r.getData(); });
    };
    /**
     * This function provides an authentication entry point to the GD API via SSO
     * https://help.gooddata.com/display/developer/GoodData+PGP+Single+Sign-On
     *
     * @method loginSso
     * @param {String} encryptedClaims PGP message
     * @param {String} ssoProvider
     * @param {String} targetUrl
     */
    UserModule.prototype.loginSso = function (encryptedClaims, ssoProvider, targetUrl) {
        return this.xhr.post("/gdc/account/customerlogin", {
            data: {
                pgpLoginRequest: {
                    targetUrl: targetUrl,
                    ssoProvider: ssoProvider,
                    encryptedClaims: encryptedClaims,
                },
            },
        });
    };
    /**
     * Logs out current user
     * @method logout
     */
    UserModule.prototype.logout = function () {
        var _this = this;
        return this.isLoggedIn().then(function (loggedIn) {
            if (loggedIn) {
                return _this.xhr.get("/gdc/app/account/bootstrap").then(function (result) {
                    var data = result.getData();
                    var userUri = data.bootstrapResource.accountSetting.links.self;
                    var userId = userUri.match(/([^/]+)\/?$/)[1];
                    return _this.xhr.del("/gdc/account/login/" + userId);
                });
            }
            return Promise.resolve();
        }, function (err) { return Promise.reject(err); });
    };
    /**
     * Gets current user's profile
     * @method getCurrentProfile
     * @return {Promise} Resolves with account setting object
     */
    UserModule.prototype.getCurrentProfile = function () {
        return this.xhr.get("/gdc/account/profile/current").then(function (r) { return r.getData().accountSetting; });
    };
    /**
     * Gets user's regional number formatting configuration
     * @method getUserRegionalNumberFormatting
     * @param {String} userId - loginMD5
     * @return {Promise} Resolves with separators setting object
     */
    UserModule.prototype.getUserRegionalNumberFormatting = function (userId) {
        return this.xhr
            .getParsed("/gdc/account/profile/" + userId + "/settings/separators")
            .then(function (res) { return ({
            decimal: res.separators.decimal,
            thousand: res.separators.thousand,
        }); });
    };
    /**
     * Updates user's profile settings
     * @method updateProfileSettings
     * @param {String} profileId - User profile identifier
     * @param {Object} profileSetting
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    UserModule.prototype.updateProfileSettings = function (profileId, profileSetting) {
        // TODO
        return this.xhr.put("/gdc/account/profile/" + profileId + "/settings", {
            body: profileSetting,
        });
    };
    /**
     * Returns info about currently logged in user from bootstrap resource
     * @method getAccountInfo
     */
    UserModule.prototype.getAccountInfo = function () {
        return this.xhr.get("/gdc/app/account/bootstrap").then(function (result) {
            var bootstrapResource = result.getData().bootstrapResource;
            return {
                login: bootstrapResource.accountSetting.login,
                loginMD5: bootstrapResource.current.loginMD5,
                firstName: bootstrapResource.accountSetting.firstName,
                lastName: bootstrapResource.accountSetting.lastName,
                organizationName: bootstrapResource.settings.organizationName,
                profileUri: bootstrapResource.accountSetting.links.self,
            };
        });
    };
    /**
     * Gets user configs including user specific feature flags
     *
     * @param {String} userId - A user identifier
     * @return {IUserConfigsSettingItem[]} An array of user configs setting item
     */
    UserModule.prototype.getUserConfigs = function (userId) {
        return this.xhr.get("/gdc/account/profile/" + userId + "/config").then(function (apiResponse) {
            var userConfigs = apiResponse.getData();
            var items = userConfigs.settings.items;
            return items || [];
        });
    };
    /**
     * Gets user specific feature flags
     *
     * @param {String} userId - A user identifier
     * @param {String[]} sourceFilter - Optional list of setting item sources to include. Defaults to including everything
     * @return {IFeatureFlags} Hash table of feature flags and their values where feature flag is the key
     */
    UserModule.prototype.getUserFeatureFlags = function (userId, sourceFilter) {
        return this.getUserConfigs(userId).then(function (settingItems) {
            var filteredSettingItems = sourceFilter
                ? settingItems.filter(function (item) { return sourceFilter.includes(item.settingItem.source); })
                : settingItems;
            var featureFlags = {};
            filteredSettingItems.forEach(function (settingItem) {
                featureFlags[settingItem.settingItem.key] = parseSettingItemValue(settingItem.settingItem.value);
            });
            return featureFlags;
        });
    };
    /**
     * Returns the feature flags valid for the currently logged in user.
     * @method getFeatureFlags
     */
    UserModule.prototype.getFeatureFlags = function () {
        return this.xhr
            .get("/gdc/app/account/bootstrap")
            .then(function (r) { return r.getData(); })
            .then(function (result) { return result.bootstrapResource.current.featureFlags; });
    };
    /**
     * Returns bootstrap resource for the currently logged in user.
     */
    UserModule.prototype.getBootstrapResource = function (options) {
        if (options === void 0) { options = {}; }
        var projectId = options.projectId, productId = options.productId, clientId = options.clientId;
        var uri = "/gdc/app/account/bootstrap";
        if (projectId) {
            uri = uri + "?projectUri=/gdc/projects/" + projectId;
        }
        else if (productId && clientId) {
            // projectId can be replaced by combination of productId + clientId
            uri = uri + "?projectUri=/gdc/projects/client:" + productId + ":" + clientId;
        }
        return this.xhr.getParsed(uri);
    };
    /**
     * Initiates SPI SAML SSO.
     *
     * @param relayState URL of the page where the user is redirected after a successful login
     */
    UserModule.prototype.initiateSamlSso = function (relayState) {
        /*
         * make sure code does not try to get new token before initiating the SAML; the token request would
         * fail and prevent the samlrequest call; there is no point in getting token anyway because it is just
         * now that the client is initializing the session security context.
         */
        this.xhr.ensureNoLeadingTokenRequest();
        return this.xhr
            .get("/gdc/account/samlrequest?" + qs.stringify({ relayState: relayState }))
            .then(function (data) { return data.getData(); })
            .then(function (response) {
            var loginUrl = response.samlRequests.items[0].samlRequest.loginUrl;
            window.location.assign(loginUrl);
        });
    };
    return UserModule;
}());
export { UserModule };
//# sourceMappingURL=user.js.map