// (C) 2020-2021 GoodData Corporation
/* *
 * (c) 2010-2019 Torstein Honsi
 *
 * Source: https://github.com/highcharts/highcharts/blob/v7.1.1/js/parts-more/BubbleSeries.js
 * License: www.highcharts.com/license
 *
 * Modified by Lan Huynh to to support
 *  - Set default size for bubbles in bubble chart where size value is not provided
 *  - Fix bubbles is not rendered with min/max config
 */
import isNil from "lodash/isNil";
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function renderBubbles(HighchartsInstance) {
    var wrap = HighchartsInstance.wrap;
    var pInt = HighchartsInstance.pInt;
    var arrayMax = HighchartsInstance.arrayMax;
    var arrayMin = HighchartsInstance.arrayMin;
    var pick = HighchartsInstance.pick;
    var isNumber = HighchartsInstance.isNumber;
    if (HighchartsInstance.seriesTypes.bubble) {
        // Set default size for bubbles in bubble chart where size value is not provided
        wrap(HighchartsInstance.seriesTypes.bubble.prototype, "getRadius", function (proceed, zMin, zMax, minSize, maxSize, value) {
            var radius = proceed.apply(this, [zMin, zMax, minSize, maxSize, value]);
            if (isNaN(value) && isNil(radius)) {
                // Relative size, a number between 0 and 1 (default is 0.5)
                // Use Math.sqrt for bubble is sized by area
                radius = Math.ceil(minSize + Math.sqrt(0.5) * (maxSize - minSize)) / 2;
            }
            return radius;
        });
        // #SD-479 fix bubbles is not rendered with min/max config
        wrap(HighchartsInstance.Axis.prototype, "beforePadding", function (_proceed) {
            // eslint-disable-next-line @typescript-eslint/no-this-alias
            var axis = this;
            var axisLength = this.len;
            var chart = this.chart;
            var isXAxis = this.isXAxis;
            var min = this.min;
            var range = this.max - min;
            var activeSeries = [];
            var pxMin = 0;
            var pxMax = axisLength;
            var transA = axisLength / range;
            var zMin = Number.MAX_VALUE;
            var zMax = -Number.MAX_VALUE;
            function translateSizeToPixel(size) {
                var smallestSize = Math.min(chart.plotWidth, chart.plotHeight);
                var isPercent = typeof size === "string" ? /%$/.test(size) : false;
                var pxSize = pInt(size);
                return isPercent ? (smallestSize * pxSize) / 100 : pxSize;
            }
            // Handle padding on the second pass, or on redraw
            this.series.forEach(function (series) {
                var seriesOptions = series.options;
                if (series.bubblePadding && (series.visible || !chart.options.chart.ignoreHiddenSeries)) {
                    // Correction for #1673
                    axis.allowZoomOutside = true;
                    // Cache it
                    activeSeries.push(series);
                    if (isXAxis) {
                        // because X axis is evaluated first
                        // For each series, translate the size extremes to pixel values
                        var minSize = translateSizeToPixel(seriesOptions.minSize);
                        var maxSize = translateSizeToPixel(seriesOptions.maxSize);
                        series.minPxSize = minSize;
                        // Prioritize min size if conflict to make sure bubbles are
                        // always visible. #5873
                        series.maxPxSize = Math.max(maxSize, minSize);
                        // Find the min and max Z
                        var zData = series.zData.filter(isNumber);
                        if (zData.length) {
                            // #1735
                            zMin = pick(seriesOptions.zMin, Math.min(zMin, Math.max(arrayMin(zData), seriesOptions.displayNegative === false
                                ? seriesOptions.zThreshold
                                : -Number.MAX_VALUE)));
                            zMax = pick(seriesOptions.zMax, Math.max(zMax, arrayMax(zData)));
                        }
                    }
                }
            });
            activeSeries.forEach(function (series) {
                var dataKey = isXAxis ? "xData" : "yData";
                var data = series[dataKey];
                var i = data.length;
                if (isXAxis) {
                    series.getRadii(zMin, zMax, series);
                }
                if (range > 0) {
                    while (i--) {
                        if (isNumber(data[i]) && axis.dataMin <= data[i] && data[i] <= axis.dataMax) {
                            var radius = series.radii[i];
                            pxMin = Math.min((data[i] - min) * transA - radius, pxMin);
                            pxMax = Math.max((data[i] - min) * transA + radius, pxMax);
                        }
                    }
                }
            });
            // Apply the padding to the min and max properties
            if (activeSeries.length && range > 0 && !this.isLog) {
                pxMax -= axisLength;
                // Note for Highchart upgrading later:
                //  - Modified the calculation of transA only
                //  - And transform from javascript to typescripts
                var pxRange = Math.abs(Math.max(0, pxMin) - Math.min(pxMax, axisLength));
                transA *= (axisLength + pxRange) / axisLength;
                if (pick(axis.options.min, axis.userMin) === undefined) {
                    axis.min += pxMin / transA;
                }
                if (pick(axis.options.max, axis.userMax) === undefined) {
                    axis.max += pxMax / transA;
                }
            }
        });
    }
}
//# sourceMappingURL=renderBubbles.js.map