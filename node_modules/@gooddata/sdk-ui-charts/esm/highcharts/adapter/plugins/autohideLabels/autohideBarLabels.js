// (C) 2007-2020 GoodData Corporation
import sortBy from "lodash/sortBy";
import { isStacked, toNeighbors, isIntersecting, getShapeAttributes, getAxisRangeForAxes, getDataPointsOfVisibleSeries, } from "../../../chartTypes/_chartCreators/helpers";
import { hideDataLabels, hideDataLabel, hasDataLabel, getDataLabelAttributes, showDataLabelInAxisRange, showStackLabelInAxisRange, getShapeVisiblePart, } from "../../../chartTypes/_chartCreators/dataLabelsHelpers";
var toggleStackedChartLabels = function (visiblePoints, axisRangeForAxes) {
    var intersectionFound = visiblePoints.filter(hasDataLabel).some(function (point) {
        var dataLabel = point.dataLabel, shapeArgs = point.shapeArgs;
        if (dataLabel && shapeArgs) {
            var dataLabelAttr = getDataLabelAttributes(point);
            var shapeAttr = getShapeAttributes(point);
            return dataLabelAttr.height + 2 * dataLabel.padding > shapeAttr.height;
        }
        return false;
    });
    if (intersectionFound) {
        hideDataLabels(visiblePoints);
    }
    else {
        visiblePoints.filter(hasDataLabel).forEach(function (point) {
            var dataLabel = point.dataLabel, shapeArgs = point.shapeArgs, chart = point.series.chart;
            if (dataLabel && shapeArgs) {
                var dataLabelAttr = getDataLabelAttributes(point);
                var shapeAttr = getShapeAttributes(point);
                var labelWidth = dataLabelAttr.width + 2 * dataLabel.padding;
                var shapeWidth = getShapeVisiblePart(shapeArgs, chart, shapeAttr.width);
                var foundIntersection = labelWidth > shapeWidth;
                // switch axis for bar chart
                return foundIntersection
                    ? hideDataLabel(point)
                    : showStackLabelInAxisRange(point, axisRangeForAxes);
            }
            return null;
        });
    }
};
var toggleNonStackedChartLabels = function (points, axisRangeForAxes, shouldCheckShapeIntersection) {
    if (shouldCheckShapeIntersection === void 0) { shouldCheckShapeIntersection = false; }
    var sortedPoints = sortBy(points, function (a, b) {
        var firstLabelAttr = getDataLabelAttributes(a);
        var nextLabelAttr = getDataLabelAttributes(b);
        return firstLabelAttr.y - nextLabelAttr.y;
    });
    var neighbors = toNeighbors(sortedPoints);
    var intersectionFound = neighbors.some(function (_a) {
        var firstPoint = _a[0], nextPoint = _a[1];
        var firstDataLabelAttr = getDataLabelAttributes(firstPoint);
        var nextDataLabelAttr = getDataLabelAttributes(nextPoint);
        if (shouldCheckShapeIntersection) {
            var firstShapeAttr = getShapeAttributes(firstPoint);
            var nextShapeAttr = getShapeAttributes(nextPoint);
            return (isIntersecting(firstDataLabelAttr, nextDataLabelAttr) ||
                isIntersecting(firstDataLabelAttr, nextShapeAttr) ||
                isIntersecting(firstShapeAttr, nextDataLabelAttr));
        }
        return isIntersecting(firstDataLabelAttr, nextDataLabelAttr);
    });
    if (intersectionFound) {
        hideDataLabels(points);
    }
    else {
        points.forEach(function (point) { return showDataLabelInAxisRange(point, point.y, axisRangeForAxes); });
    }
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var autohideBarLabels = function (chart) {
    var isStackedChart = isStacked(chart);
    var visiblePoints = getDataPointsOfVisibleSeries(chart);
    var axisRangeForAxes = getAxisRangeForAxes(chart);
    if (isStackedChart) {
        toggleStackedChartLabels(visiblePoints, axisRangeForAxes);
    }
    else {
        toggleNonStackedChartLabels(visiblePoints, axisRangeForAxes, true);
    }
};
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var handleBarLabelsOutsideChart = function (chart) {
    var visiblePoints = getDataPointsOfVisibleSeries(chart);
    var axisRangeForAxes = getAxisRangeForAxes(chart);
    visiblePoints.forEach(function (point) {
        if (!isStacked(chart)) {
            showDataLabelInAxisRange(point, point.y, axisRangeForAxes);
        }
        else {
            // fix for HCH bug for negative stack labels
            showStackLabelInAxisRange(point, axisRangeForAxes);
        }
    });
};
//# sourceMappingURL=autohideBarLabels.js.map