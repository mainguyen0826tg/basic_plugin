import { __assign, __awaiter, __extends, __generator } from "tslib";
// (C) 2019 GoodData Corporation
import React from "react";
import noop from "lodash/noop";
import hoistNonReactStatics from "hoist-non-react-statics";
import { CancelledSdkError, convertError, createExportErrorFunction, createExportFunction, isCancelError, makeCancelable, } from "../base";
/**
 * A React HOC responsible for orchestrating resolution of a data promise (e.g. data to load).
 *
 * This component offers more flexibility in regards to how to obtain the data - all that is encapsulated
 * into a promise of data. For most use cases, the withExecution HOC is a better fit.
 *
 * @internal
 */
export function withExecutionLoading(params) {
    var promiseFactory = params.promiseFactory, _a = params.loadOnMount, loadOnMount = _a === void 0 ? true : _a, _b = params.events, events = _b === void 0 ? {} : _b, _c = params.shouldRefetch, shouldRefetch = _c === void 0 ? function () { return false; } : _c, window = params.window, exportTitle = params.exportTitle;
    return function (WrappedComponent) {
        var WithLoading = /** @class */ (function (_super) {
            __extends(WithLoading, _super);
            function WithLoading(props) {
                var _this = _super.call(this, props) || this;
                _this.isWithExecutionLoadingUnmounted = false;
                _this.state = {
                    error: undefined,
                    isLoading: false,
                    result: undefined,
                };
                _this.fetch = _this.fetch.bind(_this);
                _this.startLoading = _this.startLoading.bind(_this);
                _this.setError = _this.setError.bind(_this);
                _this.setResult = _this.setResult.bind(_this);
                _this.getEvents = _this.getEvents.bind(_this);
                return _this;
            }
            WithLoading.prototype.getEvents = function () {
                var _events = typeof events === "function" ? events(this.props) : events;
                var _a = _events.onError, onError = _a === void 0 ? noop : _a, _b = _events.onLoadingChanged, onLoadingChanged = _b === void 0 ? noop : _b, _c = _events.onLoadingFinish, onLoadingFinish = _c === void 0 ? noop : _c, _d = _events.onLoadingStart, onLoadingStart = _d === void 0 ? noop : _d, _e = _events.onExportReady, onExportReady = _e === void 0 ? noop : _e;
                return {
                    onError: onError,
                    onLoadingChanged: onLoadingChanged,
                    onLoadingFinish: onLoadingFinish,
                    onLoadingStart: onLoadingStart,
                    onExportReady: onExportReady,
                };
            };
            WithLoading.prototype.startLoading = function () {
                var _a = this.getEvents(), onLoadingStart = _a.onLoadingStart, onLoadingChanged = _a.onLoadingChanged;
                onLoadingStart(this.props);
                onLoadingChanged(true, this.props);
                this.effectiveProps = undefined;
                this.setState(function (state) { return (__assign(__assign({}, state), { isLoading: true, error: undefined, result: undefined })); });
            };
            WithLoading.prototype.setError = function (error) {
                var _a = this.getEvents(), onError = _a.onError, onLoadingChanged = _a.onLoadingChanged, onExportReady = _a.onExportReady;
                onError(error, this.props);
                onLoadingChanged(false, this.props);
                onExportReady(createExportErrorFunction(error));
                this.setState(function (state) { return (__assign(__assign({}, state), { isLoading: false, error: error })); });
            };
            WithLoading.prototype.setResult = function (result) {
                var _a = this.getEvents(), onLoadingFinish = _a.onLoadingFinish, onLoadingChanged = _a.onLoadingChanged, onExportReady = _a.onExportReady;
                var title = typeof exportTitle === "function" ? exportTitle(this.props) : exportTitle;
                onLoadingFinish(result, this.props);
                onLoadingChanged(false, this.props);
                onExportReady(createExportFunction(result.result(), title));
                this.effectiveProps = this.props;
                this.setState(function (state) { return (__assign(__assign({}, state), { isLoading: false, error: undefined, result: result })); });
            };
            WithLoading.prototype.fetch = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var readWindow, promise, result, err_1, sdkError;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (this.cancelablePromise) {
                                    this.cancelablePromise.cancel();
                                    // On refetch, when cancelablePromise was not fulfilled, throw cancel error immediately
                                    if (!this.cancelablePromise.getHasFulfilled()) {
                                        this.setError(new CancelledSdkError());
                                    }
                                }
                                this.startLoading();
                                readWindow = typeof window === "function" ? window(this.props) : window;
                                promise = promiseFactory(this.props, readWindow);
                                this.cancelablePromise = makeCancelable(promise);
                                _a.label = 1;
                            case 1:
                                _a.trys.push([1, 3, , 4]);
                                return [4 /*yield*/, this.cancelablePromise.promise];
                            case 2:
                                result = _a.sent();
                                if (!this.isWithExecutionLoadingUnmounted) {
                                    this.setResult(result);
                                }
                                return [3 /*break*/, 4];
                            case 3:
                                err_1 = _a.sent();
                                // We throw cancel error immediately on refetch, when cancelablePromise was not fulfilled,
                                // but CancelablePromise throw cancel error after promise resolution, so here
                                // we don't care about it anymore.
                                if (!this.isWithExecutionLoadingUnmounted && !isCancelError(err_1)) {
                                    sdkError = convertError(err_1);
                                    this.setError(sdkError);
                                }
                                return [3 /*break*/, 4];
                            case 4: return [2 /*return*/];
                        }
                    });
                });
            };
            WithLoading.prototype.isStaleResult = function () {
                return this.effectiveProps !== undefined && shouldRefetch(this.props, this.effectiveProps);
            };
            WithLoading.prototype.componentDidMount = function () {
                this.isWithExecutionLoadingUnmounted = false;
                var _loadOnMount = typeof loadOnMount === "function" ? loadOnMount(this.props) : loadOnMount;
                if (_loadOnMount) {
                    this.fetch();
                }
            };
            WithLoading.prototype.componentDidUpdate = function (prevProps) {
                if (shouldRefetch(prevProps, this.props)) {
                    this.fetch();
                }
            };
            WithLoading.prototype.componentWillUnmount = function () {
                this.isWithExecutionLoadingUnmounted = true;
                if (this.cancelablePromise) {
                    this.cancelablePromise.cancel();
                    if (!this.cancelablePromise.getHasFulfilled()) {
                        this.setError(new CancelledSdkError());
                    }
                }
            };
            WithLoading.prototype.render = function () {
                var _a = this.state, result = _a.result, isLoading = _a.isLoading, error = _a.error;
                if (this.isStaleResult()) {
                    /*
                     * When props update, this render will be called first and state will still contain
                     * data calculated thus far. After the render, the componentDidUpdate will test whether
                     * data reload is needed and if so trigger it.
                     *
                     * The problem with this is, that the child function would be called once with stale
                     * data. This can lead to problems in expectations - the child function may work with
                     * assumptions that the result is always up to date and try access data that is just not
                     * there yet.
                     */
                    var executionResult_1 = {
                        result: undefined,
                        isLoading: true,
                        error: undefined,
                        reload: this.fetch,
                    };
                    return React.createElement(WrappedComponent, __assign({}, this.props, executionResult_1));
                }
                var executionResult = {
                    result: result,
                    isLoading: isLoading,
                    error: error,
                    reload: this.fetch,
                };
                return React.createElement(WrappedComponent, __assign({}, this.props, executionResult));
            };
            return WithLoading;
        }(React.Component));
        hoistNonReactStatics(WithLoading, WrappedComponent);
        return WithLoading;
    };
}
//# sourceMappingURL=withExecutionLoading.js.map