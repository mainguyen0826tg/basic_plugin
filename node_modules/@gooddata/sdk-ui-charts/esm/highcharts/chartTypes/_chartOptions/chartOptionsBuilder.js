import { __assign } from "tslib";
import invariant from "ts-invariant";
import { BucketNames, DataViewFacade } from "@gooddata/sdk-ui";
import { ViewByAttributesLimit } from "../../../interfaces";
import { PARENT_ATTRIBUTE_INDEX, PRIMARY_ATTRIBUTE_INDEX, STACK_BY_DIMENSION_INDEX, VIEW_BY_DIMENSION_INDEX, } from "../../constants/dimensions";
import { findAttributeInDimension, findMeasureGroupInDimensions } from "../_util/executionResultHelper";
import { isAreaChart, isBubbleChart, isChartSupported, isComboChart, isHeatmap, isOneOfTypes, isScatterPlot, isTreemap, stringifyChartTypes, unwrap, } from "../_util/common";
import { setMeasuresToSecondaryAxis } from "./dualAxis";
import { canComboChartBeStackedInPercent, getComboChartSeries, getComboChartStackingConfig, } from "../comboChart/comboChartOptions";
import { getCategoriesForTwoAttributes } from "./extendedStackingChartOptions";
import { ColorFactory } from "./colorFactory";
import { getChartProperties } from "../_chartCreators/helpers";
import { multiMeasuresAlternatingTypes, sortedByMeasureTypes, unsupportedStackingTypes, } from "./chartCapabilities";
import cloneDeep from "lodash/cloneDeep";
import isEmpty from "lodash/isEmpty";
import isUndefined from "lodash/isUndefined";
import without from "lodash/without";
import { getSeries } from "./chartSeries";
import { buildTooltipFactory, generateTooltipHeatmapFn, generateTooltipXYFn, getTooltipFactory, } from "./chartTooltips";
import { getDrillableSeries } from "./chartDrilling";
import { assignYAxes, getXAxes, getYAxes } from "./chartAxes";
var isAreaChartStackingEnabled = function (options) {
    var type = options.type, stacking = options.stacking, stackMeasures = options.stackMeasures;
    if (!isAreaChart(type)) {
        return false;
    }
    if (isUndefined(stackMeasures)) {
        return stacking || isUndefined(stacking);
    }
    return stackMeasures;
};
function getCategories(type, measureGroup, viewByAttribute, stackByAttribute) {
    if (isHeatmap(type)) {
        return [
            viewByAttribute ? viewByAttribute.items.map(function (item) { return item.attributeHeaderItem.name; }) : [""],
            stackByAttribute
                ? stackByAttribute.items.map(function (item) { return item.attributeHeaderItem.name; })
                : [""],
        ];
    }
    if (isScatterPlot(type)) {
        return stackByAttribute
            ? stackByAttribute.items.map(function (item) { return item.attributeHeaderItem.name; })
            : [""];
    }
    // Categories make up bar/slice labels in charts. These usually match view by attribute values.
    // Measure only pie or treemap charts get categories from measure names
    if (viewByAttribute) {
        return viewByAttribute.items.map(function (_a) {
            var attributeHeaderItem = _a.attributeHeaderItem;
            return attributeHeaderItem.name;
        });
    }
    if (isOneOfTypes(type, multiMeasuresAlternatingTypes)) {
        // Pie or Treemap chart with measures only (no viewByAttribute) needs to list
        return measureGroup.items.map(function (wrappedMeasure) { return unwrap(wrappedMeasure).name; });
        // Pie chart categories are later sorted by seriesItem pointValue
    }
    return [];
}
function getStackingConfig(stackByAttribute, options) {
    var type = options.type, stackMeasures = options.stackMeasures, stackMeasuresToPercent = options.stackMeasuresToPercent;
    var stackingValue = stackMeasuresToPercent ? "percent" : "normal";
    var supportsStacking = !isOneOfTypes(type, unsupportedStackingTypes);
    /**
     * we should enable stacking for one of the following cases :
     * 1) If stackby attribute have been set and chart supports stacking
     * 2) If chart is an area chart and stacking is enabled (stackBy attribute doesn't matter)
     * 3) If chart is column/bar chart and 'Stack Measures' is enabled
     */
    var isStackByChart = stackByAttribute && supportsStacking;
    var isAreaChartWithEnabledStacking = isAreaChartStackingEnabled(options);
    if (isStackByChart || isAreaChartWithEnabledStacking || stackMeasures || stackMeasuresToPercent) {
        return stackingValue;
    }
    return null; // no stacking
}
export var HEAT_MAP_CATEGORIES_COUNT = 7;
export var HIGHCHARTS_PRECISION = 15;
export var DEFAULT_HEATMAP_COLOR_INDEX = 1;
export function getHeatmapDataClasses(series, colorStrategy) {
    var _a, _b;
    if (series === void 0) { series = []; }
    var values = without(((_b = (_a = series[0]) === null || _a === void 0 ? void 0 : _a.data) !== null && _b !== void 0 ? _b : []).map(function (item) { return item.value; }), null, undefined, NaN);
    if (isEmpty(values)) {
        return [];
    }
    var min = Math.min.apply(Math, values);
    var max = Math.max.apply(Math, values);
    var safeMin = parseFloat(Number(min).toPrecision(HIGHCHARTS_PRECISION));
    var safeMax = parseFloat(Number(max).toPrecision(HIGHCHARTS_PRECISION));
    var dataClasses = [];
    if (min === max) {
        dataClasses.push({
            from: min,
            to: max,
            color: colorStrategy.getColorByIndex(DEFAULT_HEATMAP_COLOR_INDEX),
        });
    }
    else {
        var step = (safeMax - safeMin) / HEAT_MAP_CATEGORIES_COUNT;
        var currentSum = safeMin;
        for (var i = 0; i < HEAT_MAP_CATEGORIES_COUNT; i += 1) {
            dataClasses.push({
                from: currentSum,
                to: i === HEAT_MAP_CATEGORIES_COUNT - 1 ? safeMax : currentSum + step,
                color: colorStrategy.getColorByIndex(i),
            });
            currentSum += step;
        }
    }
    return dataClasses;
}
export function getDefaultTreemapAttributes(dv) {
    var dimensions = dv.meta().dimensions();
    var attributeHeaderItems = dv.meta().attributeHeaders();
    var viewByAttribute = findAttributeInDimension(dimensions[STACK_BY_DIMENSION_INDEX], attributeHeaderItems[STACK_BY_DIMENSION_INDEX]);
    var stackByAttribute = findAttributeInDimension(dimensions[STACK_BY_DIMENSION_INDEX], attributeHeaderItems[STACK_BY_DIMENSION_INDEX], 1);
    if (!viewByAttribute) {
        viewByAttribute = findAttributeInDimension(dimensions[VIEW_BY_DIMENSION_INDEX], attributeHeaderItems[VIEW_BY_DIMENSION_INDEX]);
    }
    return {
        viewByAttribute: viewByAttribute,
        stackByAttribute: stackByAttribute,
    };
}
export function getTreemapAttributes(dv) {
    if (!dv.def().hasBuckets()) {
        // without mdObject cant distinguish 1M 1Vb 0Sb and 1M 0Vb 1Sb
        return getDefaultTreemapAttributes(dv);
    }
    var dimensions = dv.meta().dimensions();
    var attributeHeaderItems = dv.meta().attributeHeaders();
    if (dv.def().isBucketEmpty(BucketNames.SEGMENT)) {
        if (dv.def().isBucketEmpty(BucketNames.VIEW)) {
            return {
                viewByAttribute: null,
                stackByAttribute: null,
            };
        }
        return {
            viewByAttribute: findAttributeInDimension(dimensions[VIEW_BY_DIMENSION_INDEX], attributeHeaderItems[VIEW_BY_DIMENSION_INDEX]),
            stackByAttribute: null,
        };
    }
    if (dv.def().isBucketEmpty(BucketNames.VIEW)) {
        return {
            viewByAttribute: null,
            stackByAttribute: findAttributeInDimension(dimensions[VIEW_BY_DIMENSION_INDEX], attributeHeaderItems[VIEW_BY_DIMENSION_INDEX]),
        };
    }
    return {
        viewByAttribute: findAttributeInDimension(dimensions[STACK_BY_DIMENSION_INDEX], attributeHeaderItems[STACK_BY_DIMENSION_INDEX]),
        stackByAttribute: findAttributeInDimension(dimensions[STACK_BY_DIMENSION_INDEX], attributeHeaderItems[STACK_BY_DIMENSION_INDEX], 1),
    };
}
function defaultChartedAttributeDiscovery(dv) {
    var attributeHeaderItems = dv.meta().attributeHeaders();
    var dimensions = dv.meta().dimensions();
    var isViewByTwoAttributes = attributeHeaderItems[VIEW_BY_DIMENSION_INDEX] &&
        attributeHeaderItems[VIEW_BY_DIMENSION_INDEX].length === ViewByAttributesLimit;
    var viewByParentAttribute;
    var viewByAttribute = findAttributeInDimension(dimensions[VIEW_BY_DIMENSION_INDEX], attributeHeaderItems[VIEW_BY_DIMENSION_INDEX], isViewByTwoAttributes ? PRIMARY_ATTRIBUTE_INDEX : undefined);
    var stackByAttribute = findAttributeInDimension(dimensions[STACK_BY_DIMENSION_INDEX], attributeHeaderItems[STACK_BY_DIMENSION_INDEX]);
    if (isViewByTwoAttributes) {
        viewByParentAttribute = findAttributeInDimension(dimensions[VIEW_BY_DIMENSION_INDEX], attributeHeaderItems[VIEW_BY_DIMENSION_INDEX], PARENT_ATTRIBUTE_INDEX);
    }
    return {
        viewByAttribute: viewByAttribute,
        viewByParentAttribute: viewByParentAttribute,
        stackByAttribute: stackByAttribute,
        isViewByTwoAttributes: isViewByTwoAttributes,
    };
}
function chartedAttributeDiscovery(dv, chartType) {
    if (isTreemap(chartType)) {
        return getTreemapAttributes(dv);
    }
    return defaultChartedAttributeDiscovery(dv);
}
function getLegendLabel(type, viewByAttribute, stackByAttribute) {
    var _a, _b, _c;
    var legendLabel;
    if (isTreemap(type)) {
        legendLabel = (_a = viewByAttribute === null || viewByAttribute === void 0 ? void 0 : viewByAttribute.formOf) === null || _a === void 0 ? void 0 : _a.name;
    }
    else if (isOneOfTypes(type, sortedByMeasureTypes) && viewByAttribute) {
        legendLabel = (_b = viewByAttribute === null || viewByAttribute === void 0 ? void 0 : viewByAttribute.formOf) === null || _b === void 0 ? void 0 : _b.name;
    }
    else {
        legendLabel = (_c = stackByAttribute === null || stackByAttribute === void 0 ? void 0 : stackByAttribute.formOf) === null || _c === void 0 ? void 0 : _c.name;
    }
    return legendLabel;
}
export function getChartOptions(dataView, chartConfig, drillableItems, theme) {
    var _a, _b, _c;
    var dv = DataViewFacade.for(dataView);
    var dimensions = dv.meta().dimensions();
    var config = setMeasuresToSecondaryAxis(chartConfig, dv);
    invariant(config && isChartSupported(config.type), "config.type must be defined and match one of supported chart types: " + stringifyChartTypes() + ", got: " + config.type);
    var type = config.type, chart = config.chart;
    var _d = chartedAttributeDiscovery(dv, type), viewByAttribute = _d.viewByAttribute, viewByParentAttribute = _d.viewByParentAttribute, stackByAttribute = _d.stackByAttribute, _e = _d.isViewByTwoAttributes, isViewByTwoAttributes = _e === void 0 ? false : _e;
    var colorStrategy = ColorFactory.getColorStrategy(config.colorPalette, config.colorMapping, viewByAttribute, stackByAttribute, dv, type, theme);
    var gridEnabled = (_b = (_a = config === null || config === void 0 ? void 0 : config.grid) === null || _a === void 0 ? void 0 : _a.enabled) !== null && _b !== void 0 ? _b : true;
    var stacking = getStackingConfig(stackByAttribute, config);
    var measureGroup = findMeasureGroupInDimensions(dimensions);
    var xAxes = getXAxes(dv, config, measureGroup, viewByAttribute);
    var yAxes = getYAxes(dv, config, measureGroup, stackByAttribute);
    var seriesWithoutDrillability = getSeries(dv, measureGroup, viewByAttribute, stackByAttribute, type, colorStrategy, theme);
    var drillableSeries = getDrillableSeries(dv, seriesWithoutDrillability, drillableItems, [viewByAttribute, viewByParentAttribute], stackByAttribute, type);
    var series = assignYAxes(drillableSeries, yAxes);
    var categories = viewByParentAttribute
        ? getCategoriesForTwoAttributes(viewByAttribute, viewByParentAttribute)
        : getCategories(type, measureGroup, viewByAttribute, stackByAttribute);
    // Pie charts dataPoints are sorted by default by value in descending order
    if (isOneOfTypes(type, sortedByMeasureTypes)) {
        var dataPoints_1 = series[0].data;
        var indexSortOrder_1 = [];
        var sortedDataPoints = dataPoints_1
            .sort(function (pointDataA, pointDataB) {
            if (pointDataA.y === pointDataB.y) {
                return 0;
            }
            return pointDataB.y - pointDataA.y;
        })
            .map(function (dataPoint, dataPointIndex) {
            // Legend index equals original dataPoint index
            indexSortOrder_1.push(dataPoint.legendIndex);
            return __assign(__assign({}, dataPoint), { color: dataPoints_1[dataPointIndex].color, legendIndex: dataPointIndex });
        });
        // categories need to be sorted in exactly the same order as dataPoints
        categories = categories.map(function (_category, dataPointIndex) { return categories[indexSortOrder_1[dataPointIndex]]; });
        series[0].data = sortedDataPoints;
    }
    var colorAssignments = colorStrategy.getColorAssignment();
    var colorPalette = config.colorPalette;
    var _f = getChartProperties(config, type), xAxisProps = _f.xAxisProps, yAxisProps = _f.yAxisProps, secondary_xAxisProps = _f.secondary_xAxisProps, secondary_yAxisProps = _f.secondary_yAxisProps;
    if (isComboChart(type)) {
        var comboSeries = getComboChartSeries(config, measureGroup, series, dv);
        var canStackInPercent = canComboChartBeStackedInPercent(comboSeries);
        return {
            type: type,
            xAxes: xAxes,
            yAxes: yAxes,
            stacking: getComboChartStackingConfig(config, comboSeries, stacking),
            legendLayout: config.legendLayout || "horizontal",
            actions: {
                tooltip: buildTooltipFactory(viewByAttribute, type, __assign(__assign({}, config), { stackMeasuresToPercent: config.stackMeasuresToPercent && canStackInPercent })),
            },
            grid: {
                enabled: gridEnabled,
            },
            data: {
                series: comboSeries,
                categories: categories,
            },
            xAxisProps: xAxisProps,
            yAxisProps: yAxisProps,
            secondary_yAxisProps: secondary_yAxisProps,
            colorAssignments: colorAssignments,
            colorPalette: colorPalette,
            forceDisableDrillOnAxes: chartConfig.forceDisableDrillOnAxes,
        };
    }
    if (isScatterPlot(type)) {
        var _g = getChartProperties(config, type), xAxisProps_1 = _g.xAxisProps, yAxisProps_1 = _g.yAxisProps;
        var measures = [
            measureGroup.items[0] ? measureGroup.items[0] : null,
            measureGroup.items[1] ? measureGroup.items[1] : null,
        ];
        if (dv.def().isBucketEmpty(BucketNames.MEASURES)) {
            measures = [null, measureGroup.items[0] ? measureGroup.items[0] : null];
        }
        return {
            type: type,
            stacking: stacking,
            legendLayout: "horizontal",
            yAxes: yAxes,
            xAxes: xAxes,
            data: {
                series: series,
                categories: categories,
            },
            actions: {
                tooltip: generateTooltipXYFn(measures, stackByAttribute, config),
            },
            grid: {
                enabled: gridEnabled,
            },
            xAxisProps: xAxisProps_1,
            yAxisProps: yAxisProps_1,
            colorAssignments: colorAssignments,
            colorPalette: colorPalette,
            forceDisableDrillOnAxes: chartConfig.forceDisableDrillOnAxes,
        };
    }
    if (isHeatmap(type)) {
        var _h = getChartProperties(config, type), xAxisProps_2 = _h.xAxisProps, yAxisProps_2 = _h.yAxisProps;
        return {
            type: type,
            stacking: null,
            legendLayout: "horizontal",
            legendLabel: (_c = unwrap(measureGroup === null || measureGroup === void 0 ? void 0 : measureGroup.items[0])) === null || _c === void 0 ? void 0 : _c.name,
            title: {
                x: viewByAttribute ? viewByAttribute.name : "",
                y: stackByAttribute ? stackByAttribute.name : "",
                format: unwrap(measureGroup.items[0]).format,
            },
            xAxes: xAxes,
            yAxes: yAxes,
            data: {
                series: series,
                categories: categories,
            },
            actions: {
                tooltip: generateTooltipHeatmapFn(viewByAttribute, stackByAttribute, config),
            },
            grid: {
                enabled: false,
            },
            colorAxis: {
                dataClasses: getHeatmapDataClasses(series, colorStrategy),
            },
            xAxisProps: xAxisProps_2,
            yAxisProps: yAxisProps_2,
            colorAssignments: colorAssignments,
            colorPalette: colorPalette,
            forceDisableDrillOnAxes: chartConfig.forceDisableDrillOnAxes,
        };
    }
    if (isBubbleChart(type)) {
        var measures = [];
        var measureGroupCopy = cloneDeep(measureGroup);
        var _j = getChartProperties(config, type), xAxisProps_3 = _j.xAxisProps, yAxisProps_3 = _j.yAxisProps;
        if (!dv.def().isBucketEmpty(BucketNames.MEASURES)) {
            measures.push(measureGroup.items[0] ? measureGroupCopy.items.shift() : null);
        }
        else {
            measures.push(null);
        }
        if (!dv.def().isBucketEmpty(BucketNames.SECONDARY_MEASURES)) {
            measures.push(measureGroup.items[0] ? measureGroupCopy.items.shift() : null);
        }
        else {
            measures.push(null);
        }
        if (!dv.def().isBucketEmpty(BucketNames.TERTIARY_MEASURES)) {
            measures.push(measureGroup.items[0] ? measureGroupCopy.items.shift() : null);
        }
        else {
            measures.push(null);
        }
        return {
            type: type,
            stacking: stacking,
            hasViewByAttribute: Boolean(stackByAttribute),
            legendLayout: "horizontal",
            legendLabel: getLegendLabel(type, viewByAttribute, stackByAttribute),
            yAxes: yAxes,
            xAxes: xAxes,
            data: {
                series: series,
                categories: [[""]],
            },
            actions: {
                tooltip: generateTooltipXYFn(measures, stackByAttribute, config),
            },
            grid: {
                enabled: gridEnabled,
            },
            xAxisProps: xAxisProps_3,
            yAxisProps: yAxisProps_3,
            colorAssignments: colorAssignments,
            colorPalette: colorPalette,
            forceDisableDrillOnAxes: chartConfig.forceDisableDrillOnAxes,
        };
    }
    var isDualAxis = yAxes.length === 2;
    var measure;
    /**
     * Because of the problem described in TNT-16, we decided to change the visual of the tooltip.
     * If the visualization contains stack by attribute, it is possible to have just one measure.
     * Therefore the first measure from measureGroup is used.
     */
    if (!dv.def().isBucketEmpty(BucketNames.MEASURES)) {
        measure = __assign({}, measureGroup.items[0]);
    }
    var tooltipFactory = getTooltipFactory(isViewByTwoAttributes, viewByAttribute, viewByParentAttribute, stackByAttribute, measure, config, isDualAxis);
    return {
        type: type,
        stacking: stacking,
        hasStackByAttribute: Boolean(stackByAttribute),
        hasViewByAttribute: Boolean(viewByAttribute),
        legendLayout: config.legendLayout || "horizontal",
        legendLabel: getLegendLabel(type, viewByAttribute, stackByAttribute),
        xAxes: xAxes,
        yAxes: yAxes,
        data: {
            series: series,
            categories: categories,
        },
        actions: {
            tooltip: tooltipFactory,
        },
        grid: {
            enabled: gridEnabled,
        },
        xAxisProps: xAxisProps,
        yAxisProps: yAxisProps,
        secondary_xAxisProps: secondary_xAxisProps,
        secondary_yAxisProps: secondary_yAxisProps,
        colorAssignments: colorAssignments,
        colorPalette: colorPalette,
        isViewByTwoAttributes: isViewByTwoAttributes,
        forceDisableDrillOnAxes: chartConfig.forceDisableDrillOnAxes,
        verticalAlign: chart === null || chart === void 0 ? void 0 : chart.verticalAlign,
    };
}
//# sourceMappingURL=chartOptionsBuilder.js.map