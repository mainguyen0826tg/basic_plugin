import { __assign, __extends } from "tslib";
// (C) 2007-2020 GoodData Corporation
import invariant from "ts-invariant";
import qs from "qs";
import range from "lodash/range";
import { ApiResponseError } from "../xhr";
import { convertExecutionToJson } from "./execute-afm.convert";
import { stringify } from "../utils/queryString";
export var DEFAULT_LIMIT = 1000;
/**
 * This interface represents error caused during second part of api execution (data fetching)
 * and contains information about first execution part if that part was successful.
 *
 * @private
 * @internal
 */
var ApiExecutionResponseError = /** @class */ (function (_super) {
    __extends(ApiExecutionResponseError, _super);
    function ApiExecutionResponseError(error, executionResponse) {
        var _this = _super.call(this, error.message, error.response, error.responseBody) || this;
        _this.executionResponse = executionResponse;
        return _this;
    }
    return ApiExecutionResponseError;
}(ApiResponseError));
export { ApiExecutionResponseError };
var ExecuteAfmModule = /** @class */ (function () {
    function ExecuteAfmModule(xhr) {
        this.xhr = xhr;
    }
    /**
     * Execute AFM and fetch all data results
     *
     * @method executeAfm
     * @param {String} projectId - GD project identifier
     * @param {GdcExecuteAFM.IExecution} execution
     *
     * @returns {Promise<GdcExecution.IExecutionResponses>} Structure with `executionResponse` and `executionResult`
     */
    ExecuteAfmModule.prototype.executeAfm = function (projectId, execution) {
        var _this = this;
        var _a, _b, _c;
        validateNumOfDimensions((_c = (_b = (_a = execution.execution.resultSpec) === null || _a === void 0 ? void 0 : _a.dimensions) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0);
        return this.getExecutionResponse(projectId, execution).then(function (executionResponse) {
            return _this.getExecutionResult(executionResponse.links.executionResult)
                .then(function (executionResult) {
                return { executionResponse: executionResponse, executionResult: executionResult };
            })
                .catch(function (error) {
                throw new ApiExecutionResponseError(error, executionResponse);
            });
        });
    };
    /**
     * Execute AFM and return execution's response; the response describes dimensionality of the results and
     * includes link to poll for the results.
     *
     * @method getExecutionResponse
     * @param {string} projectId - GD project identifier
     * @param {GdcExecuteAFM.IExecution} execution
     *
     * @returns {Promise<GdcExecution.IExecutionResponse>} Promise with `executionResponse`
     */
    ExecuteAfmModule.prototype.getExecutionResponse = function (projectId, execution) {
        var _a, _b, _c;
        validateNumOfDimensions((_c = (_b = (_a = execution.execution.resultSpec) === null || _a === void 0 ? void 0 : _a.dimensions) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0);
        return this.xhr
            .post("/gdc/app/projects/" + projectId + "/executeAfm", { body: convertExecutionToJson(execution) })
            .then(function (apiResponse) { return apiResponse.getData(); })
            .then(unwrapExecutionResponse);
    };
    /**
     * Execute saved visualization and get all data.
     *
     * NOTE: all functionality related to executeVisualization is experimental and subject to possible breaking changes
     * in the future; location and shape of this interface WILL change when the functionality is made GA.
     *
     * @param {string} projectId - GD project identifier
     * @param {IVisualizationExecution} visExecution - execution payload
     *
     * @private
     * @internal
     */
    ExecuteAfmModule.prototype._executeVisualization = function (projectId, visExecution) {
        // We have ONE-3961 as followup to take this out of experimental mode
        var _this = this;
        return this._getVisExecutionResponse(projectId, visExecution).then(function (executionResponse) {
            return _this.getExecutionResult(executionResponse.links.executionResult).then(function (executionResult) {
                return { executionResponse: executionResponse, executionResult: executionResult };
            });
        });
    };
    /**
     *
     * Execute visualization and return the response; the response describes dimensionality of the results and
     * includes link to poll for the results.
     *
     * NOTE: all functionality related to executeVisualization is experimental and subject to possible breaking changes
     * in the future; location and shape of this interface WILL change when the functionality is made GA.
     *
     * @param {string} projectId - GD project identifier
     * @param {IVisualizationExecution} visExecution - execution payload
     *
     * @private
     * @internal
     */
    ExecuteAfmModule.prototype._getVisExecutionResponse = function (projectId, visExecution) {
        // We have ONE-3961 as followup to take this out of experimental mode
        var body = createExecuteVisualizationBody(visExecution);
        return this.xhr
            .post("/gdc/app/projects/" + projectId + "/executeVisualization", { body: body })
            .then(function (apiResponse) { return apiResponse.getData(); })
            .then(unwrapExecutionResponse);
    };
    //
    // working with results
    //
    /**
     * Get one page of Result from Execution (with requested limit and offset)
     *
     * @method getPartialExecutionResult
     * @param {string} executionResultUri
     * @param {number[]} limit - limit for each dimension
     * @param {number[]} offset - offset for each dimension
     *
     * @returns {Promise<GdcExecution.IExecutionResult | null>}
     *  Promise with `executionResult` or `null` (null means empty response - HTTP 204)
     */
    ExecuteAfmModule.prototype.getPartialExecutionResult = function (executionResultUri, limit, offset) {
        var executionResultUriQueryPart = getExecutionResultUriQueryPart(executionResultUri);
        var numOfDimensions = Number(qs.parse(executionResultUriQueryPart).dimensions);
        validateNumOfDimensions(numOfDimensions);
        return this.getPage(executionResultUri, limit, offset);
    };
    /**
     * Get whole ExecutionResult
     *
     * @method getExecutionResult
     * @param {string} executionResultUri
     *
     * @returns {Promise<GdcExecution.IExecutionResult | null>}
     *  Promise with `executionResult` or `null` (null means empty response - HTTP 204)
     */
    ExecuteAfmModule.prototype.getExecutionResult = function (executionResultUri) {
        var executionResultUriQueryPart = getExecutionResultUriQueryPart(executionResultUri);
        var numOfDimensions = Number(qs.parse(executionResultUriQueryPart).dimensions);
        validateNumOfDimensions(numOfDimensions);
        var limit = Array(numOfDimensions).fill(DEFAULT_LIMIT);
        var offset = Array(numOfDimensions).fill(0);
        return this.getAllPages(executionResultUri, limit, offset);
    };
    ExecuteAfmModule.prototype.getPage = function (executionResultUri, limit, offset) {
        return this.fetchExecutionResult(executionResultUri, limit, offset).then(function (executionResultWrapper) {
            return executionResultWrapper ? unwrapExecutionResult(executionResultWrapper) : null;
        });
    };
    ExecuteAfmModule.prototype.getAllPages = function (executionResultUri, limit, offset, prevExecutionResult) {
        var _this = this;
        return this.fetchExecutionResult(executionResultUri, limit, offset).then(function (executionResultWrapper) {
            if (!executionResultWrapper) {
                return null;
            }
            var executionResult = unwrapExecutionResult(executionResultWrapper);
            var newExecutionResult = prevExecutionResult
                ? mergePage(prevExecutionResult, executionResult)
                : executionResult;
            var _a = executionResult.paging, offset = _a.offset, total = _a.total;
            var nextOffset = getNextOffset(limit, offset, total);
            var nextLimit = getNextLimit(limit, nextOffset, total);
            return nextPageExists(nextOffset, total)
                ? _this.getAllPages(executionResultUri, nextLimit, nextOffset, newExecutionResult)
                : newExecutionResult;
        });
    };
    ExecuteAfmModule.prototype.fetchExecutionResult = function (executionResultUri, limit, offset) {
        var uri = replaceLimitAndOffsetInUri(executionResultUri, limit, offset);
        return this.xhr
            .get(uri)
            .then(function (apiResponse) { return (apiResponse.response.status === 204 ? null : apiResponse.getData()); });
    };
    return ExecuteAfmModule;
}());
export { ExecuteAfmModule };
function getExecutionResultUriQueryPart(executionResultUri) {
    return executionResultUri.split(/\?(.+)/)[1];
}
function unwrapExecutionResponse(executionResponseWrapper) {
    return executionResponseWrapper.executionResponse;
}
function unwrapExecutionResult(executionResultWrapper) {
    return executionResultWrapper.executionResult;
}
function validateNumOfDimensions(numOfDimensions) {
    invariant(numOfDimensions === 1 || numOfDimensions === 2, numOfDimensions + " dimensions are not allowed. Only 1 or 2 dimensions are supported.");
}
function createExecuteVisualizationBody(visExecution) {
    var _a = visExecution.visualizationExecution, reference = _a.reference, resultSpec = _a.resultSpec, filters = _a.filters;
    var resultSpecProp = resultSpec ? { resultSpec: resultSpec } : undefined;
    var filtersProp = filters ? { filters: filters } : undefined;
    return JSON.stringify({
        visualizationExecution: __assign(__assign({ reference: reference }, resultSpecProp), filtersProp),
    });
}
export function replaceLimitAndOffsetInUri(oldUri, limit, offset) {
    var _a = oldUri.split(/\?(.+)/), uriPart = _a[0], queryPart = _a[1];
    var query = __assign(__assign({}, qs.parse(queryPart)), { limit: limit.join(","), offset: offset.join(",") });
    return uriPart + stringify(query, { addQueryPrefix: true });
}
export function getNextOffset(limit, offset, total) {
    var numOfDimensions = total.length;
    var defaultNextRowsOffset = offset[0] + limit[0];
    if (numOfDimensions === 1) {
        return [defaultNextRowsOffset];
    }
    var defaultNextColumnsOffset = offset[1] + limit[1];
    var nextColumnsExist = offset[1] + limit[1] < total[1];
    var nextRowsOffset = nextColumnsExist
        ? offset[0] // stay in the same rows
        : defaultNextRowsOffset; // go to the next rows
    var nextColumnsOffset = nextColumnsExist
        ? defaultNextColumnsOffset // next columns for the same rows
        : 0; // start in the beginning of the next rows
    return [nextRowsOffset, nextColumnsOffset];
}
export function getNextLimit(limit, nextOffset, total) {
    var numOfDimensions = total.length;
    validateNumOfDimensions(numOfDimensions);
    var getSingleNextLimit = function (limit, nextOffset, total) {
        return nextOffset + limit > total ? total - nextOffset : limit;
    };
    // prevent set up lower limit than possible for 2nd dimension in the beginning of the next rows
    if (numOfDimensions === 2 &&
        nextOffset[1] === 0 && // beginning of the next rows
        limit[0] < total[1] // limit from 1st dimension should be used in 2nd dimension
    ) {
        return [getSingleNextLimit(limit[0], nextOffset[0], total[0]), limit[0]];
    }
    return range(numOfDimensions).map(function (i) { return getSingleNextLimit(limit[i], nextOffset[i], total[i]); });
}
export function nextPageExists(nextOffset, total) {
    // expression "return nextLimit[0] > 0" also returns correct result
    return nextOffset[0] < total[0];
}
function mergeHeaderItemsForEachAttribute(dimension, headerItems, result) {
    var _a;
    if (headerItems && result.headerItems) {
        for (var attrIdx = 0; attrIdx < headerItems[dimension].length; attrIdx += 1) {
            (_a = result.headerItems[dimension][attrIdx]).push.apply(_a, headerItems[dimension][attrIdx]);
        }
    }
}
// works only for one or two dimensions
export function mergePage(prevExecutionResult, executionResult) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var result = prevExecutionResult;
    var headerItems = executionResult.headerItems, data = executionResult.data, paging = executionResult.paging;
    var mergeHeaderItems = function (dimension) {
        // for 1 dimension we already have the headers from first page
        var otherDimension = dimension === 0 ? 1 : 0;
        var isEdge = paging.offset[otherDimension] === 0;
        if (isEdge) {
            mergeHeaderItemsForEachAttribute(dimension, headerItems, result);
        }
    };
    // merge data
    var rowOffset = paging.offset[0];
    if (result.data[rowOffset]) {
        // appending columns to existing rows
        for (var i = 0; i < data.length; i += 1) {
            var columns = data[i];
            var resultData = result.data[i + rowOffset];
            resultData.push.apply(resultData, columns);
        }
    }
    else {
        // appending new rows
        var resultData = result.data;
        var currentPageData = data;
        resultData.push.apply(resultData, currentPageData);
    }
    // merge headerItems
    if (paging.offset.length > 1) {
        mergeHeaderItems(0);
        mergeHeaderItems(1);
    }
    else {
        mergeHeaderItemsForEachAttribute(0, headerItems, result);
    }
    // update page count
    if (paging.offset.length === 1) {
        result.paging.count = [(_d = (_c = (_b = (_a = result === null || result === void 0 ? void 0 : result.headerItems) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0];
    }
    if (paging.offset.length === 2) {
        result.paging.count = [
            (_h = (_g = (_f = (_e = result === null || result === void 0 ? void 0 : result.headerItems) === null || _e === void 0 ? void 0 : _e[0]) === null || _f === void 0 ? void 0 : _f[0]) === null || _g === void 0 ? void 0 : _g.length) !== null && _h !== void 0 ? _h : 0,
            (_m = (_l = (_k = (_j = result === null || result === void 0 ? void 0 : result.headerItems) === null || _j === void 0 ? void 0 : _j[1]) === null || _k === void 0 ? void 0 : _k[0]) === null || _l === void 0 ? void 0 : _l.length) !== null && _m !== void 0 ? _m : 0,
        ];
    }
    return result;
}
//# sourceMappingURL=execute-afm.js.map