import { __read } from "tslib";
// (C) 2020-2021 GoodData Corporation
import { useEffect, useMemo, useState } from "react";
import { isDashboardAttributeFilter, isInsightWidget, } from "@gooddata/sdk-backend-spi";
import { areObjRefsEqual, filterObjRef } from "@gooddata/sdk-model";
import stringify from "json-stable-stringify";
import compact from "lodash/compact";
import first from "lodash/first";
import flow from "lodash/flow";
import isEqual from "lodash/isEqual";
import sortBy from "lodash/fp/sortBy";
import { queryWidgetFilters, selectFilterContextFilters, useDashboardQueryProcessing, useDashboardSelector, } from "../../../model";
/**
 * Hook for obtaining the effective filters for a widget.
 *
 * @param widget - widget to get effective filters for
 * @param filters - additional filters to apply
 * @returns set of filters that should be used to execute the given widget
 *
 * @alpha
 */
export var useWidgetFilters = function (widget, filters) {
    var _a = __read(useState({
        filters: [],
        filterQueryStatus: undefined,
    }), 2), effectiveFiltersState = _a[0], setEffectiveFiltersState = _a[1];
    var _b = useNonIgnoredFilters(widget), nonIgnoredFiltersStatus = _b.status, nonIgnoredFiltersError = _b.error, nonIgnoredFilters = _b.result;
    var _c = useDashboardQueryProcessing({
        queryCreator: queryWidgetFilters,
        onSuccess: function (result) {
            setEffectiveFiltersState({
                filters: result,
                filterQueryStatus: "success",
            });
        },
        onBeforeRun: function () {
            setEffectiveFiltersState({
                filters: [],
                filterQueryStatus: "running",
            });
        },
        onRejected: function () {
            setEffectiveFiltersState({
                filters: [],
                filterQueryStatus: "rejected",
            });
        },
        onError: function () {
            setEffectiveFiltersState({
                filters: [],
                filterQueryStatus: "error",
            });
        },
    }), runFiltersQuery = _c.run, status = _c.status, error = _c.error;
    // only run the "full" filters query if any of the non-ignored filters has changed
    useEffect(function () {
        if (widget && nonIgnoredFiltersStatus === "success") {
            runFiltersQuery(widget, filters);
        }
    }, [widget, stringify(nonIgnoredFilters), filters, nonIgnoredFiltersStatus]);
    return {
        result: effectiveFiltersState.filters,
        status: combineQueryProcessingStatuses(nonIgnoredFiltersStatus, effectiveFiltersState === null || effectiveFiltersState === void 0 ? void 0 : effectiveFiltersState.filterQueryStatus, status),
        error: nonIgnoredFiltersError !== null && nonIgnoredFiltersError !== void 0 ? nonIgnoredFiltersError : error,
    };
};
/**
 * Hook that retrieves the non-ignored dashboard level filters for a widget.
 *
 * @param widget - widget to get the non-ignored filters for
 */
function useNonIgnoredFilters(widget) {
    var dashboardFilters = useDashboardSelector(selectFilterContextFilters);
    var widgetIgnoresDateFilter = !(widget === null || widget === void 0 ? void 0 : widget.dateDataSet);
    var _a = __read(useState([]), 2), nonIgnoredFilterRefs = _a[0], setNonIgnoredFilterRefs = _a[1];
    /**
     * This handles cases where:
     * - the set of filters themselves has changed (new filters added/filters removed)
     * - widget itself has changed (potentially changing the ignore settings)
     *
     * Those are the only ways how the set of non-ignored filters can change.
     */
    var _b = useDashboardQueryProcessing({
        queryCreator: queryWidgetFilters,
        onSuccess: function (result) {
            setNonIgnoredFilterRefs(function (prevValue) {
                // only set state if the values really changed
                // this prevents the full query from running unnecessarily
                if (!isEqual(prevValue, result)) {
                    return result.map(filterObjRef);
                }
                return prevValue;
            });
        },
    }), run = _b.run, status = _b.status, error = _b.error;
    useEffect(function () {
        if (widget) {
            if (isInsightWidget(widget)) {
                // set [] as filter overrides to ignore filters on insights -> this way we get only the dashboard level filters
                run(widget, []);
            }
            else {
                run(widget);
            }
        }
    }, [widget, filtersDigest(dashboardFilters, widgetIgnoresDateFilter)]);
    var nonIgnoredFilters = useMemo(function () {
        return dashboardFilters.filter(function (filter) {
            if (isDashboardAttributeFilter(filter)) {
                return nonIgnoredFilterRefs.some(function (validRef) {
                    return areObjRefsEqual(validRef, filter.attributeFilter.displayForm);
                });
            }
            else {
                return !widgetIgnoresDateFilter;
            }
        });
    }, [dashboardFilters, nonIgnoredFilterRefs, widgetIgnoresDateFilter]);
    return {
        error: error,
        status: status,
        result: nonIgnoredFilters,
    };
}
// the lower the number, the more priority the status has
var statusPriorities = {
    error: 0,
    rejected: 1,
    running: 2,
    success: 3,
};
function combineQueryProcessingStatuses() {
    var statuses = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        statuses[_i] = arguments[_i];
    }
    return flow(compact, sortBy(function (status) { return statusPriorities[status]; }), first)(statuses);
}
/**
 * Gets a serialized digest of the filters provided. This is useful for detecting if the set of filters has changed.
 *
 * @remarks
 * This digest is only concerned with the display forms/datasets, not the selected values of the filters.
 *
 * @param filters - filters to get digest for
 * @param ignoreDateFilter - whether to ignore date filters
 * @returns
 */
function filtersDigest(filters, ignoreDateFilter) {
    var data = filters
        // if the widget ignores date filters, remove it from the digest to avoid false positives
        // when date filter changes to or from All time (this effectively adds/removes the date filter in the filters set,
        // but we do not care either way, so remove it altogether)
        .filter(function (filter) { return !ignoreDateFilter || isDashboardAttributeFilter(filter); })
        .map(function (filter) {
        if (isDashboardAttributeFilter(filter)) {
            return {
                displayForm: filter.attributeFilter.displayForm,
            };
        }
        else {
            return {
                dataSet: filter.dateFilter.dataSet,
            };
        }
    });
    return stringify(data);
}
//# sourceMappingURL=useWidgetFilters.js.map