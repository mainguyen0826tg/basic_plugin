import { __assign } from "tslib";
import invariant from "ts-invariant";
import React from "react";
import { convertDrillableItemsToPredicates } from "@gooddata/sdk-ui";
import { getChartOptions } from "./chartTypes/_chartOptions/chartOptionsBuilder";
import { getHighchartsOptions } from "./chartTypes/_chartCreators/highChartsCreators";
import { HighChartsRenderer, renderChart as chartRenderer, renderLegend as legendRenderer, } from "./adapter/HighChartsRenderer";
import { HighChartsMeasuredRenderer } from "./adapter/HighChartsMeasuredRenderer";
import buildLegendOptions from "./adapter/legendBuilder";
import noop from "lodash/noop";
import isEqual from "lodash/isEqual";
import isFunction from "lodash/isFunction";
import omitBy from "lodash/omitBy";
import { injectIntl } from "react-intl";
import { validateData } from "./chartTypes/_chartOptions/chartLimits";
import { withTheme } from "@gooddata/sdk-ui-theme-provider";
import Highcharts from "./lib";
import { isChartSupported, stringifyChartTypes } from "./chartTypes/_util/common";
export function renderHighCharts(props) {
    var childrenRenderer = function (contentRect) { return (React.createElement(HighChartsRenderer, __assign({ contentRect: contentRect }, props))); };
    return React.createElement(HighChartsMeasuredRenderer, { childrenRenderer: childrenRenderer });
}
var ChartTransformationImpl = function (props) {
    var config = props.config, _a = props.renderer, renderer = _a === void 0 ? renderHighCharts : _a, dataView = props.dataView, height = props.height, width = props.width, _b = props.afterRender, afterRender = _b === void 0 ? noop : _b, _c = props.onDrill, onDrill = _c === void 0 ? function () { return true; } : _c, _d = props.onLegendReady, onLegendReady = _d === void 0 ? noop : _d, locale = props.locale, intl = props.intl, theme = props.theme, numericSymbols = props.numericSymbols, _e = props.drillableItems, drillableItems = _e === void 0 ? [] : _e, onDataTooLarge = props.onDataTooLarge, _f = props.onNegativeValues, onNegativeValues = _f === void 0 ? null : _f, _g = props.pushData, pushData = _g === void 0 ? noop : _g;
    var visType = config.type;
    var drillablePredicates = convertDrillableItemsToPredicates(drillableItems);
    var chartOptions = getChartOptions(dataView, config, drillablePredicates, theme);
    var legendOptions = buildLegendOptions(config.legend, chartOptions);
    var validationResult = validateData(config.limits, chartOptions);
    var drillConfig = { dataView: dataView, onDrill: onDrill };
    var hcOptions = getHighchartsOptions(chartOptions, drillConfig, config, dataView.definition, intl, theme);
    var rendererProps = {
        chartOptions: chartOptions,
        hcOptions: hcOptions,
        height: height,
        width: width,
        afterRender: afterRender,
        onLegendReady: onLegendReady,
        locale: locale,
        legend: legendOptions,
        theme: theme,
    };
    if (validationResult.dataTooLarge) {
        // always force onDataTooLarge error handling
        invariant(onDataTooLarge, "Visualization's onDataTooLarge callback is missing.");
        onDataTooLarge(chartOptions);
    }
    else if (validationResult.hasNegativeValue) {
        // ignore hasNegativeValue if validation already fails on dataTooLarge
        // force onNegativeValues error handling only for pie chart.
        // hasNegativeValue can be true only for pie chart.
        invariant(onNegativeValues, '"onNegativeValues" callback required for pie chart transformation is missing.');
        onNegativeValues(chartOptions);
    }
    pushData({
        propertiesMeta: {
            legend_enabled: legendOptions.toggleEnabled,
        },
        colors: {
            colorAssignments: chartOptions.colorAssignments,
            colorPalette: chartOptions.colorPalette,
        },
    });
    if (!isChartSupported(visType)) {
        invariant(false, "Unknown visualization type: " + visType + ". Supported visualization types: " + stringifyChartTypes());
    }
    if (numericSymbols && numericSymbols.length) {
        Highcharts.setOptions({
            lang: {
                numericSymbols: numericSymbols,
            },
        });
    }
    if (validationResult.dataTooLarge || validationResult.hasNegativeValue) {
        return null;
    }
    var resetZoomButtonTooltip = intl
        ? intl.formatMessage({ id: "visualization.tooltip.resetZoom" })
        : null;
    return renderer(__assign(__assign({}, rendererProps), { chartRenderer: chartRenderer, legendRenderer: legendRenderer, resetZoomButtonTooltip: resetZoomButtonTooltip }));
};
/**
 * @internal
 */
var ChartTransformationWithInjectedProps = injectIntl(withTheme(ChartTransformationImpl));
export var ChartTransformation = React.memo(ChartTransformationWithInjectedProps, function (props, nextProps) {
    return isEqual(omitBy(props, isFunction), omitBy(nextProps, isFunction));
});
//# sourceMappingURL=ChartTransformation.js.map