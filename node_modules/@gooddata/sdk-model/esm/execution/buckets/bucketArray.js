// (C) 2019-2020 GoodData Corporation
import { anyBucket, bucketAttributes, bucketIsEmpty, bucketItems, bucketMeasures, bucketTotals, idMatchBucket, bucketModifyItems, bucketItemReduce, } from "./index";
import { anyAttribute, idMatchAttribute, isAttribute } from "../attribute";
import { anyMeasure, idMatchMeasure, isMeasure } from "../measure";
import flatMap from "lodash/flatMap";
import invariant from "ts-invariant";
import identity from "lodash/identity";
import findIndex from "lodash/findIndex";
/**
 * Gets all attributes matching the provided predicate from a list of buckets.
 *
 * If no predicate is provided, then the function defaults to {@link anyAttribute} predicate - meaning all
 * attributes will be returned.
 *
 * @param buckets - list of buckets to get attributes from
 * @param predicate - attribute predicate; {@link anyAttribute} is default
 * @returns empty list if none match
 * @public
 */
export function bucketsAttributes(buckets, predicate) {
    if (predicate === void 0) { predicate = anyAttribute; }
    invariant(buckets, "buckets must be specified");
    if (!buckets.length) {
        return [];
    }
    return flatMap(buckets, function (b) { return bucketAttributes(b, predicate); });
}
/**
 * Gets all measures matching the provided predicate from a list of buckets.
 *
 * If no predicate is provided, then the function defaults to {@link anyMeasure} predicate - meaning all
 * measures will be returned.
 *
 * @param buckets - list of buckets to get measures from
 * @param predicate - measure predicate; {@link anyMeasure} is default
 * @returns empty list if none match
 * @public
 */
export function bucketsMeasures(buckets, predicate) {
    if (predicate === void 0) { predicate = anyMeasure; }
    invariant(buckets, "buckets must be specified");
    if (!buckets.length) {
        return [];
    }
    return flatMap(buckets, function (b) { return bucketMeasures(b, predicate); });
}
/**
 * Finds bucket matching the provided predicate in a list of buckets.
 *
 * If no predicate is provided, then the function defaults to {@link anyBucket} predicate - meaning first
 * bucket in the list will be returned.
 *
 * This function also provides convenience to find bucket by local identifier - if you pass predicate as
 * string the function will automatically create idMatchBucket predicate.
 *
 * @param buckets - list of buckets to search
 * @param idOrFun - bucket predicate or string to match bucket by local identifier; {@link anyBucket} is default
 * @public
 */
export function bucketsFind(buckets, idOrFun) {
    if (idOrFun === void 0) { idOrFun = anyBucket; }
    invariant(buckets, "buckets must be specified");
    var predicate = typeof idOrFun === "string" ? idMatchBucket(idOrFun) : idOrFun;
    return buckets.find(predicate);
}
/**
 * Finds attribute matching the provided predicate in a list of buckets. If found, the function returns an object
 * that contains bucket where the matched attribute is stored, index within that bucket and the attribute itself.
 *
 * This function also provides convenience to find attribute by local identifier - if you pass predicate as
 * string the function will automatically create idMatchAttribute predicate.
 *
 * @remarks See {@link AttributeInBucket}
 *
 * @param buckets - list of buckets to search
 * @param idOrFun - attribute predicate or string to find attribute by local identifier; defaults to {@link anyAttribute}
 * @returns first-found attribute matching the predicate, undefined if none match
 * @public
 */
export function bucketsFindAttribute(buckets, idOrFun) {
    if (idOrFun === void 0) { idOrFun = anyAttribute; }
    invariant(buckets, "buckets must be specified");
    if (!buckets.length) {
        return;
    }
    var predicate = typeof idOrFun === "string" ? idMatchAttribute(idOrFun) : idOrFun;
    var typeAgnosticPredicate = function (obj) {
        return isAttribute(obj) && predicate(obj);
    };
    for (var _i = 0, buckets_1 = buckets; _i < buckets_1.length; _i++) {
        var bucket = buckets_1[_i];
        var idx = findIndex(bucket.items, typeAgnosticPredicate);
        if (idx >= 0) {
            var item = bucket.items[idx];
            return isAttribute(item) ? { bucket: bucket, idx: idx, attribute: item } : undefined;
        }
    }
    return undefined;
}
/**
 * Finds measure matching the provided predicate in a list of buckets. If found, the function returns an object
 * that contains bucket where the matched measure is stored, index within that bucket and the measure itself.
 *
 * This function also provides convenience to find measure by local identifier - if you pass predicate as
 * string the function will automatically create idMatchMeasure predicate.
 *
 * @remarks See {@link MeasureInBucket}
 *
 * @param buckets - list of buckets to search
 * @param idOrFun - measure predicate or string to find measure by local identifier; defaults to {@link anyMeasure}
 * @returns first-found measure matching the predicate, undefined if none match
 * @public
 */
export function bucketsFindMeasure(buckets, idOrFun) {
    if (idOrFun === void 0) { idOrFun = anyMeasure; }
    invariant(buckets, "buckets must be specified");
    if (!buckets.length) {
        return;
    }
    var predicate = typeof idOrFun === "string" ? idMatchMeasure(idOrFun) : idOrFun;
    var typeAgnosticPredicate = function (obj) {
        return isMeasure(obj) && predicate(obj);
    };
    for (var _i = 0, buckets_2 = buckets; _i < buckets_2.length; _i++) {
        var bucket = buckets_2[_i];
        var idx = findIndex(bucket.items, typeAgnosticPredicate);
        if (idx >= 0) {
            var item = bucket.items[idx];
            return isMeasure(item) ? { bucket: bucket, idx: idx, measure: item } : undefined;
        }
    }
    return undefined;
}
/**
 * Gets buckets with the provided local identifiers from a list of buckets.
 *
 * @param buckets - list of buckets to filter
 * @param ids - bucket identifiers
 * @returns empty list if none match
 * @public
 */
export function bucketsById(buckets) {
    var ids = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        ids[_i - 1] = arguments[_i];
    }
    invariant(buckets, "buckets must be specified");
    if (!buckets.length || !ids || !ids.length) {
        return [];
    }
    return buckets.filter(function (b) { return b.localIdentifier && ids.indexOf(b.localIdentifier) >= 0; });
}
/**
 * Gets all attributes and measures from a list of buckets.
 *
 * @param buckets - buckets to work with
 * @returns empty list if none
 * @public
 */
export function bucketsItems(buckets) {
    invariant(buckets, "buckets must be specified");
    return flatMap(buckets, function (b) { return bucketItems(b); });
}
/**
 * Gets all totals from a list of buckets
 *
 * @param buckets - buckets to work with
 * @returns empty list if none
 * @public
 */
export function bucketsTotals(buckets) {
    invariant(buckets, "buckets must be specified");
    return flatMap(buckets, function (b) { return bucketTotals(b); });
}
/**
 * Tests whether all buckets in a list are empty (meaning neither has any items or totals defined)
 *
 * @param buckets - buckets to work with
 * @returns true if empty, false if not
 * @public
 */
export function bucketsIsEmpty(buckets) {
    invariant(buckets, "buckets must be specified");
    if (!buckets.length) {
        return true;
    }
    return buckets.every(bucketIsEmpty);
}
/**
 * Creates a new array of buckets, each bucket in the array contains modified bucket items
 * (retrieved by applying the modifications function to the bucketItem).
 *
 * @param buckets - an array of buckets, all items of each bucket in the array are applied the modification function
 * @param modifications - the modification to apply to the bucket items
 * @returns a new array of buckets, each bucket in the array contains modified bucket items
 * @public
 */
export function bucketsModifyItem(buckets, modifications) {
    if (modifications === void 0) { modifications = identity; }
    invariant(buckets, "buckets must be specified");
    return buckets.map(function (bucket) { return bucketModifyItems(bucket, modifications); });
}
/**
 * Creates a new array of buckets, each bucket in the array contains modified bucket items
 *
 * @param buckets - an array of buckets, array is applied the modification function
 * @param reducer - the reducer to apply to the bucket items array
 * @returns a new array of buckets, each bucket in the array contains modified bucket items
 * @public
 */
export function bucketsReduceItem(buckets, reducer) {
    if (reducer === void 0) { reducer = identity; }
    invariant(buckets, "buckets must be specified");
    return buckets.map(function (bucket) { return bucketItemReduce(bucket, reducer); });
}
//# sourceMappingURL=bucketArray.js.map