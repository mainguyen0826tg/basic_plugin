import { __assign, __awaiter, __extends, __generator, __rest } from "tslib";
// (C) 2020 GoodData Corporation
import React, { useCallback, useEffect, useRef } from "react";
import { v4 as uuidv4 } from "uuid";
import { render } from "react-dom";
import noop from "lodash/noop";
import isEqual from "lodash/isEqual";
import compose from "lodash/flowRight";
import { injectIntl } from "react-intl";
import { insightProperties, insightTitle } from "@gooddata/sdk-model";
import { FullVisualizationCatalog } from "../internal";
import { fillMissingTitles, ignoreTitlesForSimpleMeasures, withContexts, DefaultLocale, LoadingComponent, ErrorComponent, IntlWrapper, } from "@gooddata/sdk-ui";
import { ExecutionFactoryUpgradingToExecByReference, ExecutionFactoryWithFixedFilters, } from "@gooddata/sdk-backend-base";
import { withTheme } from "@gooddata/sdk-ui-theme-provider";
var getElementId = function () { return "gd-vis-" + uuidv4(); };
var visualizationUriRootStyle = {
    height: "100%",
    display: "flex",
    flex: "1 1 auto",
    flexDirection: "column",
};
// this needs to be a pure component as it can happen that this might be rendered multiple times
// with the same props (referentially) - this might make the rendered visualization behave unpredictably
// and is bad for performance so we need to make sure the re-renders are performed only if necessary
var InsightRendererCore = /** @class */ (function (_super) {
    __extends(InsightRendererCore, _super);
    function InsightRendererCore() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.elementId = getElementId();
        _this.containerRef = React.createRef();
        _this.unmountVisualization = function () {
            if (_this.visualization) {
                _this.visualization.unmount();
            }
            _this.visualization = undefined;
        };
        _this.updateVisualization = function () {
            var _a;
            // if the container no longer exists, update was called after unmount -> do nothing
            if (!_this.visualization || !_this.containerRef.current) {
                return;
            }
            // if there is no insight, bail early
            if (!_this.props.insight) {
                return;
            }
            var _b = _this.props.config, config = _b === void 0 ? {} : _b;
            var responsiveUiDateFormat = ((_a = _this.props.settings) !== null && _a !== void 0 ? _a : {}).responsiveUiDateFormat;
            var visProps = {
                locale: _this.props.locale,
                dateFormat: responsiveUiDateFormat,
                custom: {
                    drillableItems: _this.props.drillableItems,
                },
                config: {
                    separators: config.separators,
                    colorPalette: _this.props.colorPalette,
                    mapboxToken: config.mapboxToken,
                    forceDisableDrillOnAxes: config.forceDisableDrillOnAxes,
                    isInEditMode: false,
                    isExportMode: config.isExportMode,
                },
                executionConfig: _this.props.execConfig,
                customVisualizationConfig: config,
                theme: _this.props.theme,
            };
            _this.visualization.update(visProps, ignoreTitlesForSimpleMeasures(fillMissingTitles(_this.props.insight, _this.props.locale)), {}, _this.getExecutionFactory());
        };
        _this.setupVisualization = function () { return __awaiter(_this, void 0, void 0, function () {
            var visualizationFactory;
            var _this = this;
            var _a, _b;
            return __generator(this, function (_c) {
                // if there is no insight, bail early
                if (!this.props.insight) {
                    return [2 /*return*/];
                }
                (_b = (_a = this.props).onLoadingChanged) === null || _b === void 0 ? void 0 : _b.call(_a, { isLoading: true });
                // the visualization we may have from earlier is no longer valid -> get rid of it
                this.unmountVisualization();
                visualizationFactory = FullVisualizationCatalog.forInsight(this.props.insight).getFactory();
                this.visualization = visualizationFactory({
                    backend: this.props.backend,
                    callbacks: {
                        onError: function (error) {
                            var _a, _b, _c, _d;
                            (_b = (_a = _this.props).onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);
                            (_d = (_c = _this.props).onLoadingChanged) === null || _d === void 0 ? void 0 : _d.call(_c, { isLoading: false });
                        },
                        onLoadingChanged: function (_a) {
                            var _b, _c;
                            var isLoading = _a.isLoading;
                            (_c = (_b = _this.props).onLoadingChanged) === null || _c === void 0 ? void 0 : _c.call(_b, { isLoading: isLoading });
                        },
                        pushData: this.props.pushData,
                        onDrill: this.props.onDrill,
                        onExportReady: this.onExportReadyDecorator,
                    },
                    configPanelElement: ".gd-configuration-panel-content",
                    element: "#" + this.elementId,
                    environment: "dashboards",
                    locale: this.props.locale,
                    projectId: this.props.workspace,
                    visualizationProperties: insightProperties(this.props.insight),
                    featureFlags: this.props.settings,
                    renderFun: render,
                });
                return [2 /*return*/];
            });
        }); };
        _this.onExportReadyDecorator = function (exportFunction) {
            if (!_this.props.onExportReady) {
                return;
            }
            var decorator = function (exportConfig) {
                if (exportConfig.title || !_this.props.insight) {
                    return exportFunction(exportConfig);
                }
                return exportFunction(__assign(__assign({}, exportConfig), { title: insightTitle(_this.props.insight) }));
            };
            _this.props.onExportReady(decorator);
        };
        _this.getExecutionFactory = function () {
            var factory = _this.props.backend.workspace(_this.props.workspace).execution();
            if (_this.props.executeByReference) {
                /*
                 * When executing by reference, decorate the original execution factory so that it
                 * transparently routes `forInsight` to `forInsightByRef` AND adds the filters
                 * from InsightView props.
                 *
                 * Code will pass this factory over to the pluggable visualizations - they will do execution
                 * `forInsight` and under the covers things will be routed and done differently without the
                 * plug viz knowing.
                 */
                return new ExecutionFactoryUpgradingToExecByReference(new ExecutionFactoryWithFixedFilters(factory, _this.props.filters));
            }
            return factory;
        };
        _this.componentDidMountInner = function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.setupVisualization()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, this.updateVisualization()];
                }
            });
        }); };
        _this.componentDidUpdateInner = function (prevProps) { return __awaiter(_this, void 0, void 0, function () {
            var needsNewSetup;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        needsNewSetup = !isEqual(this.props.insight, prevProps.insight) ||
                            !isEqual(this.props.filters, prevProps.filters) ||
                            this.props.workspace !== prevProps.workspace;
                        if (!needsNewSetup) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.setupVisualization()];
                    case 1:
                        _a.sent();
                        _a.label = 2;
                    case 2: return [2 /*return*/, this.updateVisualization()];
                }
            });
        }); };
        return _this;
    }
    InsightRendererCore.prototype.componentDidMount = function () {
        this.componentDidMountInner();
    };
    InsightRendererCore.prototype.componentDidUpdate = function (prevProps) {
        this.componentDidUpdateInner(prevProps);
    };
    InsightRendererCore.prototype.componentWillUnmount = function () {
        this.unmountVisualization();
    };
    InsightRendererCore.prototype.render = function () {
        return (
        // never ever dynamically change the props of this div, otherwise bad things will happen
        // e.g. visualization being rendered multiple times, etc.
        React.createElement("div", { className: "visualization-uri-root", id: this.elementId, ref: this.containerRef, style: visualizationUriRootStyle }));
    };
    InsightRendererCore.defaultProps = {
        ErrorComponent: ErrorComponent,
        filters: [],
        drillableItems: [],
        LoadingComponent: LoadingComponent,
        pushData: noop,
        locale: DefaultLocale,
    };
    return InsightRendererCore;
}(React.PureComponent));
export var IntlInsightRenderer = compose(injectIntl, withTheme, withContexts)(InsightRendererCore);
/**
 * Updated callback (callback with a different reference) is not properly propagated to the "visualization" instance
 * (because it only takes the callbacks provided on the first render)
 * Workaround it by storing the updated callback to the ref and calling it instead.
 *
 * @param callback
 */
function useUpdatableCallback(callback) {
    var pushDataCached = useRef(callback);
    useEffect(function () {
        pushDataCached.current = callback;
    }, [callback]);
    return useCallback((function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (pushDataCached.current) {
            pushDataCached.current.apply(pushDataCached, args);
        }
    }), []);
}
/**
 * Renders insight passed as a parameter.
 *
 * @internal
 */
export var InsightRenderer = function (props) {
    var pushData = props.pushData, onDrillCallBack = props.onDrill, onErrorCallBack = props.onError, onExportReadyCallback = props.onExportReady, onLoadingChangedCallback = props.onLoadingChanged, resProps = __rest(props, ["pushData", "onDrill", "onError", "onExportReady", "onLoadingChanged"]);
    var onPushData = useUpdatableCallback(pushData);
    var onDrill = useUpdatableCallback(onDrillCallBack);
    var onError = useUpdatableCallback(onErrorCallBack);
    var onExportReady = useUpdatableCallback(onExportReadyCallback);
    var onLoadingChanged = useUpdatableCallback(onLoadingChangedCallback);
    return (React.createElement(IntlWrapper, { locale: props.locale },
        React.createElement(IntlInsightRenderer, __assign({ pushData: onPushData, onDrill: onDrill, onError: onError, onExportReady: onExportReady, onLoadingChanged: onLoadingChanged }, resProps))));
};
//# sourceMappingURL=InsightRenderer.js.map