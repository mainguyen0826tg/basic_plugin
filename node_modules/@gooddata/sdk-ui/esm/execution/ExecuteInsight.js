import { __awaiter, __generator, __read, __spread } from "tslib";
// (C) 2019 GoodData Corporation
import React from "react";
import { withExecution } from "./withExecution";
import isEqual from "lodash/isEqual";
import { withContexts } from "../base";
import invariant from "ts-invariant";
var CoreExecute = function (props) {
    var children = props.children, error = props.error, isLoading = props.isLoading, reload = props.reload, result = props.result, LoadingComponent = props.LoadingComponent, ErrorComponent = props.ErrorComponent;
    if (ErrorComponent && error) {
        return React.createElement(ErrorComponent, { error: error });
    }
    if (LoadingComponent && isLoading) {
        return React.createElement(LoadingComponent, null);
    }
    if (LoadingComponent && ErrorComponent && !result) {
        return null;
    }
    return children({
        error: error,
        isLoading: isLoading,
        reload: reload,
        result: result,
    });
};
function componentName(props) {
    return props.componentName || "ExecuteInsight";
}
function exportTitle(props) {
    return props.exportTitle || componentName(props);
}
/**
 * Gets data for a specific stored insight.
 *
 * @beta
 */
export var ExecuteInsight = withContexts(withExecution({
    exportTitle: exportTitle,
    execution: function (props) { return __awaiter(void 0, void 0, void 0, function () {
        var insightRef, filters, sorts, dimensions, dateFormat, backend, workspace, insight, insightExecution, resolvedSorts, resolvedDimensions, resolvedDateFormat;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    insightRef = props.insight, filters = props.filters, sorts = props.sorts, dimensions = props.dimensions, dateFormat = props.dateFormat, backend = props.backend, workspace = props.workspace;
                    invariant(backend, "The backend in ExecuteInsight must be defined. Either pass it as a prop or make sure there is a BackendProvider up the component tree.");
                    invariant(workspace, "The workspace in ExecuteInsight must be defined. Either pass it as a prop or make sure there is a WorkspaceProvider up the component tree.");
                    return [4 /*yield*/, backend.workspace(workspace).insights().getInsight(insightRef)];
                case 1:
                    insight = _a.sent();
                    insightExecution = backend.workspace(workspace).execution().forInsightByRef(insight, filters);
                    if (sorts) {
                        resolvedSorts = typeof sorts === "function" ? sorts(insightExecution.definition, props) : sorts;
                        insightExecution = insightExecution.withSorting.apply(insightExecution, __spread(resolvedSorts));
                    }
                    if (dimensions) {
                        resolvedDimensions = typeof dimensions === "function"
                            ? dimensions(insightExecution.definition, props)
                            : dimensions;
                        insightExecution = insightExecution.withDimensions.apply(insightExecution, __spread(resolvedDimensions));
                    }
                    if (dateFormat) {
                        resolvedDateFormat = typeof dateFormat === "function"
                            ? dateFormat(insightExecution.definition, props)
                            : dateFormat;
                        insightExecution = insightExecution.withDateFormat(resolvedDateFormat);
                    }
                    return [2 /*return*/, insightExecution];
            }
        });
    }); },
    events: function (props) {
        var onError = props.onError, onLoadingChanged = props.onLoadingChanged, onLoadingFinish = props.onLoadingFinish, onLoadingStart = props.onLoadingStart, onExportReady = props.onExportReady;
        return {
            onError: onError,
            onLoadingChanged: onLoadingChanged,
            onLoadingFinish: onLoadingFinish,
            onLoadingStart: onLoadingStart,
            onExportReady: onExportReady,
        };
    },
    shouldRefetch: function (prevProps, nextProps) {
        var relevantProps = [
            "onError",
            "onLoadingChanged",
            "onLoadingFinish",
            "onLoadingStart",
        ];
        var relevantPropsDeepEqual = [
            "insight",
            "filters",
            "window",
        ];
        return (relevantProps.some(function (propName) { return prevProps[propName] !== nextProps[propName]; }) ||
            relevantPropsDeepEqual.some(function (propName) { return !isEqual(prevProps[propName], nextProps[propName]); }));
    },
    loadOnMount: function (props) {
        var _a = (props !== null && props !== void 0 ? props : {}).loadOnMount, loadOnMount = _a === void 0 ? true : _a;
        return loadOnMount;
    },
    window: function (props) { return props.window; },
})(CoreExecute));
//# sourceMappingURL=ExecuteInsight.js.map