import { __awaiter, __generator, __read, __spread } from "tslib";
import { insightDisplayFormUsage, insightRef, isObjRef, objRefToString, serializeObjRef, } from "@gooddata/sdk-model";
import { createCachedQueryService } from "../store/_infra/queryService";
import { selectInsightByRef } from "../store/insights/insightsSelectors";
import { call, select } from "redux-saga/effects";
import { invalidQueryArguments } from "../events/general";
import { selectAllCatalogAttributesMap, selectAllCatalogDisplayFormsMap, } from "../store/catalog/catalogSelectors";
import { invariant } from "ts-invariant";
import uniqBy from "lodash/uniqBy";
export var QueryInsightAttributesMetaService = createCachedQueryService("GDC.DASH/QUERY.INSIGHT.ATTRIBUTE.META", queryService, function (query) {
    var insightOrRef = query.payload.insightOrRef;
    var ref = isObjRef(insightOrRef) ? insightOrRef : insightRef(insightOrRef);
    return serializeObjRef(ref);
});
/**
 * Selector that will return attribute metadata for an insight. The input to the selector is the dashboard query that is used
 * to obtain and cache the data.
 *
 * This selector will return undefined if the query to obtain the data for particular insight was not yet fired or
 * processed. Otherwise will return object containing `status` of the data retrieval; if the `status` is
 * `'success'` then the `result` prop will contain the data.
 *
 * @remarks see {@link QueryInsightAttributesMeta}
 * @internal
 */
export var selectInsightAttributesMeta = QueryInsightAttributesMetaService.cache.selectQueryResult;
//
// Query implementation
//
function loadDisplayFormsAndAttributes(ctx, displayFormRefs) {
    return __awaiter(this, void 0, void 0, function () {
        var backend, workspace, loadedDisplayForms, loadedAttributes;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    backend = ctx.backend, workspace = ctx.workspace;
                    return [4 /*yield*/, backend
                            .workspace(workspace)
                            .attributes()
                            .getAttributeDisplayForms(displayFormRefs)];
                case 1:
                    loadedDisplayForms = _a.sent();
                    return [4 /*yield*/, backend
                            .workspace(workspace)
                            .attributes()
                            .getAttributes(loadedDisplayForms.map(function (df) { return df.attribute; }))];
                case 2:
                    loadedAttributes = _a.sent();
                    return [2 /*return*/, {
                            loadedDisplayForms: loadedDisplayForms,
                            loadedAttributes: loadedAttributes,
                        }];
            }
        });
    });
}
/**
 * Loads insight attribute and display form metadata for particular insight display form usage.
 *
 * This function will first attempt to find display forms & attributes in the catalog - for a quick in memory hit.
 *
 * However in corner cases some of the display forms and attributes may not be stored in catalog. That is the case when dashboard
 * contains an insight created from date datasets created from custom CSVs. These are not stored in the 'default' catalog
 * that is part of the dashboard component's state. That's when the function falls back to load the metadata from backend.
 */
function createInsightAttributesMeta(ctx, usage, catalogDisplayForms, catalogAttributes) {
    return __awaiter(this, void 0, void 0, function () {
        var allUsedRefs, displayFormsFromCatalog, missingDisplayForms, attributesFromCatalog, _a, loadedDisplayForms, loadedAttributes;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    allUsedRefs = __spread(usage.inAttributes, usage.inFilters, usage.inMeasureFilters);
                    displayFormsFromCatalog = [];
                    missingDisplayForms = [];
                    allUsedRefs.forEach(function (ref) {
                        var catalogDisplayForm = catalogDisplayForms.get(ref);
                        if (catalogDisplayForm) {
                            displayFormsFromCatalog.push(catalogDisplayForm);
                        }
                        else {
                            missingDisplayForms.push(ref);
                        }
                    });
                    attributesFromCatalog = displayFormsFromCatalog.map(function (df) {
                        var catalogAttribute = catalogAttributes.get(df.attribute);
                        // if this bombs there must be something seriously wrong because it means a display form is in catalog
                        // but the attribute to which it belongs is not. such a thing can only happen if something is messing
                        // around with the catalog state stored in the component.
                        invariant(catalogAttribute, "dashboard metadata catalog is corrupted");
                        return catalogAttribute.attribute;
                    });
                    return [4 /*yield*/, loadDisplayFormsAndAttributes(ctx, missingDisplayForms)];
                case 1:
                    _a = _b.sent(), loadedDisplayForms = _a.loadedDisplayForms, loadedAttributes = _a.loadedAttributes;
                    return [2 /*return*/, {
                            usage: usage,
                            attributes: uniqBy(__spread(attributesFromCatalog, loadedAttributes), function (a) { return serializeObjRef(a.ref); }),
                            displayForms: uniqBy(__spread(displayFormsFromCatalog, loadedDisplayForms), function (df) {
                                return serializeObjRef(df.ref);
                            }),
                        }];
            }
        });
    });
}
function queryService(ctx, query) {
    var correlationId, insightOrRef, insight, usage, catalogDisplayForms, catalogAttributes;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                correlationId = query.correlationId, insightOrRef = query.payload.insightOrRef;
                if (!isObjRef(insightOrRef)) return [3 /*break*/, 2];
                return [4 /*yield*/, select(selectInsightByRef(insightOrRef))];
            case 1:
                insight = _a.sent();
                if (!insight) {
                    throw invalidQueryArguments(ctx, "Insight with ref " + objRefToString(insightOrRef) + " does not exist on the dashboard", correlationId);
                }
                return [3 /*break*/, 3];
            case 2:
                insight = insightOrRef;
                _a.label = 3;
            case 3:
                usage = insightDisplayFormUsage(insight);
                return [4 /*yield*/, select(selectAllCatalogDisplayFormsMap)];
            case 4:
                catalogDisplayForms = _a.sent();
                return [4 /*yield*/, select(selectAllCatalogAttributesMap)];
            case 5:
                catalogAttributes = _a.sent();
                return [4 /*yield*/, call(createInsightAttributesMeta, ctx, usage, catalogDisplayForms, catalogAttributes)];
            case 6: return [2 /*return*/, _a.sent()];
        }
    });
}
//# sourceMappingURL=queryInsightAttributesMeta.js.map