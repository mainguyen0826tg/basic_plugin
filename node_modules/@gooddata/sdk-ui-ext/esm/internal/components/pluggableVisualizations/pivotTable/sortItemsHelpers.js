// (C) 2019-2020 GoodData Corporation
import { __assign, __spreadArrays } from "tslib";
// removes attribute sortItems with invalid identifiers
// removes measure sortItems with invalid identifiers and invalid number of locators
import { areObjRefsEqual, attributeLocalId, bucketAttributes, bucketsFind, bucketsMeasures, isAttributeSort, isMeasureLocator, isMeasureSort, measureLocalId, newAttributeSort, } from "@gooddata/sdk-model";
import includes from "lodash/includes";
import { BucketNames } from "@gooddata/sdk-ui";
import { isAttributeFilter } from "../../../utils/bucketHelper";
function filterInvalidSortItems(originalSortItems, measureLocalIdentifiers, rowAttributeLocalIdentifiers, columnAttributeLocalIdentifiers) {
    return originalSortItems.reduce(function (sortItems, sortItem) {
        if (isMeasureSort(sortItem)) {
            // filter out invalid locators
            var filteredSortItem = {
                measureSortItem: __assign(__assign({}, sortItem.measureSortItem), { locators: sortItem.measureSortItem.locators.filter(function (locator) {
                        // filter out invalid measure locators
                        if (isMeasureLocator(locator)) {
                            return includes(measureLocalIdentifiers, locator.measureLocatorItem.measureIdentifier);
                        }
                        // filter out invalid column attribute locators
                        return includes(columnAttributeLocalIdentifiers, locator.attributeLocatorItem.attributeIdentifier);
                    }) }),
            };
            // keep sortItem if measureLocator is present and locators are correct length
            if (filteredSortItem.measureSortItem.locators.some(function (locator) { return isMeasureLocator(locator); }) &&
                filteredSortItem.measureSortItem.locators.length ===
                    columnAttributeLocalIdentifiers.length + 1) {
                return __spreadArrays(sortItems, [filteredSortItem]);
            }
            // otherwise just carry over previous sortItems
            return sortItems;
        }
        /**
         * Keep only row attribute sorts, column sorts are not supported.
         *
         * This exists to overcome AD weirdness where AD will sometimes send insight with invalid sorts
         * even if the pivot table should NOT be sorted by default by the first row attribute in ascending order since it has no row attributes.
         * Code here fixes this symptom and ensures the default sort is in place only if relevant.
         *
         * Typical case is PivotTable with one measure and one row and then the user moves thee attribute from Row bucket to Column bucket.
         * In that case AD sends insight with the irrelevant sort and then without it.
         *
         * Note: while this may seem small thing, it's actually a messy business. When rendering / switching to the pivot
         * table the AD will call update/render multiple times. Sometimes with sort items, sometimes without sort items. This
         * can seriously mess up the pivot table in return: the column resizing is susceptible to race conditions and timing
         * issues. Because of the flurry of calls, the table may not render or load indefinitely.
         */
        if (includes(rowAttributeLocalIdentifiers, sortItem.attributeSortItem.attributeIdentifier)) {
            return __spreadArrays(sortItems, [sortItem]);
        }
        return sortItems;
    }, []);
}
export function adaptReferencePointSortItemsToPivotTable(originalSortItems, measures, rowAttributes, columnAttributes) {
    var measureLocalIdentifiers = measures.map(function (measure) { return measure.localIdentifier; });
    var rowAttributeLocalIdentifiers = rowAttributes.map(function (rowAttribute) { return rowAttribute.localIdentifier; });
    var columnAttributeLocalIdentifiers = columnAttributes.map(function (columnAttribute) { return columnAttribute.localIdentifier; });
    return filterInvalidSortItems(originalSortItems, measureLocalIdentifiers, rowAttributeLocalIdentifiers, columnAttributeLocalIdentifiers);
}
export function sanitizePivotTableSorts(originalSortItems, buckets) {
    var measureLocalIdentifiers = bucketsMeasures(buckets).map(measureLocalId);
    var rowBucket = bucketsFind(buckets, BucketNames.ATTRIBUTE);
    var rowAttributeLocalIdentifiers = rowBucket ? bucketAttributes(rowBucket).map(attributeLocalId) : [];
    var columnBucket = bucketsFind(buckets, BucketNames.COLUMNS);
    var columnAttributeLocalIdentifiers = columnBucket
        ? bucketAttributes(columnBucket).map(attributeLocalId)
        : [];
    return filterInvalidSortItems(originalSortItems, measureLocalIdentifiers, rowAttributeLocalIdentifiers, columnAttributeLocalIdentifiers);
}
export function addDefaultSort(sortItems, filters, rowAttributes, previousRowAttributes, columnAttributes, tableSortingCheckDisabled) {
    if (columnAttributes === void 0) { columnAttributes = []; }
    // cannot construct default sort without a row
    if (rowAttributes.length < 1) {
        return sortItems;
    }
    // detect custom sort
    var firstRow = rowAttributes[0];
    var previousFirstRow = previousRowAttributes && previousRowAttributes[0];
    var hasVisibleCustomSort = sortItems.some(function (sortItem) {
        if (!isSortItemVisible(sortItem, filters, columnAttributes, tableSortingCheckDisabled)) {
            return false;
        }
        // non attribute sort is definitely custom
        if (!isAttributeSort(sortItem)) {
            return true;
        }
        // asc sort on first row is considered default
        if (sortItem.attributeSortItem.attributeIdentifier === firstRow.localIdentifier &&
            sortItem.attributeSortItem.direction === "asc") {
            return false;
        }
        // asc sort on row that was first until now is considered default as well
        if (previousFirstRow &&
            sortItem.attributeSortItem.attributeIdentifier === previousFirstRow.localIdentifier &&
            sortItem.attributeSortItem.direction === "asc") {
            return false;
        }
        return true;
    });
    return hasVisibleCustomSort ? sortItems : [newAttributeSort(firstRow.localIdentifier, "asc")];
}
var isAttributeSortItemVisible = function (_sortItem, _filters) {
    return true;
};
function isMeasureSortItemMatchedByFilter(sortItem, filter) {
    return filter.selectedElements
        ? filter.selectedElements.some(function (selectedElement) {
            return sortItem.measureSortItem.locators.some(function (locator) {
                return !isMeasureLocator(locator) &&
                    locator.attributeLocatorItem.element === selectedElement.uri;
            });
        })
        : false;
}
function isMeasureSortItemVisible(sortItem, filters, columnAttributes, tableSortingCheckDisabled) {
    var appliedFilters = filters.filter(isAttributeFilter);
    if (tableSortingCheckDisabled) {
        appliedFilters = appliedFilters.filter(function (filter) {
            return columnAttributes.some(function (columnBucketItem) {
                return areObjRefsEqual(columnBucketItem.dfRef, filter.displayFormRef);
            });
        });
    }
    return appliedFilters.every(function (filter) {
        var shouldBeMatched = !filter.isInverted;
        return shouldBeMatched === isMeasureSortItemMatchedByFilter(sortItem, filter);
    });
}
export function isSortItemVisible(sortItem, filters, columnAttributes, tableSortingCheckDisabled) {
    return isAttributeSort(sortItem)
        ? isAttributeSortItemVisible(sortItem, filters)
        : isMeasureSortItemVisible(sortItem, filters, columnAttributes, tableSortingCheckDisabled);
}
//# sourceMappingURL=sortItemsHelpers.js.map