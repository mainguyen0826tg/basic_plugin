// (C) 2019-2021 GoodData Corporation
import { __awaiter, __generator } from "tslib";
import flatMap from "lodash/flatMap";
import merge from "lodash/merge";
import uniqBy from "lodash/uniqBy";
import { jsonApiHeaders } from "./constants";
var DefaultPageSize = 250;
var DefaultOptions = {
    headers: jsonApiHeaders,
    query: {
        size: DefaultPageSize,
    },
};
function createOptionsForPage(page, options) {
    return merge({}, DefaultOptions, options, { query: { page: page } });
}
/**
 * Tiger metadata utility functions
 *
 * @internal
 */
var MetadataUtilities = /** @class */ (function () {
    function MetadataUtilities() {
    }
    /**
     * This function merges multiple pages containing metadata entities into a single page. The entity data from different
     * pages are concatenated. The side-loaded entities are concatenated and their uniqueness is ensured so that same
     * entity sideloaded on multiple pages only appears once.
     *
     * The merges result WILL NOT contain any links section.
     *
     * @param pages - pages to merge
     * @internal
     */
    MetadataUtilities.mergeEntitiesResults = function (pages) {
        return {
            data: flatMap(pages, function (page) { return page.data; }),
            included: uniqBy(
            // we need the as any because the JsonApiDashboardPluginOutList does not have the "included" property
            flatMap(pages, function (page) { var _a; return (_a = page.included) !== null && _a !== void 0 ? _a : []; }), function (item) { return item.id + "_" + item.type; }),
        };
    };
    /**
     * Given list of JSON API entities, return those which have not broken relations to other MD objects. This
     * info is computed by backend when "X-GDC-VALIDATE-RELATIONS" is sent with the GET request. Note that backend
     * checks the relations recursively.
     *
     * @param result - MetadataGetEntitiesResult
     */
    MetadataUtilities.filterValidEntities = function (result) {
        result.data = result.data.filter(function (entity) { var _a, _b; return (_b = (_a = entity.attributes) === null || _a === void 0 ? void 0 : _a.areRelationsValid) !== null && _b !== void 0 ? _b : true; });
        return result;
    };
    /**
     * Given a function to get a paged list of metadata entities, API call parameters and options, this function will
     * retrieve all pages from the metadata.
     *
     * The parameters are passed to the function as is. The options will be used as a 'template'. If the options specify
     * page `size`, it will be retained and used for paging. Otherwise the size will be set to a default value (250). The
     * `page` number will be added dynamically upon each page request.
     *
     * @param client - API client to use, this is required so that function can correctly bind 'this' for
     *  the entitiesGet function
     * @param entitiesGet - function to get pages list of entities
     * @param params - parameters accepted by the function
     * @param options - options accepted by the function
     * @internal
     */
    MetadataUtilities.getAllPagesOf = function (client, entitiesGet, params, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(void 0, void 0, void 0, function () {
            var boundGet, results, pageSize, reachedEnd, nextPage, optionsToUse, result;
            var _a, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        boundGet = entitiesGet.bind(client.workspaceObjects);
                        results = [];
                        pageSize = (_b = (_a = options.query) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : DefaultPageSize;
                        reachedEnd = false;
                        nextPage = 0;
                        _c.label = 1;
                    case 1:
                        if (!!reachedEnd) return [3 /*break*/, 3];
                        optionsToUse = createOptionsForPage(nextPage, options);
                        return [4 /*yield*/, boundGet(params, optionsToUse)];
                    case 2:
                        result = _c.sent();
                        results.push(result.data);
                        if (result.data.data.length < pageSize) {
                            reachedEnd = true;
                        }
                        else {
                            nextPage += 1;
                        }
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/, results];
                }
            });
        });
    };
    return MetadataUtilities;
}());
export { MetadataUtilities };
//# sourceMappingURL=metadataUtilities.js.map