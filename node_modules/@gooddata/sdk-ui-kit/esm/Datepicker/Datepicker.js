import { __assign, __extends, __read } from "tslib";
// (C) 2020 GoodData Corporation
import React from "react";
import uniqueId from "lodash/uniqueId";
import debounce from "lodash/debounce";
import noop from "lodash/noop";
import format from "date-fns/format";
import parse from "date-fns/parse";
import isValid from "date-fns/isValid";
import classNames from "classnames";
import { IntlWrapper } from "@gooddata/sdk-ui";
import { translationUtils } from "@gooddata/util";
import { injectIntl } from "react-intl";
import MomentLocaleUtils from "react-day-picker/moment";
import DayPicker from "react-day-picker";
import DayPickerInput from "react-day-picker/DayPickerInput";
import { getOptimalAlignment } from "../utils/overlay";
import { elementRegion } from "../utils/domUtilities";
import { DEFAULT_DATE_FORMAT } from "../constants/platform";
var DATEPICKER_OUTSIDE_DAY_SELECTOR = "DayPicker-Day--outside";
function formatDate(date, dateFormat) {
    return format(date, dateFormat);
}
function parseDate(str, dateFormat) {
    try {
        var parsedDate = parse(str, dateFormat, new Date());
        // parse only dates with 4-digit years. this mimics moment.js behavior - it parses only dates above 1900
        // this is to make sure that the picker input is not overwritten in the middle of writing the year with year "0002" when writing 2020.
        //
        // it's also necessary to parse only when the input string fully matches with the desired format
        // to make sure that the picker input is not overwritten in the middle of writing.
        // e.g, let's consider a case where dateFormat is "dd/MM/yyyy" and the DayPickerInput has already been filled with a valid string "13/09/2020",
        // then an user wants to change only the month "13/09/2020" -> "13/11/2020" by removing "09" and typing "11".
        // in such case the parsing should wait until the user completes typing "11" (otherwise if parsing is done right after the first "1" is typed,
        // the cursor automatically moves to the end of the string in the middle of writing, causing a bad experience for the user).
        if (isValid(parsedDate) &&
            parsedDate.getFullYear() >= 1000 &&
            str === formatDate(parsedDate, dateFormat)) {
            return parsedDate;
        }
        return;
    }
    catch (_a) {
        return;
    }
}
var WrappedDatePicker = /** @class */ (function (_super) {
    __extends(WrappedDatePicker, _super);
    function WrappedDatePicker(props) {
        var _this = _super.call(this, props) || this;
        _this.resizeHandler = debounce(function () { return _this.alignDatePicker(); }, 100);
        var alignPoints = props.alignPoints;
        _this.state = {
            align: alignPoints[0].align,
            selectedDate: undefined,
            focused: false,
        };
        _this.handleDayChanged = _this.handleDayChanged.bind(_this);
        _this.handleInputChanged = _this.handleInputChanged.bind(_this);
        _this.alignDatePicker = _this.alignDatePicker.bind(_this);
        _this.setComponentRef = _this.setComponentRef.bind(_this);
        _this.setDatepickerRef = _this.setDatepickerRef.bind(_this);
        return _this;
    }
    WrappedDatePicker.prototype.componentDidMount = function () {
        var date = this.props.date;
        this.setState({ selectedDate: this.updateDate(date || new Date()) });
        window.addEventListener("resize", this.resizeHandler);
    };
    WrappedDatePicker.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        var props = this.props;
        if (props.date > nextProps.date || props.date < nextProps.date) {
            var selectedDate = this.updateDate(nextProps.date);
            this.setState({ selectedDate: selectedDate });
        }
    };
    WrappedDatePicker.prototype.componentDidUpdate = function (_prevProps, prevState) {
        if (this.state.focused && !prevState.focused) {
            this.alignDatePicker();
        }
    };
    WrappedDatePicker.prototype.componentWillUnmount = function () {
        window.removeEventListener("resize", this.resizeHandler);
    };
    WrappedDatePicker.prototype.setComponentRef = function (ref) {
        this.rootRef = ref;
    };
    WrappedDatePicker.prototype.setDatepickerRef = function (ref) {
        this.datePickerContainer = ref ? ref.dayPicker.parentElement : null;
    };
    WrappedDatePicker.prototype.getInputClasses = function () {
        return classNames("input-text", "small-12", this.props.size, uniqueId("gd-datepicker-input-"));
    };
    WrappedDatePicker.prototype.getComponentClasses = function () {
        return classNames("gd-datepicker", this.props.className, this.props.size, "gd-datepicker-input", this.state.focused ? "gd-datepicker-focused" : "");
    };
    WrappedDatePicker.prototype.getOverlayWrapperClasses = function () {
        var _a = __read(this.state.align.split(" "), 2), inputAnchorPoint = _a[0], pickerAnchorPoint = _a[1];
        return classNames("gd-datepicker-OverlayWrapper", "gd-datepicker-OverlayWrapper-" + inputAnchorPoint + "-xx", "gd-datepicker-OverlayWrapper-xx-" + pickerAnchorPoint);
    };
    WrappedDatePicker.prototype.updateDate = function (date) {
        return this.normalizeDate(date);
    };
    WrappedDatePicker.prototype.handleInputChanged = function (e) {
        var _this = this;
        var value = e.target.value;
        var parsedDate = parseDate(value, this.props.dateFormat);
        if (parsedDate) {
            this.setState({
                selectedDate: parsedDate,
                focused: false,
            }, function () {
                _this.props.onChange(_this.state.selectedDate);
            });
        }
        else {
            if (this.props.resetOnInvalidValue) {
                this.setState({
                    focused: false,
                    selectedDate: this.state.selectedDate,
                });
                return;
            }
            this.setState({
                focused: false,
            }, function () {
                _this.props.onChange(null);
            });
        }
    };
    WrappedDatePicker.prototype.handleDayChanged = function (newlySelectedDate) {
        var _this = this;
        if (!newlySelectedDate) {
            return;
        }
        if (DayPicker.DateUtils.isSameDay(this.state.selectedDate, newlySelectedDate)) {
            return;
        }
        this.setState({
            selectedDate: newlySelectedDate,
        }, function () {
            _this.props.onChange(newlySelectedDate);
        });
    };
    WrappedDatePicker.prototype.normalizeDate = function (date) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    };
    WrappedDatePicker.prototype.alignDatePicker = function () {
        var _this = this;
        var alignPoints = this.props.alignPoints;
        var container = this.datePickerContainer;
        if (!alignPoints || !container)
            return;
        var optimalAlignment = getOptimalAlignment({
            targetRegion: elementRegion(this.rootRef),
            selfRegion: elementRegion(container),
            alignPoints: alignPoints,
        });
        var align = optimalAlignment.alignment.align;
        this.setState({
            align: align,
        }, function () {
            _this.props.onAlign(align);
        });
    };
    WrappedDatePicker.prototype.handleWrapperClick = function (e) {
        var classList = e.target.classList;
        /**
         * Prevent default fixes bug BB-332 but prevents in closing other dropdowns (Bug BB-1102)
         * so we want to prevent default only when clicking on outside dates in datepicker
         */
        if (e.target && classList && classList.contains(DATEPICKER_OUTSIDE_DAY_SELECTOR)) {
            e.preventDefault();
        }
    };
    WrappedDatePicker.prototype.render = function () {
        var _this = this;
        var dateFormat = this.props.dateFormat;
        var classNamesProps = {
            overlay: "gd-datepicker-picker",
            overlayWrapper: this.getOverlayWrapperClasses(),
            container: "",
        };
        var dayPickerProps = {
            showOutsideDays: true,
            locale: translationUtils.sanitizeLocaleForMoment(this.props.intl.locale),
            localeUtils: MomentLocaleUtils,
            month: this.state.selectedDate,
            ref: this.setDatepickerRef,
        };
        var inputProps = {
            className: this.getInputClasses(),
            onBlur: this.handleInputChanged,
            tabIndex: this.props.tabIndex,
            onClick: function () {
                _this.setState({ focused: true });
            },
            onFocus: function () {
                _this.setState({ focused: true });
            },
        };
        return (React.createElement("div", { className: this.getComponentClasses(), ref: this.setComponentRef, onClick: this.handleWrapperClick },
            React.createElement(DayPickerInput, { classNames: classNamesProps, value: this.state.selectedDate, onDayChange: this.handleDayChanged, dayPickerProps: dayPickerProps, inputProps: inputProps, formatDate: formatDate, parseDate: parseDate, format: dateFormat, placeholder: this.props.placeholder }),
            React.createElement("span", { className: "gd-datepicker-icon gd-icon-calendar" })));
    };
    WrappedDatePicker.defaultProps = {
        className: "",
        date: new Date(),
        placeholder: "",
        onChange: noop,
        resetOnInvalidValue: false,
        size: "",
        tabIndex: 0,
        alignPoints: [{ align: "bl tl" }, { align: "br tr" }, { align: "tl bl" }, { align: "tr br" }],
        onAlign: noop,
        dateFormat: DEFAULT_DATE_FORMAT,
    };
    return WrappedDatePicker;
}(React.PureComponent));
export { WrappedDatePicker };
var DatePickerWithIntl = injectIntl(WrappedDatePicker);
/**
 * @internal
 */
var Datepicker = /** @class */ (function (_super) {
    __extends(Datepicker, _super);
    function Datepicker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Datepicker.prototype.render = function () {
        return (React.createElement(IntlWrapper, { locale: this.props.locale },
            React.createElement(DatePickerWithIntl, __assign({}, this.props))));
    };
    return Datepicker;
}(React.PureComponent));
export { Datepicker };
//# sourceMappingURL=Datepicker.js.map