import { __spreadArrays } from "tslib";
import { isAttributeHeader } from "@gooddata/api-client-tiger";
import { idRef, isIdentifierRef, isSimpleMeasure, measureItem, measureLocalId, } from "@gooddata/sdk-model";
import keyBy from "lodash/keyBy";
import mapValues from "lodash/mapValues";
import groupBy from "lodash/groupBy";
import uniqBy from "lodash/uniqBy";
var DEFAULT_FORMAT = "#,#.##";
function transformDimension(dim, simpleMeasureRefs, attrTotals) {
    return {
        headers: dim.headers.map(function (header) {
            var _a;
            var h = header;
            if (isAttributeHeader(h)) {
                return {
                    attributeHeader: {
                        // TODO: TIGER-HACK: Tiger provides no uri
                        uri: "",
                        identifier: h.attributeHeader.label.id,
                        ref: idRef(h.attributeHeader.label.id, "displayForm"),
                        formOf: {
                            identifier: h.attributeHeader.attribute.id,
                            name: h.attributeHeader.attributeName,
                            // TODO: TIGER-HACK: Tiger provides no uri
                            uri: "",
                            ref: idRef(h.attributeHeader.attribute.id, "attribute"),
                        },
                        localIdentifier: h.attributeHeader.localIdentifier,
                        name: h.attributeHeader.labelName,
                        totalItems: (_a = attrTotals[h.attributeHeader.localIdentifier]) !== null && _a !== void 0 ? _a : [],
                    },
                };
            }
            else {
                /*
                 * Funny stuff #1: tiger does not send name & format according to the contract (which is inspired
                 *  by bear behavior). The code must reconciliate as follows:
                 *
                 *  -  if name does not come from tiger, then default the name to localIdentifier
                 *  -  if format does not come from tiger, then default to a hardcoded format
                 *
                 * Funny stuff #2: tiger does not send simple measure identifier. The code must reconciliate:
                 *
                 * -   look up simple measure by local id from execution definition
                 */
                return {
                    measureGroupHeader: {
                        items: h.measureGroupHeaders.map(function (m) {
                            var _a, _b;
                            var ref = simpleMeasureRefs[m.localIdentifier];
                            var identifier = isIdentifierRef(ref) ? ref.identifier : undefined;
                            return {
                                measureHeaderItem: {
                                    localIdentifier: m.localIdentifier,
                                    name: (_a = m.name) !== null && _a !== void 0 ? _a : m.localIdentifier,
                                    format: (_b = m.format) !== null && _b !== void 0 ? _b : DEFAULT_FORMAT,
                                    identifier: identifier,
                                    ref: ref,
                                },
                            };
                        }),
                    },
                };
            }
        }),
    };
}
/**
 * Compute mapping from attribute identifiers to all ITotalDescriptors corresponding to that attribute.
 */
function getAttrTotals(def) {
    var attrTotals = def.dimensions.map(function (dim) {
        var _a;
        var totalsByAttrId = groupBy((_a = dim.totals) !== null && _a !== void 0 ? _a : [], function (total) { return total.attributeIdentifier; });
        return mapValues(totalsByAttrId, function (totals) {
            return uniqBy(totals, function (total) { return total.type; }).map(function (total) { return ({ totalHeaderItem: { name: total.type } }); });
        });
    });
    return Object.assign.apply(Object, __spreadArrays([{}], attrTotals));
}
/**
 * Transforms dimensions in the result provided by backend to the unified model used in SDK. The tiger backend
 * does not return all the data needed by the SPI. For some information, the transformation needs to look into
 * the input execution definition.
 *
 * @param dimensions - dimensions from execution result
 * @param def - execution definition, this is needed to augment the descriptors with data required by the SPI which
 *  the tiger backend does not pass
 *
 * @returns dimensions as used in the unified model
 */
export function transformResultDimensions(dimensions, def) {
    var simpleMeasures = def.measures.filter(isSimpleMeasure);
    var measureRefs = mapValues(keyBy(simpleMeasures, measureLocalId), function (m) {
        return measureItem(m);
    });
    return dimensions.map(function (dim) { return transformDimension(dim, measureRefs, getAttrTotals(def)); });
}
//# sourceMappingURL=dimensions.js.map