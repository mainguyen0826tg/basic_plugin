import { __assign, __awaiter, __generator } from "tslib";
// (C) 2020 GoodData Corporation
import React, { useCallback, useMemo, useState, useRef, useEffect } from "react";
import flatMap from "lodash/flatMap";
import isEqual from "lodash/isEqual";
import merge from "lodash/merge";
import { insightProperties, insightSetProperties, isDateFilter, insightVisualizationUrl, } from "@gooddata/sdk-model";
import { IntlWrapper, useBackend, useCancelablePromise, useWorkspace, isSomeHeaderPredicateMatched, DataViewFacade, } from "@gooddata/sdk-ui";
import { InsightRenderer as InsightRendererImpl } from "../../../insightView/InsightRenderer";
import { InsightError } from "../../../insightView/InsightError";
import { getImplicitDrillsWithPredicates } from "./drillingUtils";
import { addImplicitAllTimeFilter, isDateFilterIgnoredForInsight } from "./utils";
import { filterContextItemsToFiltersForWidget, filterContextToFiltersForWidget } from "../../converters";
import { useAttributesWithDrillDown, useColorPalette, useDashboardViewConfig, useDashboardViewExecConfig, useUserWorkspaceSettings, } from "../../contexts";
var insightStyle = { width: "100%", height: "100%", position: "relative" };
export var InsightRenderer = function (_a) {
    var _b, _c;
    var insightWidget = _a.insightWidget, insight = _a.insight, filters = _a.filters, filterContext = _a.filterContext, drillableItems = _a.drillableItems, onDrill = _a.onDrill, onError = _a.onError, backend = _a.backend, workspace = _a.workspace, ErrorComponent = _a.ErrorComponent, LoadingComponent = _a.LoadingComponent, clientHeight = _a.clientHeight;
    var effectiveBackend = useBackend(backend);
    var effectiveWorkspace = useWorkspace(workspace);
    var dashboardViewConfig = useDashboardViewConfig();
    var execConfig = useDashboardViewExecConfig();
    var userWorkspaceSettings = useUserWorkspaceSettings();
    var colorPalette = useColorPalette();
    var attributesWithDrillDown = useAttributesWithDrillDown();
    var _d = useState(false), isVisualizationLoading = _d[0], setIsVisualizationLoading = _d[1];
    var _e = useState([]), possibleDrills = _e[0], setPossibleDrills = _e[1];
    var _f = useState(null), visualizationError = _f[0], setVisualizationError = _f[1];
    var handleLoadingChanged = useCallback(function (_a) {
        var isLoading = _a.isLoading;
        setIsVisualizationLoading(isLoading);
        // if starting loading dismiss any previous visualizationError as it is most likely obsolete
        if (isLoading) {
            setVisualizationError(null);
        }
    }, []);
    var handleError = useCallback(function (error) {
        setVisualizationError(error);
        onError === null || onError === void 0 ? void 0 : onError(error);
    }, [onError]);
    var inputFilters = useMemo(function () {
        return filters
            ? filterContextItemsToFiltersForWidget(filters, insightWidget)
            : filterContextToFiltersForWidget(filterContext, insightWidget);
    }, [filters, filterContext, insightWidget]);
    var _g = useCancelablePromise({
        promise: function () { return __awaiter(void 0, void 0, void 0, function () {
            var resolvedFilters, resolvedWithImplicitAllTime;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, effectiveBackend
                            .workspace(effectiveWorkspace)
                            .dashboards()
                            .getResolvedFiltersForWidget(insightWidget, inputFilters)];
                    case 1:
                        resolvedFilters = _a.sent();
                        resolvedWithImplicitAllTime = addImplicitAllTimeFilter(insightWidget, resolvedFilters);
                        if (isDateFilterIgnoredForInsight(insight)) {
                            resolvedWithImplicitAllTime = resolvedWithImplicitAllTime.filter(function (filter) { return !isDateFilter(filter); });
                        }
                        return [2 /*return*/, effectiveBackend
                                .workspace(effectiveWorkspace)
                                .insights()
                                .getInsightWithAddedFilters(insight, resolvedWithImplicitAllTime)];
                }
            });
        }); },
        onError: onError,
    }, [effectiveBackend, effectiveWorkspace, insightWidget, insight, inputFilters]), error = _g.error, insightWithFilters = _g.result, status = _g.status;
    var insightWithAddedWidgetProperties = useMemo(function () {
        var _a;
        if (!insightWithFilters) {
            return insightWithFilters;
        }
        var fromWidget = insightWidget.properties;
        if (!fromWidget) {
            return insightWithFilters;
        }
        var fromWidgetWithZoomingHandled = __assign(__assign({}, fromWidget), { controls: __assign(__assign({}, fromWidget === null || fromWidget === void 0 ? void 0 : fromWidget.controls), { 
                // we need to take the relevant feature flag into account as well
                zoomInsight: !!(userWorkspaceSettings.enableKDZooming && ((_a = fromWidget === null || fromWidget === void 0 ? void 0 : fromWidget.controls) === null || _a === void 0 ? void 0 : _a.zoomInsight)) }) });
        var fromInsight = insightProperties(insightWithFilters);
        var merged = merge({}, fromInsight, fromWidgetWithZoomingHandled);
        return insightSetProperties(insightWithFilters, merged);
    }, [insightWithFilters, insightWidget.properties, userWorkspaceSettings]);
    var implicitDrillDefinitions = useMemo(function () {
        return getImplicitDrillsWithPredicates(insightWidget.drills, possibleDrills, attributesWithDrillDown);
    }, [insightWidget.drills, possibleDrills, attributesWithDrillDown]);
    var implicitDrills = useMemo(function () {
        return flatMap(implicitDrillDefinitions, function (info) { return info.predicates; });
    }, [implicitDrillDefinitions]);
    // since InsightRendererImpl only sets onDrill on the first render (this is a PlugVis API, there is no way to update onDrill there)
    // we have to sync the implicitDrillDefinitions into a ref so that the handleDrill can access the most recent value (thanks to the .current)
    // without this, handleDrill just closes over the first implicitDrillDefinitions which will never contain drillDown drills
    // as they are added *after* the first render of the PlugVis.
    var cachedImplicitDrillDefinitions = useRef(implicitDrillDefinitions);
    useEffect(function () {
        cachedImplicitDrillDefinitions.current = implicitDrillDefinitions;
    }, [implicitDrillDefinitions]);
    var handleDrill = useCallback(function (event) {
        var enrichedEvent = __assign(__assign({}, event), { widgetRef: insightWidget.ref });
        // if there are drillable items, we do not want to return any drillDefinitions as the implicit drills are not even used
        if (drillableItems) {
            return onDrill(enrichedEvent);
        }
        var facade = DataViewFacade.for(event.dataView);
        var definitions = cachedImplicitDrillDefinitions.current;
        var matchingImplicitDrillDefinitions = definitions.filter(function (info) {
            return event.drillContext.intersection.some(function (intersection) {
                return isSomeHeaderPredicateMatched(info.predicates, intersection.header, facade);
            });
        });
        return onDrill(__assign(__assign({}, enrichedEvent), { drillDefinitions: matchingImplicitDrillDefinitions.map(function (info) { return info.drillDefinition; }) }));
    }, []);
    var handlePushData = useCallback(function (data) {
        var _a;
        if ((_a = data.availableDrillTargets) === null || _a === void 0 ? void 0 : _a.attributes) {
            setPossibleDrills(function (prevValue) {
                // only set possible drills if really different to prevent other hooks firing unnecessarily
                if (!isEqual(prevValue, data.availableDrillTargets.attributes)) {
                    return data.availableDrillTargets.attributes;
                }
                // returning prevValue effectively skips the setState
                return prevValue;
            });
        }
    }, []);
    var chartConfig = useMemo(function () { return ({
        mapboxToken: dashboardViewConfig === null || dashboardViewConfig === void 0 ? void 0 : dashboardViewConfig.mapboxToken,
        separators: dashboardViewConfig === null || dashboardViewConfig === void 0 ? void 0 : dashboardViewConfig.separators,
        forceDisableDrillOnAxes: !drillableItems,
    }); }, [dashboardViewConfig, drillableItems]);
    // we need sdk-ui intl wrapper (this is how InsightView does this as well) for error messages etc.
    // ideally, we would merge InternalIntlWrapper and sdk-ui intl wrapper, but there is no clean way to do that
    var locale = (_b = dashboardViewConfig === null || dashboardViewConfig === void 0 ? void 0 : dashboardViewConfig.locale) !== null && _b !== void 0 ? _b : userWorkspaceSettings === null || userWorkspaceSettings === void 0 ? void 0 : userWorkspaceSettings.locale;
    /*
     * if there are drillable items from the user, use them and only them
     *
     * also pass any drillable items only if there is an onDrill specified, otherwise pass undefined
     * so that the items are not shown as active since nothing can happen on click without the onDrill provided
     */
    var drillableItemsToUse = onDrill ? drillableItems !== null && drillableItems !== void 0 ? drillableItems : implicitDrills : undefined;
    var insightPositionStyle = useMemo(function () {
        return {
            width: "100%",
            height: "100%",
            position: 
            // Headline violates the layout contract.
            // It should fit parent height and adapt to it as other visualizations.
            // Now, it works differently for the Headline - parent container adapts to Headline size.
            insight && insightVisualizationUrl(insight).includes("headline") ? "relative" : "absolute",
        };
    }, [insight]);
    return (React.createElement("div", { style: insightStyle },
        React.createElement("div", { style: insightPositionStyle },
            React.createElement(IntlWrapper, { locale: locale },
                (status === "loading" || status === "pending" || isVisualizationLoading) && (React.createElement(LoadingComponent, null)),
                (error || visualizationError) && (React.createElement(InsightError, { error: error || visualizationError, ErrorComponent: ErrorComponent, clientHeight: (userWorkspaceSettings === null || userWorkspaceSettings === void 0 ? void 0 : userWorkspaceSettings.enableKDWidgetCustomHeight) && clientHeight, height: null })),
                status === "success" && (React.createElement(InsightRendererImpl, { insight: insightWithAddedWidgetProperties, backend: effectiveBackend, workspace: effectiveWorkspace, drillableItems: drillableItemsToUse, onDrill: onDrill ? handleDrill : undefined, config: chartConfig, execConfig: execConfig, onLoadingChanged: handleLoadingChanged, locale: (_c = dashboardViewConfig.locale) !== null && _c !== void 0 ? _c : userWorkspaceSettings.locale, settings: userWorkspaceSettings, colorPalette: colorPalette, onError: handleError, pushData: handlePushData, ErrorComponent: ErrorComponent, LoadingComponent: LoadingComponent }))))));
};
//# sourceMappingURL=InsightRenderer.js.map