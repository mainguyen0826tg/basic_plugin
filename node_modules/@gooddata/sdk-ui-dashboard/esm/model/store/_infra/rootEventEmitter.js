import { __generator, __read, __spread } from "tslib";
import { actionChannel, select, take } from "redux-saga/effects";
import { isDashboardEventOrCustomDashboardEvent } from "../../events";
/**
 * Creates root event emitter that will be responsible for emitting events to all registered handlers.
 *
 * The emitter is realized using a saga. This saga has its own dedicated channel through which it receives
 * the events to emit - the event bus. Upon emitter start, it creates the channel and sets it into the
 * `eventEmitterContext` field of the saga context - this way other sagas can get hold of it.
 *
 * @param initialHandlers - event handlers to register at the time of creation
 * @param dispatch - dispatch object
 */
export function createRootEventEmitter(initialHandlers, dispatch) {
    if (initialHandlers === void 0) { initialHandlers = []; }
    var eventHandlers = __spread(initialHandlers);
    return {
        registerHandler: function (handler) {
            eventHandlers.push(handler);
        },
        unregisterHandler: function (handler) {
            eventHandlers = eventHandlers.filter(function (h) { return h !== handler; });
        },
        eventEmitterSaga: function () {
            var eventChannel, _loop_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, actionChannel(isDashboardEventOrCustomDashboardEvent)];
                    case 1:
                        eventChannel = _a.sent();
                        _loop_1 = function () {
                            var event_1, stateSnapshot, selectorEvaluator;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, take(eventChannel)];
                                    case 1:
                                        event_1 = _a.sent();
                                        return [4 /*yield*/, select()];
                                    case 2:
                                        stateSnapshot = _a.sent();
                                        selectorEvaluator = function (selector) { return selector(stateSnapshot); };
                                        try {
                                            eventHandlers.forEach(function (handler) {
                                                if (handler.eval(event_1)) {
                                                    handler.handler(event_1, dispatch, selectorEvaluator);
                                                }
                                            });
                                        }
                                        catch (e) {
                                            // eslint-disable-next-line no-console
                                            console.error("Error has occurred while dispatching event", event_1, e);
                                        }
                                        return [2 /*return*/];
                                }
                            });
                        };
                        _a.label = 2;
                    case 2:
                        if (!true) return [3 /*break*/, 4];
                        return [5 /*yield**/, _loop_1()];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 2];
                    case 4: return [2 /*return*/];
                }
            });
        },
    };
}
//# sourceMappingURL=rootEventEmitter.js.map