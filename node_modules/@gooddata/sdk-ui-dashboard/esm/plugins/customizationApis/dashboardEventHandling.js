// (C) 2021 GoodData Corporation
import { __read, __spread } from "tslib";
import findIndex from "lodash/findIndex";
/**
 * Factory for predicates that compare event handlers. The comparison is somewhat more aggressive to prevent
 * double-registration of same handler code. First, the two DashboardEventHandler objects are compared for
 * reference equality. If different, the handler function and eval functions are compared for equality - if
 * they are same, the entire event handler is declared same.
 */
var sameHandlerPredicateFactory = function (other) {
    return function (handler) {
        return handler === other || (handler.handler === other.handler && handler.eval === other.eval);
    };
};
function createEvalFn(eventType) {
    if (eventType === "*") {
        return function () { return true; };
    }
    return function (evt) {
        return evt.type === eventType;
    };
}
/**
 * @internal
 */
var DefaultDashboardEventHandling = /** @class */ (function () {
    function DefaultDashboardEventHandling() {
        var _this = this;
        this.handlers = [];
        this.initialHandlersSent = false;
        this.pendingRegistration = [];
        this.pendingUnregistration = [];
        this.stateChangesChain = [];
        this.evalCache = new Map();
        this.rootStateChangesCallback = function (state, dispatch) {
            _this.stateChangesChain.forEach(function (cb) {
                try {
                    cb(state, dispatch);
                }
                catch (e) {
                    // eslint-disable-next-line no-console
                    console.warn("OnStateChange callback " + cb + " threw an exception.", e);
                }
            });
        };
        /**
         * This callback will be included in the resulting IDashboardEventing instance returned by {@link getDashboardEventing}. It will thus
         * make its way into the dashboard store initializer. Once the store initializes and the event emitter is up, the ad hoc event
         * registration/unregistration functions will be passed to here.
         *
         * From then on, the methods that add/remove handlers or custom handlers can add handlers directly into active dashboard component.
         */
        this.onEventingInitialized = function (register, unregister) {
            _this.registerHandler = register;
            _this.unregisterHandler = unregister;
            _this.pendingRegistration.forEach(_this.registerHandler);
            _this.pendingUnregistration.forEach(_this.unregisterHandler);
            _this.pendingRegistration = [];
            _this.pendingUnregistration = [];
        };
        this.getOrCreateEvalFn = function (eventType) {
            var evalFn = _this.evalCache.get(eventType);
            if (evalFn !== undefined) {
                return evalFn;
            }
            var newEvalFn = createEvalFn(eventType);
            _this.evalCache.set(eventType, newEvalFn);
            return newEvalFn;
        };
        this.addEventHandler = function (eventType, callback) {
            var newHandler = {
                eval: _this.getOrCreateEvalFn(eventType),
                handler: callback,
            };
            return _this.addCustomEventHandler(newHandler);
        };
        this.removeEventHandler = function (eventType, callback) {
            var handler = {
                eval: _this.getOrCreateEvalFn(eventType),
                handler: callback,
            };
            return _this.removeCustomEventHandler(handler);
        };
        this.doRegister = function (handler) {
            // if engine + plugin initialization is not yet complete, there is nothing extra that has to
            // be done because all known handlers will be sent over as initial event handlers
            if (!_this.initialHandlersSent) {
                return;
            }
            // once the initialization is done, code must register or unregister handlers using functions
            // provided by the dashboard component's event emitter
            if (_this.registerHandler === undefined) {
                // meh, dashboard component's eventing is not yet up, code must hold onto the handlers so
                // that they can be registered immediately after it comes up
                _this.pendingRegistration.push(handler);
                var pendingIdx = findIndex(_this.pendingUnregistration, sameHandlerPredicateFactory(handler));
                if (pendingIdx > -1) {
                    _this.pendingUnregistration.splice(pendingIdx, 1);
                }
            }
            else {
                // otherwise can proceed to register the handler with the dashboard
                _this.registerHandler(handler);
            }
        };
        this.addCustomEventHandler = function (handler) {
            if (findIndex(_this.handlers, sameHandlerPredicateFactory(handler)) > -1) {
                // eslint-disable-next-line no-console
                console.warn("Attempting double-registration of the same handler " + handler + ". Ignoring.");
                return _this;
            }
            // keep track of all known handlers locally
            _this.handlers.push(handler);
            // and if needed register handler with dashboard component event emitter
            _this.doRegister(handler);
            return _this;
        };
        this.doUnregister = function (handler) {
            // if engine + plugin initialization is not yet complete, there is nothing extra that has to
            // be done because all known handlers will be sent over as initial event handlers
            if (!_this.initialHandlersSent) {
                return;
            }
            // same dilemma as with the registration; once the initialization is done, code must register or
            // unregister handlers using functions provided by the dashboard component's event emitter
            if (_this.unregisterHandler === undefined) {
                // meh, dashboard component's eventing is not yet up; now the course of action depends on
                // whether the handler to remove was part of handlers added during initialization or
                // after the initialization
                var pendingIdx = findIndex(_this.pendingRegistration, sameHandlerPredicateFactory(handler));
                if (pendingIdx > -1) {
                    // handler to remove was added after the initialization; all that is needed is to
                    // remove it from the list of handlers that are pending the registration
                    _this.pendingRegistration.splice(pendingIdx, 1);
                }
                else {
                    // handler to remove was among the initially added handler; no other way than to
                    // unregister the handler once the eventing comes up
                    _this.pendingUnregistration.push(handler);
                }
            }
            else {
                _this.unregisterHandler(handler);
            }
        };
        this.removeCustomEventHandler = function (handler) {
            var idx = findIndex(_this.handlers, sameHandlerPredicateFactory(handler));
            if (idx === -1) {
                // eslint-disable-next-line no-console
                console.warn("Attempting remove non-existing handler " + handler + ". Ignoring.");
                return _this;
            }
            // get the handler that was originally registered and is effectively the same as the handler
            // to remove
            var actuallyRegistered = _this.handlers[idx];
            // remove the handler from list of all known handlers; this is all that is needed if the
            // dashboard is not yet initialized
            _this.handlers.splice(idx, 1);
            // and if needed unregister handler from dashboard components event emitter
            _this.doUnregister(actuallyRegistered);
            return _this;
        };
        this.subscribeToStateChanges = function (callback) {
            if (findIndex(_this.stateChangesChain, function (fn) { return fn === callback; }) > -1) {
                // eslint-disable-next-line no-console
                console.warn("Attempting double-subscription of the same state change callback " + callback + ". Ignoring.");
                return _this;
            }
            _this.stateChangesChain.push(callback);
            return _this;
        };
        this.unsubscribeFromStateChanges = function (callback) {
            var idx = findIndex(_this.stateChangesChain, function (fn) { return fn === callback; });
            if (idx === -1) {
                return _this;
            }
            _this.stateChangesChain.splice(idx, 1);
            return _this;
        };
    }
    DefaultDashboardEventHandling.prototype.getDashboardEventing = function () {
        // handlers that were registered until this method is called will be part of the initial
        // event handlers; they will be registered with the event emitter immediately when the dashboard
        // component infrastructure gets created
        this.initialHandlersSent = true;
        return {
            eventHandlers: __spread(this.handlers),
            onStateChange: this.rootStateChangesCallback,
            onEventingInitialized: this.onEventingInitialized,
        };
    };
    return DefaultDashboardEventHandling;
}());
export { DefaultDashboardEventHandling };
//# sourceMappingURL=dashboardEventHandling.js.map