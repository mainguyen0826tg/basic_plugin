// (C) 2019-2021 GoodData Corporation
import { useCallback, useMemo, useRef } from "react";
import stableStringify from "json-stable-stringify";
import { isPlaceholder, } from "./base";
import { usePlaceholdersContext } from "./context";
import invariant from "ts-invariant";
import { setPlaceholder, resolvePlaceholderValue, resolveComposedPlaceholderValue, resolveValueWithPlaceholders, } from "./resolve";
/**
 * React hook to obtain/set placeholder value.
 * See {@link IPlaceholder}.
 *
 * Note: When placeholder is not provided, setting its value will result in the error.
 *
 * @public
 */
export function usePlaceholder(placeholder) {
    var _a = usePlaceholdersContext(), state = _a.state, updateState = _a.updateState;
    var resolvedPlaceholderValue = isPlaceholder(placeholder)
        ? resolvePlaceholderValue(placeholder, state)
        : undefined;
    var setPlaceholderValue = useCallback(function (valueOrUpdateCallback) {
        updateState(function (s) {
            invariant(isPlaceholder(placeholder), "usePlaceholder: Cannot set value of the placeholder - placeholder was not provided.");
            var resoledPlaceholderValue = resolvePlaceholderValue(placeholder, s);
            var updatedValue = valueOrUpdateCallback instanceof Function
                ? valueOrUpdateCallback(resoledPlaceholderValue)
                : valueOrUpdateCallback;
            return setPlaceholder(placeholder, updatedValue, s);
        });
    }, []);
    return [resolvedPlaceholderValue, setPlaceholderValue];
}
/**
 * React hook to obtain/set multiple placeholder values at once.
 * This is useful to perform placeholders atomic change.
 * See {@link IPlaceholder}.
 * @public
 */
export function usePlaceholders(placeholders) {
    var _a = usePlaceholdersContext(), state = _a.state, updateState = _a.updateState;
    var resolvedPlaceholderValues = placeholders.map(function (placeholder) {
        return resolvePlaceholderValue(placeholder, state);
    });
    var memoizedResolvedValues = useMultiValueMemoStringify(resolvedPlaceholderValues);
    var setPlaceholderValues = useCallback(function (valueOrUpdateCallback) {
        updateState(function (s) {
            var resolvedValues = placeholders.map(function (placeholder) {
                return resolvePlaceholderValue(placeholder, s);
            });
            var updatedValues = typeof valueOrUpdateCallback === "function"
                ? valueOrUpdateCallback(resolvedValues)
                : valueOrUpdateCallback;
            return placeholders.reduce(function (acc, placeholder, i) {
                return setPlaceholder(placeholder, updatedValues[i], acc);
            }, s);
        });
    }, []);
    return [memoizedResolvedValues, setPlaceholderValues];
}
/**
 * React hook to obtain composed placeholder value.
 * Optionally provide custom context for the composed placeholders resolution.
 * See {@link IComposedPlaceholder}.
 *
 * @public
 */
export function useComposedPlaceholder(placeholder, resolutionContext) {
    var state = usePlaceholdersContext().state;
    var resolvedValue = resolveComposedPlaceholderValue(placeholder, state, resolutionContext);
    return useMemoStringify(resolvedValue);
}
/**
 * React hook that resolves any value(s) that can possibly contain also placeholder(s) to actual value(s).
 * Optionally provide custom context for the composed placeholders resolution.
 *
 * @public
 */
export function useResolveValueWithPlaceholders(value, resolutionContext) {
    var state = usePlaceholdersContext().state;
    var resolvedValue = resolveValueWithPlaceholders(value, state, resolutionContext);
    return useMemoStringify(resolvedValue);
}
/**
 * React hook that resolves multiple value(s) that can possibly contain also placeholder(s) to actual value(s).
 * Optionally provide custom context for the composed placeholders resolution.
 *
 * @public
 */
export function useResolveValuesWithPlaceholders(values, resolutionContext) {
    var state = usePlaceholdersContext().state;
    var resolvedValues = values === null || values === void 0 ? void 0 : values.map(function (value) {
        return resolveValueWithPlaceholders(value, state, resolutionContext);
    });
    return useMultiValueMemoStringify(resolvedValues);
}
/**
 * Memoize value by its stringified value, to avoid new reference on each render.
 *
 * @param value - value to memoize
 * @returns - memoized value
 * @internal
 */
export function useMemoStringify(value) {
    return useMemo(function () {
        return value;
    }, [stableStringify(value)]);
}
/**
 * Memoize multiple values by their stringified value, to avoid new reference on each render.
 *
 * @param values - values to memoize
 * @returns - memoized values
 * @internal
 */
export function useMultiValueMemoStringify(values) {
    var _a;
    var prevValues = useRef((_a = values === null || values === void 0 ? void 0 : values.map(function (v) { return ({
        hash: stableStringify(v),
        value: v,
    }); })) !== null && _a !== void 0 ? _a : []);
    return useMemo(function () {
        return values === null || values === void 0 ? void 0 : values.map(function (val, idx) {
            var hash = stableStringify(val);
            if (hash === prevValues.current[idx].hash) {
                return prevValues.current[idx].value;
            }
            prevValues.current[idx] = {
                hash: hash,
                value: val,
            };
            return val;
        });
    }, [stableStringify(values)]);
}
//# sourceMappingURL=hooks.js.map