import { __assign } from "tslib";
// (C) 2021 GoodData Corporation
import { isDashboardAttributeFilter, isDashboardDateFilter, UnexpectedError, } from "@gooddata/sdk-backend-spi";
import { areObjRefsEqual, attributeElementsCount, attributeElementsIsEmpty, filterObjRef, isAttributeElementsByRef, isAttributeFilter, objRefToString, } from "@gooddata/sdk-model";
import last from "lodash/last";
import partition from "lodash/partition";
import { isAttributeFilterIgnored, isDateFilterIrrelevant } from "../../utils/filters";
import { translateDateFilter } from "./translationUtils";
export function isBrokenAlertDateFilterInfo(item) {
    return isDashboardDateFilter(item.alertFilter);
}
export function isBrokenAlertAttributeFilterInfo(item) {
    return isDashboardAttributeFilter(item.alertFilter);
}
/**
 * Gets the information about the so called broken alert filters. These are filters that are set up on the alert,
 * but the currently applied filters either do not contain them, or the KPI has started ignoring them
 * since the alert was first set up.
 *
 * @param alert the alert to compute the broken filters for
 * @param kpi the KPI widget that the alert is relevant to
 * @param appliedFilters all the currently applied filters (including All Time date filters)
 */
export function getBrokenAlertFiltersBasicInfo(alert, kpi, appliedFilters) {
    var _a, _b;
    var alertFilters = (_a = alert === null || alert === void 0 ? void 0 : alert.filterContext) === null || _a === void 0 ? void 0 : _a.filters;
    // no filters -> no filters can be broken, bail early
    if (!alertFilters) {
        return [];
    }
    var result = [];
    var _c = partition(alertFilters, isDashboardDateFilter), alertDateFilters = _c[0], alertAttributeFilters = _c[1];
    // attribute filters
    var appliedAttributeFilters = appliedFilters.filter(isAttributeFilter);
    alertAttributeFilters.forEach(function (alertFilter) {
        // ignored attribute filters are broken even if they are noop
        var isIgnored = isAttributeFilterIgnored(kpi, alertFilter.attributeFilter.displayForm);
        if (isIgnored) {
            result.push({
                alertFilter: alertFilter,
                brokenType: "ignored",
            });
            return;
        }
        // deleted attribute filters are broken even if they are noop
        var isInAppliedFilters = appliedAttributeFilters.some(function (f) {
            return areObjRefsEqual(filterObjRef(f), alertFilter.attributeFilter.displayForm);
        });
        var isDeleted = !isInAppliedFilters;
        if (isDeleted) {
            result.push({
                alertFilter: alertFilter,
                brokenType: "deleted",
            });
        }
    });
    // date filter
    var alertDateFilter = last(alertDateFilters);
    if (alertDateFilter) {
        var isIrrelevantNow = isDateFilterIrrelevant(kpi);
        if (isIrrelevantNow) {
            result.push({
                alertFilter: {
                    dateFilter: __assign(__assign({}, alertDateFilter.dateFilter), { dataSet: (_b = alertDateFilter.dateFilter.dataSet) !== null && _b !== void 0 ? _b : kpi.dateDataSet }),
                },
                brokenType: "ignored",
            });
        }
    }
    return result;
}
/**
 * Takes basic broken alert info and adds additional information used for displaying of such filters to the user.
 *
 * @param brokenAlertFilters the basic broken alert filters info to enrich
 * @param intl the intl object used
 * @param dateFormat the date format to be used
 * @param dateDataSets all available date data sets
 * @param attributeFiltersMeta additional information about attribute filters (see {@link IAttributeFilterMetaCollection} for details)
 */
export function enrichBrokenAlertsInfo(brokenAlertFilters, intl, dateFormat, dateDataSets, attributeFiltersMeta) {
    return brokenAlertFilters.map(function (brokenFilter) {
        if (isBrokenAlertAttributeFilterInfo(brokenFilter)) {
            return enrichBrokenAttributeFilter(brokenFilter, attributeFiltersMeta);
        }
        if (isBrokenAlertDateFilterInfo(brokenFilter)) {
            return enrichBrokenDateFilter(brokenFilter, intl, dateFormat, dateDataSets);
        }
        throw new UnexpectedError("Unknown broken alert filter type.");
    });
}
function enrichBrokenDateFilter(brokenFilter, intl, dateFormat, dateDataSets) {
    var _a;
    var alertFilter = brokenFilter.alertFilter, brokenType = brokenFilter.brokenType;
    var dateFilterTitle = translateDateFilter(alertFilter, intl, dateFormat);
    var matchingDateDataset = dateDataSets.find(function (dataset) {
        return areObjRefsEqual(dataset, alertFilter.dateFilter.dataSet);
    });
    return {
        type: "date",
        brokenType: brokenType,
        dateFilterTitle: dateFilterTitle,
        title: (_a = matchingDateDataset === null || matchingDateDataset === void 0 ? void 0 : matchingDateDataset.title) !== null && _a !== void 0 ? _a : intl.formatMessage({ id: "kpiAlertDialog.brokenAlertDefaultDateLabel" }),
    };
}
function enrichBrokenAttributeFilter(brokenFilter, attributeFiltersMeta) {
    var alertFilter = brokenFilter.alertFilter, brokenType = brokenFilter.brokenType;
    var metaKey = objRefToString(alertFilter.attributeFilter.displayForm);
    var meta = attributeFiltersMeta[metaKey];
    var isNegative = alertFilter.attributeFilter.negativeSelection;
    var totalCount = meta.totalElementsCount;
    var elements = meta.validElements.filter(function (element) {
        var isInSelected = isAttributeElementsByRef(alertFilter.attributeFilter.attributeElements)
            ? alertFilter.attributeFilter.attributeElements.uris.some(function (uri) { return uri === element.uri; })
            : alertFilter.attributeFilter.attributeElements.values.some(function (value) { return value === element.title; });
        return isInSelected !== isNegative;
    });
    var selection = elements.map(function (el) { return el.title; }).join(", ");
    var title = meta.title;
    var selectedCount = attributeElementsCount(alertFilter.attributeFilter.attributeElements);
    return {
        type: "attribute",
        brokenType: brokenType,
        isAllSelected: isNegative && attributeElementsIsEmpty(alertFilter.attributeFilter.attributeElements),
        selection: selection,
        selectionSize: isNegative ? totalCount - selectedCount : selectedCount,
        title: title,
    };
}
//# sourceMappingURL=brokenFilterUtils.js.map