import { __awaiter, __generator } from "tslib";
import { areObjRefsEqual } from "@gooddata/sdk-model";
import invariant from "ts-invariant";
import isEmpty from "lodash/isEmpty";
/**
 * @internal
 */
export function dynamicDashboardEngineLoader(dashboard, moduleFederationIntegration) {
    return __awaiter(this, void 0, void 0, function () {
        var plugins, first, loadedEngineModule, engineFactory;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    plugins = dashboard.references.plugins;
                    // if this bombs, this loader was called with no plugins (which means noop version should have been used)
                    invariant(!isEmpty(plugins));
                    first = plugins[0];
                    return [4 /*yield*/, loadEngine(moduleNameFromUrl(first.url), moduleFederationIntegration)()];
                case 1:
                    loadedEngineModule = _a.sent();
                    engineFactory = loadedEngineModule.default;
                    return [2 /*return*/, engineFactory()];
            }
        });
    });
}
/**
 * @internal
 */
export function dynamicDashboardPluginLoader(_ctx, dashboard, moduleFederationIntegration) {
    return __awaiter(this, void 0, void 0, function () {
        var plugins, pluginLinks;
        var _this = this;
        return __generator(this, function (_a) {
            plugins = dashboard.references.plugins;
            if (!plugins.length) {
                return [2 /*return*/, []];
            }
            pluginLinks = dashboard.dashboard.plugins;
            return [2 /*return*/, Promise.all(plugins.map(function (pluginMeta) { return __awaiter(_this, void 0, void 0, function () {
                    var loadedModule, pluginFactory, plugin, pluginLink;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, loadPlugin(moduleNameFromUrl(pluginMeta.url), moduleFederationIntegration)()];
                            case 1:
                                loadedModule = _a.sent();
                                pluginFactory = loadedModule.default;
                                plugin = pluginFactory();
                                pluginLink = pluginLinks === null || pluginLinks === void 0 ? void 0 : pluginLinks.find(function (link) { return areObjRefsEqual(link.plugin, pluginMeta.ref); });
                                return [2 /*return*/, {
                                        plugin: plugin,
                                        parameters: pluginLink === null || pluginLink === void 0 ? void 0 : pluginLink.parameters,
                                    }];
                        }
                    });
                }); }))];
        });
    });
}
/**
 * @internal
 */
export function dynamicDashboardBeforeLoad(_ctx, dashboard) {
    return __awaiter(this, void 0, void 0, function () {
        var plugins, urls, tasks;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    plugins = dashboard.references.plugins;
                    if (!plugins.length) {
                        return [2 /*return*/];
                    }
                    urls = plugins.map(function (plugin) { return plugin.url; });
                    tasks = urls.map(addScriptTag);
                    // add the script tags...
                    return [4 /*yield*/, Promise.all(tasks.map(function (task) { return task.promise; }))];
                case 1:
                    // add the script tags...
                    _a.sent();
                    // ...and once they are added (and added to the global scope), remove them immediately, they are not needed anymore
                    tasks.forEach(function (_a) {
                        var element = _a.element;
                        document.head.removeChild(element);
                    });
                    return [2 /*return*/];
            }
        });
    });
}
function moduleNameFromUrl(url) {
    var _a;
    var moduleName = (_a = /.*\/(.+)\.js/.exec(url)) === null || _a === void 0 ? void 0 : _a[1];
    invariant(moduleName, "Invalid plugin URL provided, it must point to the root .js file");
    return moduleName;
}
function addScriptTag(url) {
    var element = document.createElement("script");
    var promise = new Promise(function (resolve, reject) {
        element.src = url;
        element.type = "text/javascript";
        element.async = true;
        element.onload = function () {
            // eslint-disable-next-line no-console
            console.log("Dynamic Script Loaded: " + url);
            resolve();
        };
        element.onerror = function () {
            // eslint-disable-next-line no-console
            console.error("Dynamic Script Error: " + url);
            reject();
        };
        document.head.appendChild(element);
    });
    return {
        promise: promise,
        element: element,
    };
}
function loadEntry(moduleName, _a) {
    var _this = this;
    var __webpack_init_sharing__ = _a.__webpack_init_sharing__, __webpack_share_scopes__ = _a.__webpack_share_scopes__;
    return function () { return __awaiter(_this, void 0, void 0, function () {
        var container, entryFactory;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: 
                // Initializes the share scope. This fills it with known provided modules from this build and all remotes
                return [4 /*yield*/, __webpack_init_sharing__("default")];
                case 1:
                    // Initializes the share scope. This fills it with known provided modules from this build and all remotes
                    _a.sent();
                    container = window[moduleName];
                    // Initialize the container, it may provide shared modules
                    return [4 /*yield*/, container.init(__webpack_share_scopes__.default)];
                case 2:
                    // Initialize the container, it may provide shared modules
                    _a.sent();
                    return [4 /*yield*/, window[moduleName].get("./" + moduleName + "_ENTRY")];
                case 3:
                    entryFactory = _a.sent();
                    return [2 /*return*/, entryFactory().default];
            }
        });
    }); };
}
function loadPlugin(moduleName, moduleFederationIntegration) {
    var _this = this;
    return function () { return __awaiter(_this, void 0, void 0, function () {
        var entry, factory;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, loadEntry(moduleName, moduleFederationIntegration)()];
                case 1:
                    entry = _a.sent();
                    return [4 /*yield*/, window[moduleName].get(entry.pluginKey)];
                case 2:
                    factory = _a.sent();
                    return [2 /*return*/, factory()];
            }
        });
    }); };
}
function loadEngine(moduleName, moduleFederationIntegration) {
    var _this = this;
    return function () { return __awaiter(_this, void 0, void 0, function () {
        var entry, factory;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, loadEntry(moduleName, moduleFederationIntegration)()];
                case 1:
                    entry = _a.sent();
                    return [4 /*yield*/, window[moduleName].get(entry.engineKey)];
                case 2:
                    factory = _a.sent();
                    return [2 /*return*/, factory()];
            }
        });
    }); };
}
//# sourceMappingURL=dynamicComponentLoaders.js.map