import { __assign, __read, __rest, __spread, __values } from "tslib";
// (C) 2019-2021 GoodData Corporation
import flatten from "lodash/flatten";
import round from "lodash/round";
import isNil from "lodash/isNil";
import isEqual from "lodash/isEqual";
import clamp from "lodash/clamp";
import { isDashboardLayout, isWidget, isWidgetDefinition, isLegacyKpiWithoutComparison, isLegacyKpi, } from "@gooddata/sdk-backend-spi";
import invariant from "ts-invariant";
import { isInsight } from "@gooddata/sdk-model";
import { fluidLayoutDescriptor, getInsightSizeInfo, INSIGHT_WIDGET_SIZE_INFO_DEFAULT_LEGACY, KPI_WIDGET_SIZE_INFO_DEFAULT, KPI_WIDGET_SIZE_INFO_DEFAULT_LEGACY, INSIGHT_WIDGET_SIZE_INFO_DEFAULT, } from "@gooddata/sdk-ui-ext";
import { DashboardLayoutFacade } from "../../../../_staging/dashboard/fluidLayout/facade/layout";
import { DashboardLayoutBuilder } from "../../../../_staging/dashboard/fluidLayout/builder/layout";
import { ALL_SCREENS, DASHBOARD_LAYOUT_CONTAINER_WIDTHS, DASHBOARD_LAYOUT_MAX_HEIGHT_AS_RATIO_XS, GRID_ROW_HEIGHT_IN_PX, } from "../../../constants";
import { DASHBOARD_LAYOUT_GRID_COLUMNS_COUNT } from "../../../../_staging/dashboard/fluidLayout";
export function unifyDashboardLayoutItemHeights(itemsOrLayout) {
    if (isDashboardLayout(itemsOrLayout)) {
        var updatedLayout = __assign(__assign({}, itemsOrLayout), { sections: DashboardLayoutFacade.for(itemsOrLayout)
                .sections()
                .reduce(function (acc, section) {
                return __spread(acc, [
                    __assign(__assign({}, section.raw()), { items: unifyDashboardLayoutItemHeights(section.items().raw()) }),
                ]);
            }, []) });
        return updatedLayout;
    }
    var itemsWithSizeForAllScreens = itemsOrLayout.map(function (item) { return (__assign(__assign({}, item), { size: implicitLayoutItemSizeFromXlSize(item.size.xl) })); });
    var itemsWithUnifiedHeightForAllScreens = ALL_SCREENS.reduce(function (acc, screen) {
        var itemsAsFutureGridRows = splitDashboardLayoutItemsAsRenderedGridRows(acc, screen);
        var itemsWithUnifiedHeight = flatten(itemsAsFutureGridRows.map(function (futureGridRow) {
            return unifyDashboardLayoutItemHeightsForScreen(futureGridRow, screen);
        }));
        return itemsWithUnifiedHeight;
    }, itemsWithSizeForAllScreens);
    return itemsWithUnifiedHeightForAllScreens;
}
/**
 * Derive dashboard layout size for all screens from dashboard layout size defined for xl screen.
 *
 * @param xlSize - dashboard layout size for xl screen
 */
function implicitLayoutItemSizeFromXlSize(xlSize) {
    var xlWidth = xlSize.gridWidth;
    var xlHeight = xlSize.gridHeight;
    var ratio = xlSize.heightAsRatio;
    switch (xlWidth) {
        case 0:
            return dashboardLayoutItemSizeForAllScreens(0, 0, 0, 0, 0, 0, 0);
        case 1:
            return dashboardLayoutItemSizeForAllScreens(ratio, xlHeight, xlWidth, xlWidth, 2, 6, 12);
        case 2:
            return dashboardLayoutItemSizeForAllScreens(ratio, xlHeight, xlWidth, xlWidth, 4, 6, 12);
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
            return dashboardLayoutItemSizeForAllScreens(ratio, xlHeight, xlWidth, xlWidth, 6, 12, 12);
        case 10:
            return dashboardLayoutItemSizeForAllScreens(ratio, xlHeight, xlWidth, xlWidth, 12, 12, 12);
        case 11:
            return dashboardLayoutItemSizeForAllScreens(ratio, xlHeight, xlWidth, xlWidth, 12, 12, 12);
        case 12:
            return dashboardLayoutItemSizeForAllScreens(ratio, xlHeight, xlWidth, xlWidth, 12, 12, 12);
        default:
            invariant(false, "Unsupported xlWidth: " + xlWidth);
    }
}
/**
 * Create dashboard layout item size for all screens,
 * with identical height, defined as ratio,
 * but different width, defined as grid items count.
 *
 * @param heightAsRatio - height as ratio to the width, defined in percents
 * @param gridHeight - height as number of grid rows
 * @param xl - width as grid items count for xl screen
 * @param lg - width as grid items count for lg screen
 * @param md - width as grid items count for md screen
 * @param sm - width as grid items count for sm screen
 * @param xs - width as grid items count for xs screen
 */
function dashboardLayoutItemSizeForAllScreens(heightAsRatio, gridHeight, xl, lg, md, sm, xs) {
    if (gridHeight) {
        return {
            xl: {
                gridWidth: xl,
                gridHeight: gridHeight,
            },
            lg: {
                gridWidth: lg,
                gridHeight: gridHeight,
            },
            md: {
                gridWidth: md,
                gridHeight: gridHeight,
            },
            sm: {
                gridWidth: sm,
                gridHeight: gridHeight,
            },
            xs: {
                gridWidth: xs,
                gridHeight: gridHeight,
            },
        };
    }
    return {
        xl: {
            gridWidth: xl,
            heightAsRatio: heightAsRatio,
        },
        lg: {
            gridWidth: lg,
            heightAsRatio: heightAsRatio,
        },
        md: {
            gridWidth: md,
            heightAsRatio: heightAsRatio,
        },
        sm: {
            gridWidth: sm,
            heightAsRatio: heightAsRatio,
        },
        xs: {
            gridWidth: xs,
            heightAsRatio: heightAsRatio,
        },
    };
}
/**
 * Divide the items into a list representing the future rows of the grid.
 * This is useful for performing item transformations, depending on how they really appear in the grid.
 *
 * @param items - dashboard layout items
 * @param screen - responsive screen class
 */
export function splitDashboardLayoutItemsAsRenderedGridRows(items, screen) {
    var renderedRows = [];
    var currentRowWidth = 0;
    var currentRow = [];
    items.forEach(function (item) {
        var itemSize = item.size[screen];
        if (isNil(itemSize)) {
            throw Error("Item size for current screen is undefined");
        }
        if (currentRowWidth + itemSize.gridWidth > DASHBOARD_LAYOUT_GRID_COLUMNS_COUNT) {
            renderedRows.push(currentRow);
            currentRow = [];
            currentRowWidth = 0;
        }
        currentRow.push(item);
        currentRowWidth = currentRowWidth + itemSize.gridWidth;
    });
    if (currentRow.length > 0) {
        renderedRows.push(currentRow);
    }
    return renderedRows;
}
/**
 * Calculate dashboard layout item height for the provided screen.
 * Result, if custom height is defined, is height of the item, defined
 * as grid items count, multiplied by {@link GRID_ROW_HEIGHT_IN_PX} or width of the item,
 * defined as grid items count, multiplied by height, defined as a ratio.
 *
 * @param item - dashboard layout item
 * @param screen - responsive screen class
 */
function dashboardLayoutItemHeightForScreen(item, screen) {
    var _a, _b;
    var _c = (_b = (_a = item.size) === null || _a === void 0 ? void 0 : _a[screen]) !== null && _b !== void 0 ? _b : {}, gridWidth = _c.gridWidth, gridHeight = _c.gridHeight, _d = _c.heightAsRatio, heightAsRatio = _d === void 0 ? 0 : _d;
    if (!gridWidth) {
        return 0;
    }
    if (gridHeight) {
        return getDashboardLayoutItemHeightForGrid(gridHeight);
    }
    return gridWidth * heightAsRatio;
}
/**
 * Unify dashboard layout items height, defined as ratio, for the provided screen.
 * It overrides height of all items to the highest item height found for the provided screen.
 *
 * @param items - dashboard layout items
 * @param screen -  responsive screen class
 */
function unifyDashboardLayoutItemHeightsForScreen(items, screen) {
    var heights = items.map(function (item) { return dashboardLayoutItemHeightForScreen(item, screen); });
    var maxHeight = Math.max.apply(Math, __spread([0], heights));
    if (maxHeight === 0) {
        return items;
    }
    return items.map(function (item) { return updateDashboardLayoutItemHeight(item, screen, maxHeight); });
}
var updateDashboardLayoutItemHeight = function (item, screen, maxHeight) {
    var _a;
    var itemSizeForCurrentScreen = item.size[screen];
    var heightAsRatio = (itemSizeForCurrentScreen === null || itemSizeForCurrentScreen === void 0 ? void 0 : itemSizeForCurrentScreen.gridWidth) ? round(maxHeight / itemSizeForCurrentScreen.gridWidth, 2)
        : 0;
    var updatedColumn = item;
    if (!(itemSizeForCurrentScreen === null || itemSizeForCurrentScreen === void 0 ? void 0 : itemSizeForCurrentScreen.gridHeight) &&
        !isNil(itemSizeForCurrentScreen === null || itemSizeForCurrentScreen === void 0 ? void 0 : itemSizeForCurrentScreen.heightAsRatio) &&
        (itemSizeForCurrentScreen === null || itemSizeForCurrentScreen === void 0 ? void 0 : itemSizeForCurrentScreen.heightAsRatio) !== heightAsRatio) {
        if (isWidget(updatedColumn.widget) || isWidgetDefinition(updatedColumn.widget)) {
            updatedColumn = __assign(__assign({}, updatedColumn), { widget: __assign({}, updatedColumn.widget) });
        }
        updatedColumn = __assign(__assign({}, updatedColumn), { size: __assign(__assign({}, updatedColumn.size), (_a = {}, _a[screen] = __assign(__assign({}, updatedColumn.size[screen]), { heightAsRatio: heightAsRatio }), _a)) });
    }
    if (screen === "xs" && heightAsRatio > DASHBOARD_LAYOUT_MAX_HEIGHT_AS_RATIO_XS) {
        updatedColumn = __assign(__assign({}, updatedColumn), { size: __assign(__assign({}, updatedColumn.size), { xs: __assign(__assign({}, updatedColumn.size.xs), { heightAsRatio: DASHBOARD_LAYOUT_MAX_HEIGHT_AS_RATIO_XS }) }) });
    }
    return updatedColumn;
};
/**
 *
 * @internal
 */
export var getResizedItemPositions = function (originalLayout, resizedLayout, positions) {
    if (positions === void 0) { positions = []; }
    var originalLayoutFacade = DashboardLayoutFacade.for(originalLayout);
    return DashboardLayoutFacade.for(resizedLayout)
        .sections()
        .reduce(function (acc, section) {
        return section.items().reduce(function (acc, item) {
            var originalColumn = originalLayoutFacade
                .sections()
                .section(section.index())
                .items()
                .item(item.index());
            // if this bombs there is something wrong with the layout
            invariant(originalColumn);
            var originalContent = originalColumn.widget();
            var updatedContent = item.widget();
            // Is nested layout?
            if (isDashboardLayout(originalContent) && isDashboardLayout(updatedContent)) {
                return getResizedItemPositions(originalContent, updatedContent, positions);
            }
            if (!isEqual(originalColumn.size(), item.size()) &&
                (isWidget(updatedContent) || isWidgetDefinition(updatedContent))) {
                acc.push([item.section().index(), item.index()]);
            }
            return acc;
        }, acc);
    }, positions);
};
export var getDashboardLayoutItemHeight = function (size) {
    var gridHeight = size.gridHeight;
    if (gridHeight) {
        return getDashboardLayoutItemHeightForGrid(gridHeight);
    }
    return undefined;
};
export var getDashboardLayoutItemHeightForRatioAndScreen = function (size, screen) {
    // TODO is this default ok?
    var gridWidth = size.gridWidth, _a = size.heightAsRatio, heightAsRatio = _a === void 0 ? 1 : _a;
    var actualWidth = DASHBOARD_LAYOUT_CONTAINER_WIDTHS[screen];
    var actualColumnUnitWidth = actualWidth / DASHBOARD_LAYOUT_GRID_COLUMNS_COUNT;
    return actualColumnUnitWidth * gridWidth * (heightAsRatio / 100);
};
export var getDashboardLayoutItemHeightForGrid = function (gridHeight) {
    return gridHeight * GRID_ROW_HEIGHT_IN_PX;
};
export function getDashboardLayoutItemMaxGridWidth(item, screen) {
    var e_1, _a;
    var _b, _c;
    var gridRowWidth = 0;
    var sectionItems = item.section().items().all();
    try {
        for (var sectionItems_1 = __values(sectionItems), sectionItems_1_1 = sectionItems_1.next(); !sectionItems_1_1.done; sectionItems_1_1 = sectionItems_1.next()) {
            var sectionItem = sectionItems_1_1.value;
            var newWidth = sectionItem.sizeForScreen(screen).gridWidth + gridRowWidth;
            if (newWidth <= DASHBOARD_LAYOUT_GRID_COLUMNS_COUNT) {
                if (sectionItem.index() === item.index()) {
                    break;
                }
                gridRowWidth = newWidth;
            }
            else {
                if (sectionItem.index() === item.index()) {
                    return DASHBOARD_LAYOUT_GRID_COLUMNS_COUNT;
                }
                // TODO is this default ok?
                gridRowWidth = (_c = (_b = sectionItem.sizeForScreen(screen)) === null || _b === void 0 ? void 0 : _b.gridWidth) !== null && _c !== void 0 ? _c : 1;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (sectionItems_1_1 && !sectionItems_1_1.done && (_a = sectionItems_1.return)) _a.call(sectionItems_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return DASHBOARD_LAYOUT_GRID_COLUMNS_COUNT - gridRowWidth;
}
var getSizeInfo = function (settings, widgetType, widgetContent) {
    if (widgetType === "kpi") {
        return getKpiSizeInfo(settings, widgetContent);
    }
    return getVisualizationSizeInfo(settings, widgetContent);
};
var getVisualizationSizeInfo = function (settings, insight) {
    var sizeInfo;
    if (isInsight(insight)) {
        sizeInfo = getInsightSizeInfo(insight, settings);
    }
    if (!sizeInfo) {
        if (!settings.enableKDWidgetCustomHeight) {
            return INSIGHT_WIDGET_SIZE_INFO_DEFAULT_LEGACY;
        }
        return INSIGHT_WIDGET_SIZE_INFO_DEFAULT;
    }
    return sizeInfo;
};
var getKpiSizeInfo = function (settings, kpi) {
    if (!settings.enableKDWidgetCustomHeight) {
        return KPI_WIDGET_SIZE_INFO_DEFAULT_LEGACY;
    }
    if (!isLegacyKpi(kpi)) {
        return KPI_WIDGET_SIZE_INFO_DEFAULT;
    }
    return {
        width: {
            min: 2,
            default: 2,
        },
        height: isLegacyKpiWithoutComparison(kpi)
            ? {
                default: 8,
                min: 6,
                max: 40,
            }
            : {
                default: 11,
                min: 10,
                max: 40,
            },
    };
};
export function getDashboardLayoutWidgetMinGridWidth(settings, widgetType, widgetContent) {
    var sizeInfo = getSizeInfo(settings, widgetType, widgetContent);
    return sizeInfo.width.min;
}
export function getDashboardLayoutWidgetDefaultGridWidth(settings, widgetType, widgetContent) {
    var sizeInfo = getSizeInfo(settings, widgetType, widgetContent);
    return sizeInfo.width.default;
}
export function getDashboardLayoutWidgetDefaultHeight(settings, widgetType, widgetContent) {
    var sizeInfo = getSizeInfo(settings, widgetType, widgetContent);
    return fluidLayoutDescriptor.toHeightInPx(sizeInfo.height.default);
}
export function getDashboardLayoutWidgetMinGridHeight(settings, widgetType, widgetContent) {
    var sizeInfo = getSizeInfo(settings, widgetType, widgetContent);
    return sizeInfo.height.min;
}
export function getDashboardLayoutWidgetMaxGridHeight(settings, widgetType, widgetContent) {
    var sizeInfo = getSizeInfo(settings, widgetType, widgetContent);
    return sizeInfo.height.max;
}
export function getLayoutWithoutGridHeights(layout) {
    var layoutBuilder = DashboardLayoutBuilder.for(layout);
    return layoutBuilder
        .modifySections(function (section) {
        return section.modifyItems(function (itemBuilder, itemFacade) {
            var widget = itemFacade.widget();
            if (isDashboardLayout(widget)) {
                var updatedLayout = getLayoutWithoutGridHeights(widget);
                return itemBuilder.widget(updatedLayout);
            }
            var itemWithoutGridHeight = removeGridHeightFromItemSize(itemFacade.raw());
            return itemBuilder.setItem(itemWithoutGridHeight);
        });
    })
        .build();
}
function removeGridHeightFromItemSize(item) {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    var _a = item.size.xl, gridHeight = _a.gridHeight, rest = __rest(_a, ["gridHeight"]);
    return __assign(__assign({}, item), { size: __assign(__assign({}, item.size), { xl: __assign({}, rest) }) });
}
/**
 * @internal
 */
export function validateDashboardLayoutWidgetSize(currentWidth, currentHeight, widgetType, widgetContent, settings) {
    var minWidth = getDashboardLayoutWidgetMinGridWidth(settings, widgetType, widgetContent);
    var maxWidth = fluidLayoutDescriptor.gridColumnsCount;
    var minHeight = getDashboardLayoutWidgetMinGridHeight(settings, widgetType, widgetContent);
    var maxHeight = getDashboardLayoutWidgetMaxGridHeight(settings, widgetType, widgetContent);
    var validWidth = currentWidth !== undefined ? clamp(currentWidth, minWidth, maxWidth) : currentWidth;
    var validHeight = currentHeight !== undefined ? clamp(currentHeight, minHeight, maxHeight) : currentHeight;
    return {
        validWidth: validWidth,
        validHeight: validHeight,
    };
}
//# sourceMappingURL=sizing.js.map