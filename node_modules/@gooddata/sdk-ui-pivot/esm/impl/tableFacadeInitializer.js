import { isNoDataError, isUnexpectedResponseError, } from "@gooddata/sdk-backend-spi";
import { COLS_PER_PAGE } from "./base/constants";
import { getAvailableDrillTargets } from "./drilling/drillTargets";
import { convertError, DataViewFacade } from "@gooddata/sdk-ui";
import invariant from "ts-invariant";
import { TableFacade } from "./tableFacade";
var TableFacadeInitializer = /** @class */ (function () {
    function TableFacadeInitializer(execution, tableMethods, props) {
        var _this = this;
        this.execution = execution;
        this.tableMethods = tableMethods;
        this.props = props;
        this.abandoned = false;
        /**
         * Abandon the initialization. This will not cancel any requests that may be already in-flight. It will
         * ensure though that no events will be emitted and that the initalization ends with `undefined` result.
         */
        this.abandon = function () {
            invariant(!_this.abandoned);
            _this.abandoned = true;
        };
        /**
         * Drives initialization of the table facade. The initialization will emit all the essential
         * loading, error, onExportReady and pushData events using the callback functions specified in the {@link TableDataCallbacks}.
         *
         * If the initialization was abandoned at the right time, the result is 'undefined'. Otherwise the result
         * contains pointer to the initializer instance and the table facade itself.
         *
         * To prevent race conditions in situations when caller may create, start and abandon multiple initializations,
         * it is essential for the caller to check that the initialization result belongs to the currently active
         * initializer.
         */
        this.initialize = function () {
            var _a = _this, execution = _a.execution, tableMethods = _a.tableMethods;
            tableMethods.onLoadingChanged({ isLoading: true });
            return execution
                .execute()
                .then(function (result) {
                return result
                    .readWindow([0, 0], [_this.props.pageSize, COLS_PER_PAGE])
                    .then(function (dataView) {
                    if (_this.abandoned) {
                        /*
                         * Stop right now if the component gets unmounted while it is still being
                         * initialized.
                         */
                        return undefined;
                    }
                    var table = _this.createTableFacade(result, dataView);
                    tableMethods.onLoadingChanged({ isLoading: false });
                    tableMethods.onExportReady(table.createExportFunction(_this.props.exportTitle));
                    var availableDrillTargets = table.getAvailableDrillTargets();
                    tableMethods.pushData({ dataView: dataView, availableDrillTargets: availableDrillTargets });
                    return {
                        initializer: _this,
                        table: table,
                    };
                })
                    .catch(function (error) {
                    if (_this.abandoned) {
                        return undefined;
                    }
                    /**
                     * When execution result is received successfully,
                     * but data load fails with unexpected http response,
                     * we still want to push availableDrillTargets
                     */
                    if (isUnexpectedResponseError(error)) {
                        var availableDrillTargets = getAvailableDrillTargets(DataViewFacade.forResult(result));
                        _this.props.pushData({ availableDrillTargets: availableDrillTargets });
                    }
                    /*
                     * There can be situations, where there is no data to visualize but the result / dataView contains
                     * metadata essential for setup of drilling. Look for that and if available push up.
                     */
                    if (isNoDataError(error) && error.dataView) {
                        var availableDrillTargets = getAvailableDrillTargets(DataViewFacade.for(error.dataView));
                        tableMethods.pushData({ availableDrillTargets: availableDrillTargets });
                        tableMethods.onLoadingChanged({ isLoading: false });
                    }
                    tableMethods.onError(convertError(error), _this.execution);
                });
            })
                .catch(function (error) {
                if (_this.abandoned) {
                    return undefined;
                }
                tableMethods.onError(convertError(error), _this.execution);
            });
        };
        this.createTableFacade = function (result, dataView) {
            return new TableFacade(result, dataView, _this.tableMethods, _this.props);
        };
    }
    /**
     * Tests whether the other execution is the same as the one used by the initializer.
     *
     * @param other - other execution to test
     */
    TableFacadeInitializer.prototype.isSameExecution = function (other) {
        return this.execution.fingerprint() === other.fingerprint();
    };
    return TableFacadeInitializer;
}());
export { TableFacadeInitializer };
//# sourceMappingURL=tableFacadeInitializer.js.map