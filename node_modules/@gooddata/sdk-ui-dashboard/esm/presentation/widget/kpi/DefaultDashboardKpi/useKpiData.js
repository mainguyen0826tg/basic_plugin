import { __awaiter, __generator } from "tslib";
import { isAllTimeDateFilter, isDateFilter, isUriRef, newMeasure, newPopMeasure, newPreviousPeriodMeasure, } from "@gooddata/sdk-model";
import { useBackendStrict, useCancelablePromise, useWorkspaceStrict, } from "@gooddata/sdk-ui";
import invariant from "ts-invariant";
import { filterContextItemsToFiltersForWidget } from "../../../../converters";
import { useWidgetFilters } from "../../common";
import { useMemo } from "react";
/**
 * @internal
 */
export function useKpiData(_a) {
    var _this = this;
    var kpiWidget = _a.kpiWidget, filters = _a.filters, dashboardFilters = _a.dashboardFilters, backend = _a.backend, workspace = _a.workspace;
    var effectiveBackend = useBackendStrict(backend);
    var effectiveWorkspace = useWorkspaceStrict(workspace);
    var convertedFilters = useMemo(function () { return filters && kpiWidget && filterContextItemsToFiltersForWidget(filters, kpiWidget); }, [filters, kpiWidget]);
    var _b = useWidgetFilters(kpiWidget, convertedFilters), status = _b.status, result = _b.result;
    // we only put IDashboardFilters in, so we must get IDashboardFilters out as well
    var effectiveFilters = result;
    var promise = kpiWidget && dashboardFilters && effectiveFilters && status === "success"
        ? function () { return __awaiter(_this, void 0, void 0, function () {
            var allFilters, primaryMeasure, comparison, isAllTime, secondaryMeasure, secondaryMeasure;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        invariant(kpiWidget.kpi, "The provided widget is not a KPI widget.");
                        allFilters = filterContextItemsToFiltersForWidget(dashboardFilters, kpiWidget);
                        primaryMeasure = newMeasure(kpiWidget.kpi.metric);
                        comparison = kpiWidget.kpi.comparisonType;
                        isAllTime = !effectiveFilters ||
                            !effectiveFilters.some(function (filter) { return isDateFilter(filter) && !isAllTimeDateFilter(filter); });
                        if (comparison === "none" || isAllTime) {
                            return [2 /*return*/, { primaryMeasure: primaryMeasure, effectiveFilters: effectiveFilters, allFilters: allFilters }];
                        }
                        if (comparison === "previousPeriod") {
                            invariant(kpiWidget.dateDataSet, "Inconsistent KPI in useKpiData, it has comparison but not dateDataset");
                            secondaryMeasure = newPreviousPeriodMeasure(primaryMeasure, [
                                { dataSet: kpiWidget.dateDataSet, periodsAgo: 1 },
                            ]);
                            return [2 /*return*/, { primaryMeasure: primaryMeasure, secondaryMeasure: secondaryMeasure, effectiveFilters: effectiveFilters, allFilters: allFilters }];
                        }
                        if (!(comparison === "lastYear")) return [3 /*break*/, 2];
                        invariant(kpiWidget.dateDataSet, "Inconsistent KPI in useKpiData, it has comparison but not dateDataset");
                        return [4 /*yield*/, getLastYearComparisonMeasure(effectiveBackend, effectiveWorkspace, primaryMeasure, kpiWidget.dateDataSet)];
                    case 1:
                        secondaryMeasure = _a.sent();
                        return [2 /*return*/, { primaryMeasure: primaryMeasure, secondaryMeasure: secondaryMeasure, effectiveFilters: effectiveFilters, allFilters: allFilters }];
                    case 2:
                        invariant(false, "Unknown comparison " + comparison);
                        return [2 /*return*/];
                }
            });
        }); }
        : null;
    return useCancelablePromise({ promise: promise }, [
        effectiveBackend,
        effectiveWorkspace,
        effectiveFilters,
        kpiWidget,
    ]);
}
function getLastYearComparisonMeasure(backend, workspace, primaryMeasure, targetDateDataset) {
    return __awaiter(this, void 0, void 0, function () {
        var catalog, dateDatasets, relevantDateDataset, yearAttribute;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, backend.workspace(workspace).catalog().forTypes(["dateDataset"]).load()];
                case 1:
                    catalog = _a.sent();
                    dateDatasets = catalog.dateDatasets();
                    relevantDateDataset = dateDatasets.find(function (dateDataset) {
                        if (isUriRef(targetDateDataset)) {
                            return dateDataset.dataSet.uri === targetDateDataset.uri;
                        }
                        else {
                            return dateDataset.dataSet.id === targetDateDataset.identifier;
                        }
                    });
                    invariant(relevantDateDataset, "Cannot find relevant date dataset in useKpiData");
                    yearAttribute = relevantDateDataset.dateAttributes.find(function (dateAttribute) { return dateAttribute.granularity === "GDC.time.year"; });
                    invariant(yearAttribute, "Cannot find yearAttribute in useKpiData");
                    return [2 /*return*/, newPopMeasure(primaryMeasure, yearAttribute.attribute.ref)];
            }
        });
    });
}
//# sourceMappingURL=useKpiData.js.map