import { __assign, __awaiter, __generator, __spreadArrays } from "tslib";
// (C) 2019-2021 GoodData Corporation
import { isCatalogFact, isCatalogMeasure, } from "@gooddata/sdk-backend-spi";
import partition from "lodash/partition";
import uniq from "lodash/uniq";
import flatMap from "lodash/flatMap";
import keyBy from "lodash/keyBy";
import { GdcCatalog, GdcMetadata } from "@gooddata/api-model-bear";
import { convertAttribute, convertDateDataset, convertFact, convertGroup, convertItemType, convertMeasure, convertMetric, isCompatibleCatalogItemType, } from "../../../convertors/fromBackend/CatalogConverter";
import { BearWorkspaceCatalog } from "./catalog";
import { objRefsToIdentifiers, objRefToIdentifier } from "../../../utils/api";
import { isApiResponseError } from "../../../utils/errorHandling";
var bearCatalogItemToCatalogItem = function (displayForms, attributes) {
    return function (item) {
        if (GdcCatalog.isCatalogAttribute(item)) {
            return convertAttribute(item, displayForms, attributes);
        }
        else if (GdcCatalog.isCatalogMetric(item)) {
            return convertMeasure(item);
        }
        return convertFact(item);
    };
};
var createLookups = function (displayFormsAndAttributes) {
    var _a = partition(displayFormsAndAttributes, GdcMetadata.isWrappedAttribute), attributes = _a[0], displayForms = _a[1];
    var unwrappedDisplayForms = displayForms.map(function (df) { return df.attributeDisplayForm; });
    var attributeByUri = keyBy(attributes, function (item) { return item.attribute.meta.uri; });
    var attributeById = keyBy(attributes, function (item) { return item.attribute.meta.identifier; });
    var displayFormByUri = keyBy(unwrappedDisplayForms, function (item) { return item.meta.uri; });
    var displayFormById = keyBy(unwrappedDisplayForms, function (item) { return item.meta.identifier; });
    var attributeByDisplayFormUri = Object.keys(displayFormByUri).reduce(function (acc, displayFormUri) {
        var _a;
        var displayForm = displayFormByUri[displayFormUri];
        var attributeUri = displayForm.content.formOf;
        var attribute = attributeByUri[attributeUri];
        return __assign(__assign({}, acc), (_a = {}, _a[displayFormUri] = attribute, _a));
    }, {});
    return {
        attributeById: attributeById,
        attributeByDisplayFormUri: attributeByDisplayFormUri,
        displayFormById: displayFormById,
        displayFormByUri: displayFormByUri,
    };
};
var getProductionFlag = function (_a) {
    var production = _a.production, dataset = _a.dataset;
    // if production is undefined, leave it as is - it has meaning
    if (production === undefined) {
        return production;
    }
    // if a dataset is specified, production must be false
    var sanitizedProduction = !dataset && production;
    return sanitizedProduction ? 1 : 0;
};
var groupableCatalogItemTypes = ["attribute", "measure", "fact"];
var isGroupableCatalogItemType = function (type) { return groupableCatalogItemTypes.includes(type); };
var BearWorkspaceCatalogFactory = /** @class */ (function () {
    function BearWorkspaceCatalogFactory(authCall, workspace, options) {
        var _this = this;
        if (options === void 0) { options = {
            types: ["attribute", "measure", "fact", "dateDataset"],
            excludeTags: [],
            includeTags: [],
        }; }
        this.authCall = authCall;
        this.workspace = workspace;
        this.options = options;
        this.tagsAndDatasetIdsPromise = null;
        this.loadAllCatalogItemsAndMappings = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, bearCatalogItems, bearUnlistedMetrics, bearDateDatasets, bearDisplayFormsAndAttributes, _b, attributeByDisplayFormUri, displayFormById, displayFormByUri, attributeById, catalogItems, catalogWithUnlisted, dateDatasets, allCatalogItems, measureById, factById, dateAttributeById;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.loadBearCatalogItems(),
                            this.loadBearUnlistedMetrics(),
                            this.loadDateDatasets(),
                        ])];
                    case 1:
                        _a = _c.sent(), bearCatalogItems = _a[0], bearUnlistedMetrics = _a[1], bearDateDatasets = _a[2];
                        return [4 /*yield*/, this.loadBearDisplayFormsAndAttributes(bearCatalogItems, flatMap(bearDateDatasets, function (dd) { var _a; return (_a = dd.availableDateAttributes) !== null && _a !== void 0 ? _a : []; }))];
                    case 2:
                        bearDisplayFormsAndAttributes = _c.sent();
                        _b = createLookups(bearDisplayFormsAndAttributes), attributeByDisplayFormUri = _b.attributeByDisplayFormUri, displayFormById = _b.displayFormById, displayFormByUri = _b.displayFormByUri, attributeById = _b.attributeById;
                        catalogItems = bearCatalogItems.map(bearCatalogItemToCatalogItem(displayFormByUri, attributeById));
                        catalogWithUnlisted = this.withUpdatedUnlistedFlag(catalogItems, bearUnlistedMetrics);
                        dateDatasets = bearDateDatasets.map(function (dd) { return convertDateDataset(dd, attributeById); });
                        allCatalogItems = catalogWithUnlisted.concat(dateDatasets);
                        measureById = keyBy(catalogWithUnlisted.filter(isCatalogMeasure).map(function (el) { return el.measure; }), function (el) { return el.id; });
                        factById = keyBy(catalogItems.filter(isCatalogFact).map(function (el) { return el.fact; }), function (el) { return el.id; });
                        dateAttributeById = keyBy(flatMap(dateDatasets, function (dd) { return dd.dateAttributes; }), function (attr) { return attr.attribute.id; });
                        return [2 /*return*/, {
                                allCatalogItems: allCatalogItems,
                                mappings: {
                                    attributeById: attributeById,
                                    attributeByDisplayFormUri: attributeByDisplayFormUri,
                                    displayFormById: displayFormById,
                                    measureById: measureById,
                                    factById: factById,
                                    dateAttributeById: dateAttributeById,
                                },
                            }];
                }
            });
        }); };
        this.loadDateDatasets = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, types, production, includeDateGranularities, includeDateDatasets, _b, includeTagsIds, excludeTagsIds, dataSetId, shouldReturnAllDateDataSets, result;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.options, types = _a.types, production = _a.production, includeDateGranularities = _a.includeDateGranularities;
                        includeDateDatasets = types.includes("dateDataset");
                        if (!includeDateDatasets) {
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, this.getTagsAndDatasetIds()];
                    case 1:
                        _b = _c.sent(), includeTagsIds = _b.includeTagsIds, excludeTagsIds = _b.excludeTagsIds, dataSetId = _b.dataSetId;
                        shouldReturnAllDateDataSets = !production && !dataSetId;
                        return [4 /*yield*/, this.authCall(function (sdk) {
                                return sdk.catalogue.loadDateDataSets(_this.workspace, {
                                    returnAllDateDataSets: shouldReturnAllDateDataSets,
                                    dataSetIdentifier: dataSetId,
                                    excludeObjectsWithTags: excludeTagsIds.length ? excludeTagsIds : undefined,
                                    includeObjectsWithTags: includeTagsIds.length ? includeTagsIds : undefined,
                                    includeDateGranularities: includeDateGranularities,
                                });
                            })];
                    case 2:
                        result = _c.sent();
                        return [2 /*return*/, result.dateDataSets];
                }
            });
        }); };
        this.loadBearCatalogItems = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, types, dataset, compatibleBearItemTypes, _b, includeTagsIds, excludeTagsIds, dataSetId, bearItemTypes;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.options, types = _a.types, dataset = _a.dataset;
                        compatibleBearItemTypes = types.filter(isCompatibleCatalogItemType);
                        if (compatibleBearItemTypes.length === 0) {
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, this.getTagsAndDatasetIds()];
                    case 1:
                        _b = _c.sent(), includeTagsIds = _b.includeTagsIds, excludeTagsIds = _b.excludeTagsIds, dataSetId = _b.dataSetId;
                        bearItemTypes = compatibleBearItemTypes.map(convertItemType);
                        return [2 /*return*/, this.authCall(function (sdk) {
                                return sdk.catalogue.loadAllItems(_this.workspace, {
                                    types: bearItemTypes,
                                    includeWithTags: includeTagsIds.length ? includeTagsIds : undefined,
                                    excludeWithTags: excludeTagsIds.length ? excludeTagsIds : undefined,
                                    production: getProductionFlag(_this.options),
                                    csvDataSets: dataset ? [dataSetId] : [],
                                });
                            })];
                }
            });
        }); };
        /**
         * Loads unlisted metrics using /query resource. This is a shortcoming of the current
         * catalog items implementation. The unlisted items do not come back in /items resource - however,
         * they are needed to augment existing insights with metadata measures that MAY be unlisted.
         *
         * Previously, AD used to ignore catalog items when augmenting insights with bucket item metadata - instead
         * it was fetching the items as it found them. Now we try to position catalog as a single source of truth
         * and use just the catalog items for everything.
         */
        this.loadBearUnlistedMetrics = function () { return __awaiter(_this, void 0, void 0, function () {
            var types, compatibleBearItemTypes, queryOptions;
            var _this = this;
            return __generator(this, function (_a) {
                types = this.options.types;
                compatibleBearItemTypes = types.filter(function (item) { return item === "measure"; });
                if (compatibleBearItemTypes.length === 0) {
                    return [2 /*return*/, []];
                }
                queryOptions = {
                    category: "metric",
                    limit: 50,
                };
                return [2 /*return*/, this.authCall(function (sdk) {
                        return sdk.md
                            .getObjectsByQuery(_this.workspace, queryOptions)
                            .then(function (metrics) {
                            return metrics.filter(function (metric) { return metric.metric.meta.unlisted; }).map(convertMetric);
                        })
                            .catch(function (err) {
                            if (isApiResponseError(err) && err.response.status === 404) {
                                /*
                                 * Mock-server (mock-js) for GD platform does not support the md query resource.
                                 * Instead of enhancing the mock-js, code here opts to fallback to empty list
                                 * in case the query resource does not exist.
                                 */
                                return [];
                            }
                            throw err;
                        });
                    })];
            });
        }); };
        this.loadBearDisplayFormsAndAttributes = function (bearCatalogItems, dateDatasetAttributes) { return __awaiter(_this, void 0, void 0, function () {
            var types, shouldLoadAttributes, bearCatalogAttributes, attributeUris, displayFormUris, dateAttributeUris;
            var _this = this;
            return __generator(this, function (_a) {
                types = this.options.types;
                shouldLoadAttributes = types.some(function (type) { return type === "attribute" || type === "dateDataset"; });
                if (!shouldLoadAttributes) {
                    return [2 /*return*/, []];
                }
                bearCatalogAttributes = bearCatalogItems.filter(GdcCatalog.isCatalogAttribute);
                attributeUris = bearCatalogAttributes.map(function (attr) { return attr.links.self; });
                displayFormUris = flatMap(bearCatalogAttributes, function (attr) {
                    var _a;
                    var geoPins = (_a = attr.links.geoPinDisplayForms) !== null && _a !== void 0 ? _a : [];
                    return __spreadArrays([attr.links.defaultDisplayForm], geoPins);
                });
                dateAttributeUris = dateDatasetAttributes.map(function (attr) { return attr.attributeMeta.uri; });
                return [2 /*return*/, this.authCall(function (sdk) {
                        return sdk.md.getObjects(_this.workspace, uniq(__spreadArrays(attributeUris, displayFormUris, dateAttributeUris)));
                    })];
            });
        }); };
        this.loadCatalogGroups = function () { return __awaiter(_this, void 0, void 0, function () {
            var types, shouldLoadGroups, dataset, _a, includeTagsIds, excludeTagsIds, dataSetId, bearCatalogGroups;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        types = this.options.types;
                        shouldLoadGroups = types.some(isGroupableCatalogItemType);
                        if (!shouldLoadGroups) {
                            return [2 /*return*/, []];
                        }
                        dataset = this.options.dataset;
                        return [4 /*yield*/, this.getTagsAndDatasetIds()];
                    case 1:
                        _a = _b.sent(), includeTagsIds = _a.includeTagsIds, excludeTagsIds = _a.excludeTagsIds, dataSetId = _a.dataSetId;
                        return [4 /*yield*/, this.authCall(function (sdk) {
                                return sdk.catalogue.loadGroups(_this.workspace, {
                                    includeWithTags: includeTagsIds.length ? includeTagsIds : undefined,
                                    excludeWithTags: excludeTagsIds.length ? excludeTagsIds : undefined,
                                    production: getProductionFlag(_this.options),
                                    csvDataSets: dataset ? [dataSetId] : [],
                                });
                            })];
                    case 2:
                        bearCatalogGroups = _b.sent();
                        return [2 /*return*/, bearCatalogGroups.map(convertGroup)];
                }
            });
        }); };
        this.getTagsAndDatasetIds = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, dataset, includeTags, excludeTags;
            return __generator(this, function (_b) {
                if (!this.tagsAndDatasetIdsPromise) {
                    _a = this.options, dataset = _a.dataset, includeTags = _a.includeTags, excludeTags = _a.excludeTags;
                    this.tagsAndDatasetIdsPromise = Promise.all([
                        objRefsToIdentifiers(includeTags, this.authCall),
                        objRefsToIdentifiers(excludeTags, this.authCall),
                        dataset ? objRefToIdentifier(dataset, this.authCall) : Promise.resolve(""),
                    ]).then(function (_a) {
                        var includeTagsIds = _a[0], excludeTagsIds = _a[1], dataSetId = _a[2];
                        return ({
                            dataSetId: dataSetId,
                            excludeTagsIds: excludeTagsIds,
                            includeTagsIds: includeTagsIds,
                        });
                    });
                }
                return [2 /*return*/, this.tagsAndDatasetIdsPromise];
            });
        }); };
        this.withUpdatedUnlistedFlag = function (catalogItems, bearUnlistedMetrics) {
            var catalogWithUnlisted = __spreadArrays(catalogItems);
            bearUnlistedMetrics.forEach(function (metric) {
                var existingMeasure = catalogItems.find(function (item) { return isCatalogMeasure(item) && item.measure.uri === metric.measure.uri; });
                if (existingMeasure) {
                    existingMeasure.measure.unlisted = true;
                }
            });
            return catalogWithUnlisted;
        };
    }
    BearWorkspaceCatalogFactory.prototype.withOptions = function (options) {
        var newOptions = __assign(__assign({}, this.options), options);
        return new BearWorkspaceCatalogFactory(this.authCall, this.workspace, newOptions);
    };
    BearWorkspaceCatalogFactory.prototype.forDataset = function (dataset) {
        return this.withOptions({
            dataset: dataset,
        });
    };
    BearWorkspaceCatalogFactory.prototype.forTypes = function (types) {
        return this.withOptions({
            types: types,
        });
    };
    BearWorkspaceCatalogFactory.prototype.includeTags = function (tags) {
        return this.withOptions({
            includeTags: tags,
        });
    };
    BearWorkspaceCatalogFactory.prototype.excludeTags = function (tags) {
        return this.withOptions({
            excludeTags: tags,
        });
    };
    BearWorkspaceCatalogFactory.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, allCatalogItems, mappings, catalogGroups;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, Promise.all([
                            this.loadAllCatalogItemsAndMappings(),
                            this.loadCatalogGroups(),
                        ])];
                    case 1:
                        _a = _c.sent(), _b = _a[0], allCatalogItems = _b.allCatalogItems, mappings = _b.mappings, catalogGroups = _a[1];
                        return [2 /*return*/, new BearWorkspaceCatalog(this.authCall, this.workspace, catalogGroups, allCatalogItems, this.options, mappings)];
                }
            });
        });
    };
    return BearWorkspaceCatalogFactory;
}());
export { BearWorkspaceCatalogFactory };
//# sourceMappingURL=factory.js.map