import { __spreadArrays } from "tslib";
// (C) 2007-2021 GoodData Corporation
import head from "lodash/head";
import isEmpty from "lodash/isEmpty";
import { isAreaChart, isOneOfTypes, isTreemap } from "../chartTypes/_util/common";
import { VisualizationTypes } from "@gooddata/sdk-ui";
import { supportedDualAxesChartTypes } from "../chartTypes/_chartOptions/chartCapabilities";
export var RESPONSIVE_ITEM_MIN_WIDTH = 200;
export var RESPONSIVE_VISIBLE_ROWS = 2;
export var FLUID_PAGING_WIDTH = 30;
export var LEGEND_PADDING = 12;
export var ITEM_HEIGHT = 20;
export var SKIPPED_LABEL_TEXT = "...";
export var UTF_NON_BREAKING_SPACE = "\u00A0";
var STATIC_PAGING_HEIGHT = 44;
export function calculateFluidLegend(seriesCount, containerWidth) {
    // -1 because flex dimensions provide rounded number and the real width can be float
    var realWidth = containerWidth - 2 * LEGEND_PADDING - 1;
    if (seriesCount <= 2) {
        return {
            hasPaging: false,
            itemWidth: realWidth / seriesCount,
            visibleItemsCount: seriesCount,
        };
    }
    var columnsCount = Math.floor(realWidth / RESPONSIVE_ITEM_MIN_WIDTH);
    var itemWidth = realWidth / columnsCount;
    var hasPaging = false;
    var rowsCount = Math.ceil(seriesCount / columnsCount);
    // Recalculate with paging
    if (rowsCount > RESPONSIVE_VISIBLE_ROWS) {
        var legendWidthWithPaging = realWidth - FLUID_PAGING_WIDTH;
        columnsCount = Math.floor(legendWidthWithPaging / RESPONSIVE_ITEM_MIN_WIDTH);
        itemWidth = legendWidthWithPaging / columnsCount;
        hasPaging = true;
    }
    var visibleItemsCount = columnsCount * RESPONSIVE_VISIBLE_ROWS;
    return {
        itemWidth: itemWidth,
        hasPaging: hasPaging,
        visibleItemsCount: visibleItemsCount,
    };
}
function getStaticVisibleItemsCount(containerHeight, withPaging) {
    if (withPaging === void 0) { withPaging = false; }
    var pagingHeight = withPaging ? STATIC_PAGING_HEIGHT : 0;
    return Math.floor((containerHeight - pagingHeight) / ITEM_HEIGHT);
}
export function calculateStaticLegend(seriesCount, containerHeight) {
    var visibleItemsCount = getStaticVisibleItemsCount(containerHeight);
    if (visibleItemsCount >= seriesCount) {
        return {
            hasPaging: false,
            visibleItemsCount: visibleItemsCount,
        };
    }
    return {
        hasPaging: true,
        visibleItemsCount: getStaticVisibleItemsCount(containerHeight, true),
    };
}
var LEGEND_TEXT_KEYS = {
    column: ["left", "right"],
    line: ["left", "right"],
    bar: ["bottom", "top"],
    area: ["left", "right"],
    combo: ["left", "right"],
    combo2: ["left", "right"],
};
export var LEGEND_AXIS_INDICATOR = "legendAxisIndicator";
export var LEGEND_SEPARATOR = "legendSeparator";
function separateLegendItems(series) {
    return series.reduce(function (result, item) {
        // for now, it assumes that GDC chart only has 2 Y axes in maximum
        // yAxis only takes 0 (left/bottom axis) or 1 (right/top axis)
        var yAxis = item.yAxis;
        if (!yAxis) {
            // 0
            result.itemsOnFirstAxis.push(item);
        }
        else {
            result.itemsOnSecondAxis.push(item);
        }
        return result;
    }, {
        itemsOnFirstAxis: [],
        itemsOnSecondAxis: [],
    });
}
export function groupSeriesItemsByType(series) {
    var _a;
    var primaryType = (_a = head(series)) === null || _a === void 0 ? void 0 : _a.type;
    return series.reduce(function (result, item) {
        if (primaryType === item.type) {
            result.primaryItems.push(item);
        }
        else {
            result.secondaryItems.push(item);
        }
        return result;
    }, {
        primaryItems: [],
        secondaryItems: [],
    });
}
export function getComboChartSeries(series) {
    var _a = groupSeriesItemsByType(series), primaryItems = _a.primaryItems, secondaryItems = _a.secondaryItems;
    var primaryItem = head(primaryItems) || {};
    var secondaryItem = head(secondaryItems) || {};
    var primaryType = primaryItem.type || VisualizationTypes.COLUMN;
    var secondaryType = secondaryItem.type || VisualizationTypes.LINE;
    var _b = LEGEND_TEXT_KEYS.combo, firstAxisKey = _b[0], secondAxisKey = _b[1];
    // convert to dual axis series when there is only one chart type
    if (isEmpty(secondaryItems)) {
        return transformToDualAxesSeries(series, primaryType);
    }
    // all measures display on same axis
    if (primaryItem.yAxis === secondaryItem.yAxis) {
        return __spreadArrays([
            { type: LEGEND_AXIS_INDICATOR, labelKey: primaryType }
        ], primaryItems, [
            { type: LEGEND_SEPARATOR },
            { type: LEGEND_AXIS_INDICATOR, labelKey: secondaryType }
        ], secondaryItems);
    }
    return __spreadArrays([
        {
            type: LEGEND_AXIS_INDICATOR,
            labelKey: VisualizationTypes.COMBO,
            data: [primaryType, firstAxisKey],
        }
    ], primaryItems, [
        { type: LEGEND_SEPARATOR },
        {
            type: LEGEND_AXIS_INDICATOR,
            labelKey: VisualizationTypes.COMBO,
            data: [secondaryType, secondAxisKey],
        }
    ], secondaryItems);
}
export function createDualAxesSeriesMapper(chartType) {
    return function (series) {
        return transformToDualAxesSeries(series, chartType);
    };
}
export function transformToDualAxesSeries(series, chartType) {
    var _a = separateLegendItems(series), itemsOnFirstAxis = _a.itemsOnFirstAxis, itemsOnSecondAxis = _a.itemsOnSecondAxis;
    if (!isOneOfTypes(chartType, supportedDualAxesChartTypes) ||
        !itemsOnFirstAxis.length ||
        !itemsOnSecondAxis.length) {
        return series;
    }
    var _b = LEGEND_TEXT_KEYS[chartType], firstAxisKey = _b[0], secondAxisKey = _b[1];
    return __spreadArrays([
        { type: LEGEND_AXIS_INDICATOR, labelKey: firstAxisKey }
    ], itemsOnFirstAxis, [
        { type: LEGEND_SEPARATOR },
        { type: LEGEND_AXIS_INDICATOR, labelKey: secondAxisKey }
    ], itemsOnSecondAxis);
}
export function isStackedChart(chartOptions) {
    var _a, _b;
    var seriesLength = (_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.data) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b.length;
    var type = chartOptions.type, stacking = chartOptions.stacking, hasStackByAttribute = chartOptions.hasStackByAttribute;
    var hasMoreThanOneSeries = seriesLength > 1;
    var isAreaChartWithOneSerie = isAreaChart(type) && !hasMoreThanOneSeries && !hasStackByAttribute;
    return !isAreaChartWithOneSerie && !isTreemap(type) && Boolean(stacking);
}
//# sourceMappingURL=legendHelpers.js.map