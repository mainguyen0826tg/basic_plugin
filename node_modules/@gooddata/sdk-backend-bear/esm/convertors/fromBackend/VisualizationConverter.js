import { __assign } from "tslib";
// (C) 2019-2021 GoodData Corporation
import { uriRef, } from "@gooddata/sdk-model";
import compact from "lodash/compact";
import isEmpty from "lodash/isEmpty";
import isNil from "lodash/isNil";
import omit from "lodash/omit";
import { GdcVisualizationObject } from "@gooddata/api-model-bear";
import { convertReferencesToUris } from "./ReferenceConverter";
import { deserializeProperties, serializeProperties } from "./PropertiesConverter";
import { fromBearRef, fromScopedBearRef } from "./ObjRefConverter";
// we use more lenient uri "detection" here because the one in bear-client makes some legacy data fail
// as the objId is not always just a number
var isUriLike = function (value) { return /\/gdc\/md\/\S+\/obj\/\S+/.test(value); };
var convertAttributeElements = function (items) {
    if (!items.length) {
        // in case of empty filter assume that it is meant to be an URI-based one as these are much more common on bear
        return { uris: [] };
    }
    // we assume that all the items either use uris, or values, not both, since there is no way of representing the mixed variant
    var first = items[0];
    return isUriLike(first) ? { uris: items } : { values: items };
};
var convertMeasureValueFilter = function (filter) {
    return {
        measureValueFilter: {
            condition: filter.measureValueFilter.condition,
            measure: fromScopedBearRef(filter.measureValueFilter.measure, "measure"),
        },
    };
};
var convertRankingFilter = function (filter) {
    var _a = filter.rankingFilter, measures = _a.measures, operator = _a.operator, value = _a.value, attributes = _a.attributes;
    return {
        rankingFilter: {
            measure: fromScopedBearRef(measures[0], "measure"),
            operator: operator,
            value: value,
            attributes: attributes,
        },
    };
};
var convertFilter = function (filter) {
    if (GdcVisualizationObject.isMeasureValueFilter(filter)) {
        return convertMeasureValueFilter(filter);
    }
    else if (GdcVisualizationObject.isRankingFilter(filter)) {
        return convertRankingFilter(filter);
    }
    else {
        return convertMeasureFilter(filter);
    }
};
var convertMeasureFilter = function (filter) {
    if (GdcVisualizationObject.isAttributeFilter(filter)) {
        if (GdcVisualizationObject.isPositiveAttributeFilter(filter)) {
            return {
                positiveAttributeFilter: {
                    displayForm: fromBearRef(filter.positiveAttributeFilter.displayForm, "displayForm"),
                    in: convertAttributeElements(filter.positiveAttributeFilter.in),
                },
            };
        }
        return {
            negativeAttributeFilter: {
                displayForm: fromBearRef(filter.negativeAttributeFilter.displayForm, "displayForm"),
                notIn: convertAttributeElements(filter.negativeAttributeFilter.notIn),
            },
        };
    }
    else {
        if (GdcVisualizationObject.isAbsoluteDateFilter(filter)) {
            return {
                absoluteDateFilter: {
                    dataSet: fromBearRef(filter.absoluteDateFilter.dataSet, "dataSet"),
                    from: filter.absoluteDateFilter.from || "",
                    to: filter.absoluteDateFilter.to || "",
                },
            };
        }
        // check for all-time filters with missing bounds (even one missing bound suggests an all time filter)
        // we cannot remove them, as they do make sense in some rare legacy contexts
        if (isNil(filter.relativeDateFilter.from) || isNil(filter.relativeDateFilter.to)) {
            // eslint-disable-next-line no-console
            console.warn("RelativeDateFilter without 'from' or 'to' field encountered." +
                "This can make sense in some legacy contexts (e.g. PoP measures with All time global filter), but generally, this indicates an error." +
                "Please check the visualization object data to make sure the relativeDateFilter data is what you expected.");
        }
        return {
            relativeDateFilter: __assign(__assign({}, filter.relativeDateFilter), { granularity: filter.relativeDateFilter.granularity, from: filter.relativeDateFilter.from, to: filter.relativeDateFilter.to }),
        };
    }
};
var convertMeasureDefinition = function (definition) {
    if (GdcVisualizationObject.isArithmeticMeasureDefinition(definition)) {
        return definition;
    }
    if (GdcVisualizationObject.isPopMeasureDefinition(definition)) {
        return definition;
    }
    if (GdcVisualizationObject.isPreviousPeriodMeasureDefinition(definition)) {
        return definition;
    }
    var filters = definition.measureDefinition.filters;
    return {
        measureDefinition: __assign(__assign({}, definition.measureDefinition), { filters: filters ? compact(filters.map(convertMeasureFilter)) : [] }),
    };
};
var convertMeasure = function (measure) {
    var definition = measure.measure.definition;
    return {
        measure: __assign(__assign({}, measure.measure), { definition: convertMeasureDefinition(definition) }),
    };
};
var convertAttribute = function (attribute) {
    return {
        attribute: __assign(__assign({}, attribute.visualizationAttribute), { displayForm: fromBearRef(attribute.visualizationAttribute.displayForm, "displayForm") }),
    };
};
var convertBucketItem = function (bucketItem) {
    return GdcVisualizationObject.isMeasure(bucketItem)
        ? convertMeasure(bucketItem)
        : convertAttribute(bucketItem);
};
var convertBucket = function (bucket) {
    return {
        items: bucket.items.map(convertBucketItem),
        localIdentifier: bucket.localIdentifier,
        totals: bucket.totals,
    };
};
var resolveReferences = function (mdObject) {
    var content = mdObject.content;
    if (!content) {
        return mdObject;
    }
    var properties = content.properties;
    if (!properties) {
        return mdObject;
    }
    var _a = convertReferencesToUris({
        properties: deserializeProperties(properties),
        references: content.references || {},
    }), convertedProperties = _a.properties, convertedReferences = _a.references;
    // set the new properties and references
    var referencesProp = isEmpty(convertedReferences) ? undefined : { references: convertedReferences };
    return __assign(__assign({}, mdObject), { content: __assign(__assign(__assign({}, omit(mdObject.content, "references")), { properties: serializeProperties(convertedProperties) }), referencesProp) });
};
/**
 *
 * @internal
 */
export var convertVisualization = function (visualization, visualizationClassUri, userMap) {
    var _a, _b;
    var withResolvedReferences = resolveReferences(visualization.visualizationObject);
    var content = withResolvedReferences.content, meta = withResolvedReferences.meta;
    var parsedProperties = deserializeProperties(content.properties);
    return {
        insight: {
            buckets: content.buckets.map(convertBucket),
            filters: content.filters ? compact(content.filters.map(convertFilter)) : [],
            ref: uriRef(meta.uri),
            // we assume that identifier is always defined for visualizations
            identifier: meta.identifier,
            properties: parsedProperties,
            sorts: parsedProperties.sortItems || [],
            title: meta.title,
            uri: meta.uri,
            visualizationUrl: visualizationClassUri,
            created: meta.created,
            createdBy: meta.author ? userMap === null || userMap === void 0 ? void 0 : userMap.get(meta.author) : undefined,
            updated: meta.updated,
            updatedBy: meta.contributor ? userMap === null || userMap === void 0 ? void 0 : userMap.get(meta.contributor) : undefined,
            isLocked: meta.locked,
            tags: (_b = (_a = meta.tags) === null || _a === void 0 ? void 0 : _a.split(" ").filter(Boolean)) !== null && _b !== void 0 ? _b : [],
        },
    };
};
export var convertListedVisualization = function (visualizationLink) {
    var ref = uriRef(visualizationLink.link);
    return {
        insight: {
            identifier: visualizationLink.identifier || "",
            title: visualizationLink.title || "",
            uri: visualizationLink.link,
            ref: ref,
            properties: [],
            sorts: [],
            visualizationUrl: "",
            buckets: [],
            filters: [],
            tags: [],
            created: visualizationLink.created,
            updated: visualizationLink.updated,
        },
    };
};
//# sourceMappingURL=VisualizationConverter.js.map