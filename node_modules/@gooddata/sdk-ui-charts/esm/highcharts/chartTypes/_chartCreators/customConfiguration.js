import { __assign } from "tslib";
// (C) 2007-2021 GoodData Corporation
import noop from "lodash/noop";
import isString from "lodash/isString";
import merge from "lodash/merge";
import map from "lodash/map";
import partial from "lodash/partial";
import isEmpty from "lodash/isEmpty";
import compact from "lodash/compact";
import every from "lodash/every";
import isNil from "lodash/isNil";
import pickBy from "lodash/pickBy";
import numberJS from "@gooddata/numberjs";
import cx from "classnames";
import { styleVariables } from "./styles/variables";
import { VisualizationTypes } from "@gooddata/sdk-ui";
import { formatAsPercent, getLabelStyle, getLabelsVisibilityConfig } from "./dataLabelsHelpers";
import { HOVER_BRIGHTNESS, MINIMUM_HC_SAFE_BRIGHTNESS } from "./commonConfiguration";
import { getLighterColor } from "@gooddata/sdk-ui-vis-commons";
import { isAreaChart, isBarChart, isBubbleChart, isBulletChart, isColumnChart, isComboChart, isHeatmap, isInvertedChartType, isOneOfTypes, isRotationInRange, isScatterPlot, percentFormatter, } from "../_util/common";
import { shouldEndOnTick, shouldFollowPointer, shouldStartOnTick, shouldXAxisStartOnTickOnBubbleScatter, shouldYAxisStartOnTickOnBubbleScatter, } from "./helpers";
import getOptionalStackingConfiguration from "./getOptionalStackingConfiguration";
import { getZeroAlignConfiguration } from "./getZeroAlignConfiguration";
import { canComboChartBeStackedInPercent } from "../comboChart/comboChartOptions";
import { getAxisNameConfiguration } from "./getAxisNameConfiguration";
import { getAxisLabelConfigurationForDualBarChart } from "./getAxisLabelConfigurationForDualBarChart";
import { supportedDualAxesChartTypes, supportedTooltipFollowPointerChartTypes, } from "../_chartOptions/chartCapabilities";
import { AXIS_LINE_COLOR } from "../_util/color";
import { isMeasureFormatInPercent } from "@gooddata/sdk-model";
var stripColors = numberJS.stripColors, numberFormat = numberJS.numberFormat;
var EMPTY_DATA = { categories: [], series: [] };
var ALIGN_LEFT = "left";
var ALIGN_RIGHT = "right";
var ALIGN_CENTER = "center";
var TOOLTIP_ARROW_OFFSET = 23;
var TOOLTIP_MAX_WIDTH = 320;
var TOOLTIP_INVERTED_CHART_VERTICAL_OFFSET = 5;
var TOOLTIP_VERTICAL_OFFSET = 14;
var BAR_COLUMN_TOOLTIP_TOP_OFFSET = 8;
var BAR_COLUMN_TOOLTIP_LEFT_OFFSET = 5;
var HIGHCHARTS_TOOLTIP_TOP_LEFT_OFFSET = 16;
var MIN_RANGE = 2;
// custom limit to hide data labels to improve performance
var HEATMAP_DATA_LABELS_LIMIT = 150;
// in viewport <= 480, tooltip width is equal to chart container width
var TOOLTIP_FULLSCREEN_THRESHOLD = 480;
export var TOOLTIP_PADDING = 24; // padding of tooltip container - defined by CSS
export var TOOLTIP_VIEWPORT_MARGIN_TOP = 20;
var escapeAngleBrackets = function (str) { return str && str.replace(/</g, "&lt;").replace(/>/g, "&gt;"); };
function getAxisTitleConfiguration(axis) {
    var _a;
    return (axis
        ? {
            title: {
                text: escapeAngleBrackets((_a = axis === null || axis === void 0 ? void 0 : axis.label) !== null && _a !== void 0 ? _a : ""),
            },
        }
        : {});
}
function getTitleConfiguration(chartOptions) {
    var _a = chartOptions.yAxes, yAxes = _a === void 0 ? [] : _a, _b = chartOptions.xAxes, xAxes = _b === void 0 ? [] : _b;
    var yAxis = yAxes.map(function (axis) { return getAxisTitleConfiguration(axis); });
    var xAxis = xAxes.map(function (axis) { return getAxisTitleConfiguration(axis); });
    return {
        yAxis: yAxis,
        xAxis: xAxis,
    };
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function formatOverlappingForParentAttribute(category) {
    var _a, _b, _c, _d, _e;
    // category is passed from 'grouped-categories' which is highcharts plug-in
    if (!category) {
        return formatOverlapping.call(this);
    }
    var categoriesCount = ((_b = (_a = this.axis) === null || _a === void 0 ? void 0 : _a.categoriesTree) !== null && _b !== void 0 ? _b : []).length;
    if (categoriesCount === 1) {
        // Let the width be auto to make sure "this.value" is displayed on screen
        return "<div style=\"overflow: hidden; text-overflow: ellipsis\">" + this.value + "</div>";
    }
    var chartHeight = (_e = (_d = (_c = this.axis) === null || _c === void 0 ? void 0 : _c.chart) === null || _d === void 0 ? void 0 : _d.chartHeight) !== null && _e !== void 0 ? _e : 1;
    var width = Math.floor(chartHeight / categoriesCount);
    var pixelOffset = 40; // parent attribute should have more space than its children
    var finalWidth = Math.max(0, width - pixelOffset);
    return "<div style=\"width: " + finalWidth + "px; overflow: hidden; text-overflow: ellipsis\">" + this.value + "</div>";
}
export function formatOverlapping() {
    var _a, _b, _c, _d;
    var categoriesCount = ((_b = (_a = this.axis) === null || _a === void 0 ? void 0 : _a.categories) !== null && _b !== void 0 ? _b : []).length;
    if (categoriesCount === 1) {
        // Let the width be auto to make sure "this.value" is displayed on screen
        return "<div align=\"center\" style=\"overflow: hidden; text-overflow: ellipsis\">" + this.value + "</div>";
    }
    var chartHeight = (_d = (_c = this.chart) === null || _c === void 0 ? void 0 : _c.chartHeight) !== null && _d !== void 0 ? _d : 1;
    var width = Math.floor(chartHeight / categoriesCount);
    var pixelOffset = 20;
    var finalWidth = Math.max(0, width - pixelOffset);
    return ("<div align=\"center\" style=\"width: " + finalWidth + "px; overflow: hidden; text-overflow: ellipsis\">" +
        this.value +
        "</div>");
}
function hideOverlappedLabels(chartOptions) {
    var _a, _b;
    var rotation = Number((_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.xAxisProps) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : "0");
    // rotate labels for charts that are horizontal (bar, bullet)
    var isInvertedChart = isInvertedChartType(chartOptions.type);
    if (isInvertedChart && isRotationInRange(rotation, 75, 105)) {
        var _c = chartOptions.xAxes, xAxes = _c === void 0 ? [] : _c, isViewByTwoAttributes_1 = chartOptions.isViewByTwoAttributes;
        return {
            xAxis: xAxes.map(function (axis) {
                return axis
                    ? {
                        labels: {
                            useHTML: true,
                            formatter: isViewByTwoAttributes_1
                                ? formatOverlappingForParentAttribute
                                : formatOverlapping,
                        },
                    }
                    : {};
            }),
        };
    }
    return {};
}
function getArrowAlignment(arrowPosition, chartWidth) {
    var minX = -TOOLTIP_ARROW_OFFSET;
    var maxX = chartWidth + TOOLTIP_ARROW_OFFSET;
    if (arrowPosition + TOOLTIP_MAX_WIDTH / 2 > maxX && arrowPosition - TOOLTIP_MAX_WIDTH / 2 > minX) {
        return ALIGN_RIGHT;
    }
    if (arrowPosition - TOOLTIP_MAX_WIDTH / 2 < minX && arrowPosition + TOOLTIP_MAX_WIDTH / 2 < maxX) {
        return ALIGN_LEFT;
    }
    return ALIGN_CENTER;
}
var getTooltipHorizontalStartingPosition = function (arrowPosition, chartWidth, tooltipWidth) {
    switch (getArrowAlignment(arrowPosition, chartWidth)) {
        case ALIGN_RIGHT:
            return arrowPosition - tooltipWidth + TOOLTIP_ARROW_OFFSET;
        case ALIGN_LEFT:
            return arrowPosition - TOOLTIP_ARROW_OFFSET;
        default:
            return arrowPosition - tooltipWidth / 2;
    }
};
function getArrowHorizontalPosition(chartType, stacking, dataPointEnd, dataPointHeight) {
    if (isBarChart(chartType) && stacking) {
        return dataPointEnd - dataPointHeight / 2;
    }
    return dataPointEnd;
}
function getDataPointEnd(chartType, isNegative, endPoint, height, stacking) {
    return isBarChart(chartType) && isNegative && stacking ? endPoint + height : endPoint;
}
function getDataPointStart(chartType, isNegative, endPoint, height, stacking) {
    return isColumnChart(chartType) && isNegative && stacking ? endPoint - height : endPoint;
}
function getTooltipVerticalOffset(chartType, stacking, point) {
    if (isColumnChart(chartType) && (stacking || point.negative)) {
        return 0;
    }
    if (isInvertedChartType(chartType)) {
        return TOOLTIP_INVERTED_CHART_VERTICAL_OFFSET;
    }
    return TOOLTIP_VERTICAL_OFFSET;
}
export function getTooltipPositionInChartContainer(chartType, stacking, labelWidth, labelHeight, point) {
    var dataPointEnd = getDataPointEnd(chartType, point.negative, point.plotX, point.h, stacking);
    var arrowPosition = getArrowHorizontalPosition(chartType, stacking, dataPointEnd, point.h);
    var chartWidth = this.chart.plotWidth;
    var tooltipHorizontalStartingPosition = getTooltipHorizontalStartingPosition(arrowPosition, chartWidth, labelWidth);
    var verticalOffset = getTooltipVerticalOffset(chartType, stacking, point);
    var dataPointStart = getDataPointStart(chartType, point.negative, point.plotY, point.h, stacking);
    return {
        x: this.chart.plotLeft + tooltipHorizontalStartingPosition,
        y: this.chart.plotTop + dataPointStart - (labelHeight + verticalOffset),
    };
}
function getHighchartTooltipTopOffset(chartType) {
    if (isBarChart(chartType) ||
        isBulletChart(chartType) ||
        isColumnChart(chartType) ||
        isComboChart(chartType)) {
        return BAR_COLUMN_TOOLTIP_TOP_OFFSET;
    }
    return HIGHCHARTS_TOOLTIP_TOP_LEFT_OFFSET;
}
function getHighchartTooltipLeftOffset(chartType) {
    if (isBarChart(chartType) ||
        isBulletChart(chartType) ||
        isColumnChart(chartType) ||
        isComboChart(chartType)) {
        return BAR_COLUMN_TOOLTIP_LEFT_OFFSET;
    }
    return HIGHCHARTS_TOOLTIP_TOP_LEFT_OFFSET;
}
export function getTooltipPositionInViewPort(chartType, stacking, labelWidth, labelHeight, point) {
    var _a = getTooltipPositionInChartContainer.call(this, chartType, stacking, labelWidth, labelHeight, point), x = _a.x, y = _a.y;
    var _b = this.chart.container.getBoundingClientRect(), containerTop = _b.top, containerLeft = _b.left;
    var leftOffset = pageXOffset + containerLeft - getHighchartTooltipLeftOffset(chartType);
    var topOffset = pageYOffset + containerTop - getHighchartTooltipTopOffset(chartType);
    var posX = isTooltipShownInFullScreen() ? leftOffset : leftOffset + x;
    var posY = topOffset + y;
    var minPosY = TOOLTIP_VIEWPORT_MARGIN_TOP - TOOLTIP_PADDING + pageYOffset;
    var posYLimited = posY < minPosY ? minPosY : posY;
    return {
        x: posX,
        y: posYLimited,
    };
}
var isTooltipShownInFullScreen = function () {
    return document.documentElement.clientWidth <= TOOLTIP_FULLSCREEN_THRESHOLD;
};
function formatTooltip(tooltipCallback, intl) {
    var chart = this.series.chart;
    var pointColor = this.point.color;
    var chartWidth = chart.spacingBox.width;
    var isFullScreenTooltip = isTooltipShownInFullScreen();
    var maxTooltipContentWidth = isFullScreenTooltip ? chartWidth : Math.min(chartWidth, TOOLTIP_MAX_WIDTH);
    var isDrillable = this.point.drilldown;
    // when brushing, do not show tooltip
    if (chart.mouseIsDown) {
        return false;
    }
    var strokeStyle = pointColor ? "border-top-color: " + pointColor + ";" : "";
    var tooltipStyle = isFullScreenTooltip ? "width: " + maxTooltipContentWidth + "px;" : "";
    // null disables whole tooltip
    var tooltipContent = tooltipCallback(this.point, maxTooltipContentWidth, this.percentage);
    var interactionMessage = getInteractionMessage(isDrillable, intl);
    return tooltipContent !== null
        ? "<div class=\"hc-tooltip gd-viz-tooltip\" style=\"" + tooltipStyle + "\">\n            <span class=\"stroke gd-viz-tooltip-stroke\" style=\"" + strokeStyle + "\"></span>\n            <div class=\"content gd-viz-tooltip-content\" style=\"max-width: " + maxTooltipContentWidth + "px;\">\n                " + tooltipContent + "\n                " + interactionMessage + "\n            </div>\n        </div>"
        : null;
}
function getInteractionMessage(isDrillable, intl) {
    var message = intl ? intl.formatMessage({ id: "visualization.tooltip.interaction" }) : null;
    return isDrillable && intl ? "<div class=\"gd-viz-tooltip-interaction\">" + message + "</div>" : "";
}
function formatLabel(value, format, config) {
    if (config === void 0) { config = {}; }
    // no labels for missing values
    if (isNil(value)) {
        return null;
    }
    var stripped = stripColors(format || "");
    var separators = config.separators;
    return escapeAngleBrackets(String(numberFormat(value, stripped, undefined, separators)));
}
function labelFormatter(config) {
    var _a;
    return formatLabel(this.y, (_a = this.point) === null || _a === void 0 ? void 0 : _a.format, config);
}
function axisLabelFormatter(config, format) {
    return this.value === 0 ? 0 : formatLabel(this.value, format, config);
}
export function percentageDataLabelFormatter(config) {
    var _a, _b, _c, _d, _e, _f, _g;
    // suppose that chart has one Y axis by default
    var isSingleAxis = ((_d = (_c = (_b = (_a = this.series) === null || _a === void 0 ? void 0 : _a.chart) === null || _b === void 0 ? void 0 : _b.yAxis) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 1) === 1;
    var isPrimaryAxis = !((_g = (_f = (_e = this.series) === null || _e === void 0 ? void 0 : _e.yAxis) === null || _f === void 0 ? void 0 : _f.opposite) !== null && _g !== void 0 ? _g : false);
    // only format data labels to percentage for
    //  * left or right axis on single axis chart, or
    //  * primary axis on dual axis chart
    if (this.percentage && (isSingleAxis || isPrimaryAxis)) {
        return percentFormatter(this.percentage);
    }
    return labelFormatter.call(this, config);
}
function labelFormatterHeatmap(options) {
    return formatLabel(this.point.value, options.formatGD, options.config);
}
function level1LabelsFormatter(config) {
    var _a, _b, _c, _d;
    return ((_a = this.point) === null || _a === void 0 ? void 0 : _a.name) + " (" + formatLabel((_c = (_b = this.point) === null || _b === void 0 ? void 0 : _b.node) === null || _c === void 0 ? void 0 : _c.val, (_d = this.point) === null || _d === void 0 ? void 0 : _d.format, config) + ")";
}
function level2LabelsFormatter(config) {
    var _a, _b, _c;
    return ((_a = this.point) === null || _a === void 0 ? void 0 : _a.name) + " (" + formatLabel((_b = this.point) === null || _b === void 0 ? void 0 : _b.value, (_c = this.point) === null || _c === void 0 ? void 0 : _c.format, config) + ")";
}
function labelFormatterBubble(config) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var value = (_a = this.point) === null || _a === void 0 ? void 0 : _a.z;
    if (isNil(value) || isNaN(value)) {
        return null;
    }
    var xAxisMin = (_c = (_b = this.series) === null || _b === void 0 ? void 0 : _b.xAxis) === null || _c === void 0 ? void 0 : _c.min;
    var xAxisMax = (_e = (_d = this.series) === null || _d === void 0 ? void 0 : _d.xAxis) === null || _e === void 0 ? void 0 : _e.max;
    var yAxisMin = (_g = (_f = this.series) === null || _f === void 0 ? void 0 : _f.yAxis) === null || _g === void 0 ? void 0 : _g.min;
    var yAxisMax = (_j = (_h = this.series) === null || _h === void 0 ? void 0 : _h.yAxis) === null || _j === void 0 ? void 0 : _j.max;
    if ((!isNil(xAxisMax) && this.x > xAxisMax) ||
        (!isNil(xAxisMin) && this.x < xAxisMin) ||
        (!isNil(yAxisMax) && this.y > yAxisMax) ||
        (!isNil(yAxisMin) && this.y < yAxisMin)) {
        return null;
    }
    else {
        return formatLabel(value, (_k = this.point) === null || _k === void 0 ? void 0 : _k.format, config);
    }
}
function labelFormatterScatter() {
    var _a;
    var name = (_a = this.point) === null || _a === void 0 ? void 0 : _a.name;
    if (name) {
        return escapeAngleBrackets(name);
    }
    return null;
}
// check whether series contains only positive values, not consider nulls
function hasOnlyPositiveValues(series, x) {
    return every(series, function (seriesItem) {
        var dataPoint = seriesItem.yData[x];
        return dataPoint !== null && dataPoint >= 0;
    });
}
function stackLabelFormatter(config) {
    var _a, _b;
    // show labels: always for negative,
    // without negative values or with non-zero total for positive
    var showStackLabel = this.isNegative || hasOnlyPositiveValues(this.axis.series, this.x) || this.total !== 0;
    return showStackLabel ? formatLabel(this.total, (_b = (_a = this.axis) === null || _a === void 0 ? void 0 : _a.userOptions) === null || _b === void 0 ? void 0 : _b.defaultFormat, config) : null;
}
function getTooltipConfiguration(chartOptions, _config, _chartConfig, _drillConfig, intl) {
    var _a, _b, _c;
    var tooltipAction = (_a = chartOptions.actions) === null || _a === void 0 ? void 0 : _a.tooltip;
    var chartType = chartOptions.type;
    var stacking = chartOptions.stacking;
    var followPointer = isOneOfTypes(chartType, supportedTooltipFollowPointerChartTypes)
        ? { followPointer: shouldFollowPointer(chartOptions) }
        : {};
    return tooltipAction
        ? {
            tooltip: __assign({ borderWidth: 0, borderRadius: 0, shadow: false, useHTML: true, outside: true, positioner: partial(getTooltipPositionInViewPort, chartType, stacking), formatter: partial(formatTooltip, tooltipAction, intl), enabled: (_c = (_b = _chartConfig === null || _chartConfig === void 0 ? void 0 : _chartConfig.tooltip) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : true }, followPointer),
        }
        : {};
}
function getTreemapLabelsConfiguration(isMultiLevel, style, config, labelsConfig) {
    var smallLabelInCenter = {
        dataLabels: __assign({ enabled: true, padding: 2, formatter: partial(level2LabelsFormatter, config), allowOverlap: false, style: style }, labelsConfig),
    };
    if (isMultiLevel) {
        return {
            dataLabels: __assign({}, labelsConfig),
            levels: [
                {
                    level: 1,
                    dataLabels: __assign({ enabled: true, align: "left", verticalAlign: "top", padding: 5, style: __assign(__assign({}, style), { fontSize: "14px", fontFamily: "gdcustomfont, Avenir, 'Helvetica Neue', Arial, sans-serif" }), formatter: partial(level1LabelsFormatter, config), allowOverlap: false }, labelsConfig),
                },
                __assign({ level: 2 }, smallLabelInCenter),
            ],
        };
    }
    else {
        return {
            dataLabels: __assign({}, labelsConfig),
            levels: [
                __assign({ level: 1 }, smallLabelInCenter),
            ],
        };
    }
}
function shouldDisableHeatmapDataLabels(series) {
    return series.some(function (item) { return item.data.length >= HEATMAP_DATA_LABELS_LIMIT; });
}
function getLabelsConfiguration(chartOptions, _config, chartConfig) {
    var _a, _b, _c;
    var stacking = chartOptions.stacking, _d = chartOptions.yAxes, yAxes = _d === void 0 ? [] : _d, type = chartOptions.type;
    var labelsVisible = (_a = chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.dataLabels) === null || _a === void 0 ? void 0 : _a.visible;
    var labelsConfig = getLabelsVisibilityConfig(labelsVisible);
    var style = getLabelStyle(type, stacking);
    var yAxis = yAxes.map(function (axis) { return ({
        defaultFormat: axis === null || axis === void 0 ? void 0 : axis.format,
    }); });
    var series = (_c = (_b = chartOptions.data) === null || _b === void 0 ? void 0 : _b.series) !== null && _c !== void 0 ? _c : [];
    var canStackInPercent = canComboChartBeStackedInPercent(series);
    var _e = (chartConfig || {}).stackMeasuresToPercent, stackMeasuresToPercent = _e === void 0 ? false : _e;
    // only applied to bar, column, dual axis and area chart
    var dataLabelFormatter = stackMeasuresToPercent && canStackInPercent ? percentageDataLabelFormatter : labelFormatter;
    var DEFAULT_LABELS_CONFIG = __assign({ formatter: partial(labelFormatter, chartConfig), style: style, allowOverlap: false }, labelsConfig);
    // workaround for missing data labels on last stacked measure with limited axis
    // see https://github.com/highcharts/highcharts/issues/15145
    var dataLabelsBugWorkaround = stackMeasuresToPercent && canStackInPercent ? { inside: true } : {};
    // only applied to heatmap chart
    var areHeatmapDataLabelsDisabled = shouldDisableHeatmapDataLabels(series);
    var heatmapLabelsConfig = areHeatmapDataLabelsDisabled ? { enabled: false } : labelsConfig;
    return {
        plotOptions: {
            gdcOptions: {
                dataLabels: {
                    visible: labelsVisible,
                },
            },
            bar: {
                dataLabels: __assign(__assign(__assign({}, DEFAULT_LABELS_CONFIG), { formatter: partial(dataLabelFormatter, chartConfig) }), dataLabelsBugWorkaround),
            },
            column: {
                dataLabels: __assign(__assign(__assign({}, DEFAULT_LABELS_CONFIG), { formatter: partial(dataLabelFormatter, chartConfig) }), dataLabelsBugWorkaround),
            },
            heatmap: {
                dataLabels: __assign({ formatter: labelFormatterHeatmap, config: chartConfig }, heatmapLabelsConfig),
            },
            treemap: __assign({}, getTreemapLabelsConfiguration(!!stacking, style, chartConfig, labelsConfig)),
            line: {
                dataLabels: DEFAULT_LABELS_CONFIG,
            },
            area: {
                dataLabels: __assign(__assign({}, DEFAULT_LABELS_CONFIG), { formatter: partial(dataLabelFormatter, chartConfig) }),
            },
            scatter: {
                dataLabels: __assign(__assign({}, DEFAULT_LABELS_CONFIG), { formatter: partial(labelFormatterScatter, chartConfig) }),
            },
            bubble: {
                dataLabels: __assign(__assign({}, DEFAULT_LABELS_CONFIG), { formatter: partial(labelFormatterBubble, chartConfig) }),
            },
            pie: {
                dataLabels: __assign(__assign({}, DEFAULT_LABELS_CONFIG), { verticalAlign: "middle" }),
            },
        },
        yAxis: yAxis,
    };
}
function getDataPointsConfiguration(_chartOptions, _config, chartConfig) {
    var _a, _b;
    var dataPointsVisible = (_b = (_a = chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.dataPoints) === null || _a === void 0 ? void 0 : _a.visible) !== null && _b !== void 0 ? _b : true;
    var dataPointsConfig = {
        marker: {
            enabled: dataPointsVisible === "auto" ? undefined : dataPointsVisible,
        },
    };
    return {
        plotOptions: {
            line: dataPointsConfig,
            area: dataPointsConfig,
        },
    };
}
function getStackingConfiguration(chartOptions, _config, chartConfig) {
    var _a;
    var stacking = chartOptions.stacking, _b = chartOptions.yAxes, yAxes = _b === void 0 ? [] : _b, type = chartOptions.type;
    var labelsConfig = {};
    if (isColumnChart(type)) {
        var labelsVisible = (_a = chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.dataLabels) === null || _a === void 0 ? void 0 : _a.visible;
        labelsConfig = getLabelsVisibilityConfig(labelsVisible);
    }
    var yAxis = yAxes.map(function () { return ({
        stackLabels: __assign(__assign({}, labelsConfig), { formatter: partial(stackLabelFormatter, chartConfig) }),
    }); });
    var connectNulls = {};
    if (stacking && isAreaChart(type)) {
        connectNulls = {
            connectNulls: true,
        };
    }
    return stacking
        ? {
            plotOptions: {
                series: __assign({ stacking: stacking }, connectNulls),
            },
            yAxis: yAxis,
        }
        : {};
}
function getSeries(series) {
    return series.map(function (seriesItem) {
        var _a;
        return __assign(__assign({}, seriesItem), { 
            // Escaping is handled by highcharts so we don't want to provide escaped input.
            // With one exception, though. Highcharts supports defining styles via
            // for example <b>...</b> and parses that from series name.
            // So to avoid this parsing, escape only < and > to &lt; and &gt;
            // which is understood by highcharts correctly
            name: (seriesItem === null || seriesItem === void 0 ? void 0 : seriesItem.name) && escapeAngleBrackets(seriesItem === null || seriesItem === void 0 ? void 0 : seriesItem.name), 
            // Escape data items for pie chart
            data: (_a = seriesItem === null || seriesItem === void 0 ? void 0 : seriesItem.data) === null || _a === void 0 ? void 0 : _a.map(function (dataItem) {
                if (!dataItem) {
                    return dataItem;
                }
                return __assign(__assign({}, dataItem), { name: escapeAngleBrackets(dataItem.name) });
            }) });
    });
}
function getHeatmapDataConfiguration(chartOptions) {
    var _a, _b;
    var data = chartOptions.data || EMPTY_DATA;
    var series = data.series;
    var categories = data.categories;
    return {
        series: series,
        xAxis: [
            {
                categories: categories[0] || [],
            },
        ],
        yAxis: [
            {
                categories: categories[1] || [],
            },
        ],
        colorAxis: {
            dataClasses: (_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.colorAxis) === null || _a === void 0 ? void 0 : _a.dataClasses) !== null && _b !== void 0 ? _b : [],
        },
    };
}
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export function escapeCategories(dataCategories) {
    return map(dataCategories, function (category) {
        return isString(category)
            ? escapeAngleBrackets(category)
            : {
                name: escapeAngleBrackets(category.name),
                categories: map(category.categories, escapeAngleBrackets),
            };
    });
}
function getDataConfiguration(chartOptions) {
    var data = chartOptions.data || EMPTY_DATA;
    var series = getSeries(data.series);
    var type = chartOptions.type;
    switch (type) {
        case VisualizationTypes.SCATTER:
        case VisualizationTypes.BUBBLE:
            return {
                series: series,
            };
        case VisualizationTypes.HEATMAP:
            return getHeatmapDataConfiguration(chartOptions);
    }
    var categories = escapeCategories(data.categories);
    return {
        series: series,
        xAxis: [
            {
                categories: categories,
            },
        ],
    };
}
function lineSeriesMapFn(seriesOrig) {
    var _a, _b, _c, _d, _e, _f;
    if (seriesOrig.isDrillable) {
        return __assign(__assign({}, seriesOrig), { marker: __assign(__assign({}, seriesOrig === null || seriesOrig === void 0 ? void 0 : seriesOrig.marker), { states: __assign(__assign({}, (_a = seriesOrig === null || seriesOrig === void 0 ? void 0 : seriesOrig.marker) === null || _a === void 0 ? void 0 : _a.states), { hover: __assign(__assign({}, (_c = (_b = seriesOrig === null || seriesOrig === void 0 ? void 0 : seriesOrig.marker) === null || _b === void 0 ? void 0 : _b.states) === null || _c === void 0 ? void 0 : _c.hover), { fillColor: getLighterColor(seriesOrig.color, HOVER_BRIGHTNESS) }) }) }) });
    }
    return __assign(__assign({}, seriesOrig), { states: __assign(__assign({}, seriesOrig === null || seriesOrig === void 0 ? void 0 : seriesOrig.states), { hover: __assign(__assign({}, (_d = seriesOrig === null || seriesOrig === void 0 ? void 0 : seriesOrig.states) === null || _d === void 0 ? void 0 : _d.hover), { halo: __assign(__assign({}, (_f = (_e = seriesOrig === null || seriesOrig === void 0 ? void 0 : seriesOrig.states) === null || _e === void 0 ? void 0 : _e.hover) === null || _f === void 0 ? void 0 : _f.halo), { size: 0 }) }) }) });
}
function barSeriesMapFn(seriesOrig) {
    var _a;
    return __assign(__assign({}, seriesOrig), { states: __assign(__assign({}, seriesOrig === null || seriesOrig === void 0 ? void 0 : seriesOrig.states), { hover: __assign(__assign({}, (_a = seriesOrig === null || seriesOrig === void 0 ? void 0 : seriesOrig.states) === null || _a === void 0 ? void 0 : _a.hover), { brightness: HOVER_BRIGHTNESS, enabled: seriesOrig.isDrillable }) }) });
}
function getHeatMapHoverColor(config) {
    var _a, _b;
    var dataClasses = (_b = (_a = config === null || config === void 0 ? void 0 : config.colorAxis) === null || _a === void 0 ? void 0 : _a.dataClasses) !== null && _b !== void 0 ? _b : null;
    var resultColor = "rgb(210,210,210)";
    if (dataClasses) {
        if (dataClasses.length === 1) {
            resultColor = dataClasses[0].color;
        }
        else if (dataClasses.length > 1) {
            resultColor = dataClasses[1].color;
        }
    }
    return getLighterColor(resultColor, 0.2);
}
function getHoverStyles(_a, config) {
    var type = _a.type;
    var seriesMapFn = noop;
    switch (type) {
        case VisualizationTypes.LINE:
        case VisualizationTypes.SCATTER:
        case VisualizationTypes.AREA:
        case VisualizationTypes.BUBBLE:
            seriesMapFn = lineSeriesMapFn;
            break;
        case VisualizationTypes.BAR:
        case VisualizationTypes.COLUMN:
        case VisualizationTypes.BULLET:
        case VisualizationTypes.FUNNEL:
            seriesMapFn = barSeriesMapFn;
            break;
        case VisualizationTypes.HEATMAP:
            seriesMapFn = function (series, config) {
                var _a;
                var color = getHeatMapHoverColor(config);
                return __assign(__assign({}, series), { states: __assign(__assign({}, series === null || series === void 0 ? void 0 : series.states), { hover: __assign(__assign({}, (_a = series === null || series === void 0 ? void 0 : series.states) === null || _a === void 0 ? void 0 : _a.hover), { color: color, enabled: series.isDrillable }) }) });
            };
            break;
        case VisualizationTypes.COMBO:
        case VisualizationTypes.COMBO2:
            seriesMapFn = function (seriesOrig) {
                var type = seriesOrig.type;
                if (type === "line" || type === "area") {
                    return lineSeriesMapFn(seriesOrig);
                }
                return barSeriesMapFn(seriesOrig);
            };
            break;
        case VisualizationTypes.PIE:
        case VisualizationTypes.DONUT:
        case VisualizationTypes.TREEMAP:
            seriesMapFn = function (series) {
                return __assign(__assign({}, series), { data: series.data.map(function (dataItemOrig) {
                        var _a;
                        var drilldown = dataItemOrig === null || dataItemOrig === void 0 ? void 0 : dataItemOrig.drilldown;
                        var pointHalo = !drilldown
                            ? {
                                // see plugins/pointHalo.js
                                halo: __assign(__assign({}, dataItemOrig === null || dataItemOrig === void 0 ? void 0 : dataItemOrig.halo), { size: 0 }),
                            }
                            : {};
                        return __assign(__assign(__assign({}, dataItemOrig), { states: __assign(__assign({}, dataItemOrig === null || dataItemOrig === void 0 ? void 0 : dataItemOrig.states), { hover: __assign(__assign({}, (_a = dataItemOrig === null || dataItemOrig === void 0 ? void 0 : dataItemOrig.states) === null || _a === void 0 ? void 0 : _a.hover), { brightness: drilldown ? HOVER_BRIGHTNESS : MINIMUM_HC_SAFE_BRIGHTNESS }) }) }), pointHalo);
                    }) });
            };
            break;
        default:
            throw new Error("Undefined chart type \"" + type + "\".");
    }
    return {
        series: config.series.map(function (item) { return seriesMapFn(item, config); }),
    };
}
function getGridConfiguration(chartOptions, _config, _chartConfig, _drillConfig, _intl, theme) {
    var _a, _b, _c, _d, _e, _f, _g;
    var gridEnabled = (_b = (_a = chartOptions.grid) === null || _a === void 0 ? void 0 : _a.enabled) !== null && _b !== void 0 ? _b : true;
    var _h = chartOptions.yAxes, yAxes = _h === void 0 ? [] : _h, _j = chartOptions.xAxes, xAxes = _j === void 0 ? [] : _j;
    var gridColor = (_g = (_d = (_c = theme === null || theme === void 0 ? void 0 : theme.chart) === null || _c === void 0 ? void 0 : _c.gridColor) !== null && _d !== void 0 ? _d : (_f = (_e = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _e === void 0 ? void 0 : _e.complementary) === null || _f === void 0 ? void 0 : _f.c3) !== null && _g !== void 0 ? _g : styleVariables.gdColorGrid;
    var config = gridEnabled ? { gridLineWidth: 1, gridLineColor: gridColor } : { gridLineWidth: 0 };
    var yAxis = yAxes.map(function () { return config; });
    var bothAxesGridlineCharts = [VisualizationTypes.BUBBLE, VisualizationTypes.SCATTER];
    var xAxis = {};
    if (isOneOfTypes(chartOptions.type, bothAxesGridlineCharts)) {
        xAxis = xAxes.map(function () { return config; });
    }
    return {
        yAxis: yAxis,
        xAxis: xAxis,
    };
}
export function areAxisLabelsEnabled(chartOptions, axisPropsName, shouldCheckForEmptyCategories) {
    var _a, _b, _c, _d;
    var data = chartOptions.data || EMPTY_DATA;
    var type = chartOptions.type;
    var categories = isHeatmap(type) ? data.categories : escapeCategories(data.categories);
    var visible = (_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions[axisPropsName]) === null || _a === void 0 ? void 0 : _a.visible) !== null && _b !== void 0 ? _b : true;
    var labelsEnabled = (_d = (_c = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions[axisPropsName]) === null || _c === void 0 ? void 0 : _c.labelsEnabled) !== null && _d !== void 0 ? _d : true;
    var categoriesFlag = shouldCheckForEmptyCategories ? !isEmpty(compact(categories)) : true;
    return {
        enabled: categoriesFlag && visible && labelsEnabled,
    };
}
function shouldExpandYAxis(chartOptions) {
    var _a, _b, _c, _d;
    var min = (_b = (_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.xAxisProps) === null || _a === void 0 ? void 0 : _a.min) !== null && _b !== void 0 ? _b : "";
    var max = (_d = (_c = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.xAxisProps) === null || _c === void 0 ? void 0 : _c.max) !== null && _d !== void 0 ? _d : "";
    return min === "" && max === "" ? {} : { getExtremesFromAll: true };
}
function getAxisLineConfiguration(chartType, isAxisVisible) {
    var lineWidth;
    if (isAxisVisible === false) {
        lineWidth = 0;
    }
    else {
        lineWidth = isScatterPlot(chartType) || isBubbleChart(chartType) ? 1 : undefined;
    }
    return pickBy({ AXIS_LINE_COLOR: AXIS_LINE_COLOR, lineWidth: lineWidth }, function (item) { return item !== undefined; });
}
function getXAxisTickConfiguration(chartOptions) {
    var type = chartOptions.type;
    if (isBubbleChart(type) || isScatterPlot(type)) {
        return {
            startOnTick: shouldXAxisStartOnTickOnBubbleScatter(chartOptions),
            endOnTick: false,
        };
    }
    return {};
}
function getYAxisTickConfiguration(chartOptions, axisPropsKey) {
    var type = chartOptions.type, yAxes = chartOptions.yAxes;
    if (isBubbleChart(type) || isScatterPlot(type)) {
        return {
            startOnTick: shouldYAxisStartOnTickOnBubbleScatter(chartOptions),
        };
    }
    if (isOneOfTypes(type, supportedDualAxesChartTypes) && yAxes.length > 1) {
        // disable { startOnTick, endOnTick } to make gridline sync in both axes
        return {};
    }
    return {
        startOnTick: shouldStartOnTick(chartOptions, axisPropsKey),
        endOnTick: shouldEndOnTick(chartOptions, axisPropsKey),
    };
}
export var getFormatterProperty = function (chartOptions, axisPropsKey, chartConfig, axisFormat) {
    var _a, _b;
    if (isMeasureFormatInPercent(axisFormat)) {
        return { formatter: partial(formatAsPercent, 100) };
    }
    var useCustomFormat = (_b = ((_a = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions[axisPropsKey]) === null || _a === void 0 ? void 0 : _a.format) === "inherit") !== null && _b !== void 0 ? _b : false;
    if (useCustomFormat) {
        return { formatter: partial(axisLabelFormatter, chartConfig, axisFormat) };
    }
    return {};
};
var getYAxisConfiguration = function (chartOptions, chartConfig, axisValueColor, axisLabelColor) {
    var _a = chartOptions.forceDisableDrillOnAxes, forceDisableDrillOnAxes = _a === void 0 ? false : _a;
    var type = chartOptions.type;
    var yAxes = chartOptions.yAxes || [];
    return yAxes.map(function (axis) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (!axis) {
            return {
                visible: false,
            };
        }
        var opposite = (_a = axis.opposite) !== null && _a !== void 0 ? _a : false;
        var axisType = opposite ? "secondary" : "primary";
        var className = cx("s-highcharts-" + axisType + "-yaxis", {
            "gd-axis-label-drilling-disabled": forceDisableDrillOnAxes,
        });
        var axisPropsKey = opposite ? "secondary_yAxisProps" : "yAxisProps";
        // For bar chart take x axis options
        var min = (_c = (_b = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions[axisPropsKey]) === null || _b === void 0 ? void 0 : _b.min) !== null && _c !== void 0 ? _c : "";
        var max = (_e = (_d = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions[axisPropsKey]) === null || _d === void 0 ? void 0 : _d.max) !== null && _e !== void 0 ? _e : "";
        var visible = (_g = (_f = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions[axisPropsKey]) === null || _f === void 0 ? void 0 : _f.visible) !== null && _g !== void 0 ? _g : true;
        var maxProp = max ? { max: Number(max) } : {};
        var minProp = min ? { min: Number(min) } : {};
        var rotation = (_j = (_h = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions[axisPropsKey]) === null || _h === void 0 ? void 0 : _h.rotation) !== null && _j !== void 0 ? _j : "auto";
        var rotationProp = rotation !== "auto" ? { rotation: -Number(rotation) } : {};
        var shouldCheckForEmptyCategories = isHeatmap(type) ? true : false;
        var labelsEnabled = areAxisLabelsEnabled(chartOptions, axisPropsKey, shouldCheckForEmptyCategories);
        var formatter = getFormatterProperty(chartOptions, axisPropsKey, chartConfig, axis.format);
        var tickConfiguration = getYAxisTickConfiguration(chartOptions, axisPropsKey);
        var titleTextProp = visible ? {} : { text: null }; // new way how to hide title instead of deprecated 'enabled'
        return __assign(__assign(__assign(__assign(__assign({}, getAxisLineConfiguration(type, visible)), { labels: __assign(__assign(__assign(__assign({}, labelsEnabled), { style: {
                    color: axisValueColor,
                    font: '12px gdcustomfont, Avenir, "Helvetica Neue", Arial, sans-serif',
                } }), formatter), rotationProp), title: __assign(__assign({}, titleTextProp), { margin: 15, style: {
                    color: axisLabelColor,
                    font: '14px gdcustomfont, Avenir, "Helvetica Neue", Arial, sans-serif',
                } }), opposite: opposite,
            className: className }), maxProp), minProp), tickConfiguration);
    });
};
var getXAxisConfiguration = function (chartOptions, chartConfig, axisValueColor, axisLabelColor) {
    var _a = chartOptions.forceDisableDrillOnAxes, forceDisableDrillOnAxes = _a === void 0 ? false : _a;
    var type = chartOptions.type;
    var xAxes = chartOptions.xAxes || [];
    return xAxes.map(function (axis) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        if (!axis) {
            return {
                visible: false,
            };
        }
        var opposite = (_a = axis.opposite) !== null && _a !== void 0 ? _a : false;
        var axisPropsKey = opposite ? "secondary_xAxisProps" : "xAxisProps";
        var className = cx({
            "gd-axis-label-drilling-disabled": forceDisableDrillOnAxes,
        });
        var min = (_c = (_b = chartOptions[axisPropsKey]) === null || _b === void 0 ? void 0 : _b.min) !== null && _c !== void 0 ? _c : "";
        var max = (_e = (_d = chartOptions[axisPropsKey]) === null || _d === void 0 ? void 0 : _d.max) !== null && _e !== void 0 ? _e : "";
        var maxProp = max ? { max: Number(max) } : {};
        var minProp = min ? { min: Number(min) } : {};
        var isViewByTwoAttributes = (_f = chartOptions.isViewByTwoAttributes) !== null && _f !== void 0 ? _f : false;
        var isInvertedChart = isInvertedChartType(chartOptions.type);
        var visible = (_h = (_g = chartOptions[axisPropsKey]) === null || _g === void 0 ? void 0 : _g.visible) !== null && _h !== void 0 ? _h : true;
        var rotation = (_k = (_j = chartOptions[axisPropsKey]) === null || _j === void 0 ? void 0 : _j.rotation) !== null && _k !== void 0 ? _k : "auto";
        var rotationProp = rotation !== "auto" ? { rotation: -Number(rotation) } : {};
        var shouldCheckForEmptyCategories = isScatterPlot(type) || isBubbleChart(type) ? false : true;
        var labelsEnabled = areAxisLabelsEnabled(chartOptions, axisPropsKey, shouldCheckForEmptyCategories);
        var formatter = getFormatterProperty(chartOptions, axisPropsKey, chartConfig, axis.format);
        var tickConfiguration = getXAxisTickConfiguration(chartOptions);
        // for minimum zoom level value
        var minRange = ((_l = chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.zoomInsight) !== null && _l !== void 0 ? _l : false) && ((_o = (_m = chartOptions === null || chartOptions === void 0 ? void 0 : chartOptions.data) === null || _m === void 0 ? void 0 : _m.categories) !== null && _o !== void 0 ? _o : []).length > 2
            ? MIN_RANGE
            : undefined;
        var titleTextProp = visible && !isViewByTwoAttributes ? {} : { text: null }; // new way how to hide title instead of deprecated 'enabled'
        // for bar chart take y axis options
        return __assign(__assign(__assign(__assign(__assign({}, getAxisLineConfiguration(type, visible)), { 
            // hide ticks on x axis
            minorTickLength: 0, tickLength: 0, 
            // padding of maximum value
            maxPadding: 0.05, minRange: minRange, labels: __assign(__assign(__assign(__assign(__assign({}, labelsEnabled), { style: {
                    color: axisValueColor,
                    font: '12px gdcustomfont, Avenir, "Helvetica Neue", Arial, sans-serif',
                }, autoRotation: [-90] }), formatter), rotationProp), { 
                // Due to a bug in Highcharts & grouped-categories the autoRotation is working only with useHtml
                // See: https://github.com/blacklabel/grouped_categories/issues/137
                useHTML: !isInvertedChart && isViewByTwoAttributes }), title: __assign(__assign({}, titleTextProp), { margin: 10, style: {
                    textOverflow: "ellipsis",
                    color: axisLabelColor,
                    font: '14px gdcustomfont, Avenir, "Helvetica Neue", Arial, sans-serif',
                } }), className: className }), maxProp), minProp), tickConfiguration);
    });
};
function getAxesConfiguration(chartOptions, _config, chartConfig, _drillConfig, _intl, theme) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    var axisValueColor = (_e = (_b = (_a = theme === null || theme === void 0 ? void 0 : theme.chart) === null || _a === void 0 ? void 0 : _a.axisValueColor) !== null && _b !== void 0 ? _b : (_d = (_c = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _c === void 0 ? void 0 : _c.complementary) === null || _d === void 0 ? void 0 : _d.c6) !== null && _e !== void 0 ? _e : styleVariables.gdColorStateBlank;
    var axisLabelColor = (_k = (_g = (_f = theme === null || theme === void 0 ? void 0 : theme.chart) === null || _f === void 0 ? void 0 : _f.axisLabelColor) !== null && _g !== void 0 ? _g : (_j = (_h = theme === null || theme === void 0 ? void 0 : theme.palette) === null || _h === void 0 ? void 0 : _h.complementary) === null || _j === void 0 ? void 0 : _j.c7) !== null && _k !== void 0 ? _k : styleVariables.gdColorLink;
    return {
        plotOptions: {
            series: __assign({}, shouldExpandYAxis(chartOptions)),
        },
        yAxis: getYAxisConfiguration(chartOptions, chartConfig, axisValueColor, axisLabelColor),
        xAxis: getXAxisConfiguration(chartOptions, chartConfig, axisValueColor, axisLabelColor),
    };
}
function getTargetCursorConfigurationForBulletChart(chartOptions) {
    var type = chartOptions.type, data = chartOptions.data;
    if (!isBulletChart(type)) {
        return {};
    }
    var isTargetDrillable = data.series.some(function (series) { return series.type === "bullet" && series.isDrillable; });
    return isTargetDrillable ? { plotOptions: { bullet: { cursor: "pointer" } } } : {};
}
function getZoomingAndPanningConfiguration(_chartOptions, _config, chartConfig) {
    return (chartConfig === null || chartConfig === void 0 ? void 0 : chartConfig.zoomInsight) ? {
        chart: {
            animation: true,
            zoomType: "x",
            panKey: "shift",
            panning: {
                enabled: true,
            },
            resetZoomButton: {
                theme: {
                    display: "none",
                },
            },
        },
    }
        : undefined;
}
export function getCustomizedConfiguration(chartOptions, chartConfig, drillConfig, intl, theme) {
    var configurators = [
        getTitleConfiguration,
        getAxesConfiguration,
        getStackingConfiguration,
        hideOverlappedLabels,
        getDataConfiguration,
        getTooltipConfiguration,
        getHoverStyles,
        getGridConfiguration,
        getLabelsConfiguration,
        getDataPointsConfiguration,
        // should be after 'getDataConfiguration' to modify 'series'
        // and should be after 'getStackingConfiguration' to get stackLabels config
        getOptionalStackingConfiguration,
        getZeroAlignConfiguration,
        getAxisNameConfiguration,
        getAxisLabelConfigurationForDualBarChart,
        getTargetCursorConfigurationForBulletChart,
        getZoomingAndPanningConfiguration,
    ];
    var commonData = configurators.reduce(function (config, configurator) {
        return merge(config, configurator(chartOptions, config, chartConfig, drillConfig, intl, theme));
    }, {});
    return merge({}, commonData);
}
//# sourceMappingURL=customConfiguration.js.map