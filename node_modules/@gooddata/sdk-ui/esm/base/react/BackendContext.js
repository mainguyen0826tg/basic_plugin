import { __assign } from "tslib";
// (C) 2019 GoodData Corporation
import React from "react";
import { wrapDisplayName } from "./wrapDisplayName";
import invariant from "ts-invariant";
var BackendContext = React.createContext(undefined);
BackendContext.displayName = "BackendContext";
/**
 * BackendProvider can be used to inject analytical backend instance to all ui-sdk components in your app.
 *
 * @public
 */
export var BackendProvider = function (_a) {
    var children = _a.children, backend = _a.backend;
    return React.createElement(BackendContext.Provider, { value: backend }, children);
};
/**
 * Hook to get analytical backend instance provided to {@link BackendProvider}.
 * You can optionally set a backend override that will be returned if defined.
 * This makes the usage more ergonomic (see the following example).
 *
 * Note: For a better TypeScript experience without the hassle of undefined values, you can use the {@link useBackendStrict} hook.
 *
 * @example
 * ```
 * // instead of
 * const fromContext = useBackend();
 * const effectiveBackend = fromArguments ?? fromContext.
 * // you can write
 * const backend = useBackend(fromArguments);
 *```
 *
 * @param backend - backend to use instead of context value. If undefined, the context value is used.
 * @public
 */
export var useBackend = function (backend) {
    var backendFromContext = React.useContext(BackendContext);
    return backend !== null && backend !== void 0 ? backend : backendFromContext;
};
/**
 * Hook to get analytical backend instance provided to {@link BackendProvider}.
 * You can optionally set a backend override that will be returned if defined.
 * This makes the usage more ergonomic (see the following example).
 *
 * Note: If you do not provide an {@link @gooddata/sdk-backend-spi#IAnalyticalBackend} instance to {@link BackendProvider} or as a parameter for this hook,
 * an invariant error is raised.
 *
 * @example
 * ```
 * // instead of
 * const fromContext = useBackendStrict();
 * const effectiveBackend = fromArguments ?? fromContext.
 * // you can write
 * const backend = useBackendStrict(fromArguments);
 *```
 *
 * @param backend - backend to use instead of context value. If undefined, the context value is used.
 * @param context - optionally provide context to improve error message in raised invariant (e.g. parent hook name).
 * @public
 */
export var useBackendStrict = function (backend, context) {
    if (context === void 0) { context = "useBackendStrict"; }
    var backendFromContext = React.useContext(BackendContext);
    var effectiveBackend = backend !== null && backend !== void 0 ? backend : backendFromContext;
    invariant(effectiveBackend, context + ": IAnalyticalBackend must be defined. Either pass it as a parameter or make sure there is a BackendProvider up the component tree.");
    return effectiveBackend;
};
/**
 * Wraps component into a BackendContext consumer - injecting an instance of backend from context into the
 * backend prop.
 *
 * @internal
 */
export function withBackend(Component) {
    var ComponentWithInjectedBackend = function (props) {
        return (React.createElement(BackendContext.Consumer, null, function (backend) { var _a; return React.createElement(Component, __assign({}, props, { backend: (_a = props.backend) !== null && _a !== void 0 ? _a : backend })); }));
    };
    return wrapDisplayName("withBackend", Component)(ComponentWithInjectedBackend);
}
//# sourceMappingURL=BackendContext.js.map