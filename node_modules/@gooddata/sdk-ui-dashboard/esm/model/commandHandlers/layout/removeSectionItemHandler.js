import { __assign, __generator } from "tslib";
import { dispatchDashboardEvent } from "../../store/_infra/eventDispatcher";
import { invalidArgumentsProvided } from "../../events/general";
import { selectLayout } from "../../store/layout/layoutSelectors";
import { put, select } from "redux-saga/effects";
import { validateItemExists, validateSectionExists } from "./validation/layoutValidation";
import { layoutSectionItemRemoved, layoutSectionRemoved } from "../../events/layout";
import { layoutActions } from "../../store/layout";
function validateAndResolve(commandCtx) {
    var ctx = commandCtx.ctx, _a = commandCtx.cmd.payload, sectionIndex = _a.sectionIndex, itemIndex = _a.itemIndex, layout = commandCtx.layout;
    if (!validateSectionExists(layout, sectionIndex)) {
        throw invalidArgumentsProvided(ctx, commandCtx.cmd, "Attempting to remove item from non-existent section at " + sectionIndex + ". There are only " + layout.sections.length + " sections.");
    }
    var fromSection = layout.sections[sectionIndex];
    if (!validateItemExists(fromSection, itemIndex)) {
        throw invalidArgumentsProvided(ctx, commandCtx.cmd, "Attempting to remove non-existent item from index " + itemIndex + " in section " + sectionIndex + ". There are only " + fromSection.items.length + " items in this section.");
    }
    var itemToRemove = fromSection.items[itemIndex];
    return {
        fromSection: fromSection,
        itemToRemove: itemToRemove,
    };
}
export function removeSectionItemHandler(ctx, cmd) {
    var commandCtx, _a, _b, fromSection, itemToRemove, _c, sectionIndex, itemIndex, eager, stashIdentifier, sectionWithEmptyItems;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0:
                _a = {
                    ctx: ctx,
                    cmd: cmd
                };
                return [4 /*yield*/, select(selectLayout)];
            case 1:
                commandCtx = (_a.layout = _d.sent(),
                    _a);
                _b = validateAndResolve(commandCtx), fromSection = _b.fromSection, itemToRemove = _b.itemToRemove;
                _c = cmd.payload, sectionIndex = _c.sectionIndex, itemIndex = _c.itemIndex, eager = _c.eager, stashIdentifier = _c.stashIdentifier;
                if (!(eager && fromSection.items.length === 1)) return [3 /*break*/, 5];
                return [4 /*yield*/, put(layoutActions.removeSection({
                        index: sectionIndex,
                        stashIdentifier: stashIdentifier,
                        undo: {
                            cmd: cmd,
                        },
                    }))];
            case 2:
                _d.sent();
                sectionWithEmptyItems = __assign(__assign({}, fromSection), { items: [] });
                return [4 /*yield*/, dispatchDashboardEvent(layoutSectionItemRemoved(ctx, itemToRemove, itemIndex, sectionWithEmptyItems, stashIdentifier, cmd.correlationId))];
            case 3:
                _d.sent();
                return [4 /*yield*/, dispatchDashboardEvent(layoutSectionRemoved(ctx, sectionWithEmptyItems, sectionIndex, true, undefined, cmd.correlationId))];
            case 4:
                _d.sent();
                return [3 /*break*/, 8];
            case 5: return [4 /*yield*/, put(layoutActions.removeSectionItem({
                    sectionIndex: sectionIndex,
                    itemIndex: itemIndex,
                    stashIdentifier: stashIdentifier,
                    undo: {
                        cmd: cmd,
                    },
                }))];
            case 6:
                _d.sent();
                return [4 /*yield*/, dispatchDashboardEvent(layoutSectionItemRemoved(ctx, itemToRemove, itemIndex, undefined, stashIdentifier, cmd.correlationId))];
            case 7:
                _d.sent();
                _d.label = 8;
            case 8: return [2 /*return*/];
        }
    });
}
//# sourceMappingURL=removeSectionItemHandler.js.map