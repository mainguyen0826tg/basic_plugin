// (C) 2021 GoodData Corporation
import { __assign, __generator, __rest } from "tslib";
import { batchActions } from "redux-batched-actions";
import { call, put, select, setContext } from "redux-saga/effects";
import { dashboardFilterContextIdentity } from "../../../_staging/dashboard/dashboardFilterContext";
import { dashboardLayoutRemoveIdentity, dashboardLayoutWidgetIdentityMap, } from "../../../_staging/dashboard/dashboardLayout";
import { dashboardCopySaved } from "../../events/dashboard";
import { filterContextActions } from "../../store/filterContext";
import { selectFilterContextDefinition } from "../../store/filterContext/filterContextSelectors";
import { layoutActions } from "../../store/layout";
import { selectBasicLayout } from "../../store/layout/layoutSelectors";
import { metaActions } from "../../store/meta";
import { selectDashboardDescriptor, selectPersistedDashboard, selectPersistedDashboardFilterContextAsFilterContextDefinition, } from "../../store/meta/metaSelectors";
import { selectDateFilterConfigOverrides } from "../../store/dateFilterConfig/dateFilterConfigSelectors";
import { alertsActions } from "../../store/alerts";
import { savingActions } from "../../store/saving";
import { selectSettings } from "../../store/config/configSelectors";
import { selectBackendCapabilities } from "../../store/backendCapabilities/backendCapabilitiesSelectors";
function createDashboard(ctx, saveAsCtx) {
    return ctx.backend.workspace(ctx.workspace).dashboards().createDashboard(saveAsCtx.dashboardToSave);
}
/*
 * TODO: custom widget persistence; we need a new backend capability that indicates whether the
 *  backend can persist custom widget content (tiger can already, bear cannot). Based on that
 *  capability, this code should use either the selectBasicLayout (that strips any custom widgets) or
 *  selectLayout (that keeps custom widgets).
 */
function createDashboardSaveAsContext(cmd) {
    var _a, title, useOriginalFilterContext, titleProp, persistedDashboard, dashboardDescriptor, originalDashboardDescription, filterContextDefinition, layout, dateFilterConfig, settings, capabilities, _unusedProp, dashboardDescriptorRest, dashboardFromState, pluginsProp, shareProp, dashboardToSave;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _a = cmd.payload, title = _a.title, useOriginalFilterContext = _a.useOriginalFilterContext;
                titleProp = title ? { title: title } : {};
                return [4 /*yield*/, select(selectPersistedDashboard)];
            case 1:
                persistedDashboard = _b.sent();
                return [4 /*yield*/, select(selectDashboardDescriptor)];
            case 2:
                dashboardDescriptor = _b.sent();
                return [4 /*yield*/, select(selectPersistedDashboard)];
            case 3:
                originalDashboardDescription = _b.sent();
                return [4 /*yield*/, select(!useOriginalFilterContext || !originalDashboardDescription
                        ? selectFilterContextDefinition
                        : selectPersistedDashboardFilterContextAsFilterContextDefinition)];
            case 4:
                filterContextDefinition = _b.sent();
                return [4 /*yield*/, select(selectBasicLayout)];
            case 5:
                layout = _b.sent();
                return [4 /*yield*/, select(selectDateFilterConfigOverrides)];
            case 6:
                dateFilterConfig = _b.sent();
                return [4 /*yield*/, select(selectSettings)];
            case 7:
                settings = _b.sent();
                return [4 /*yield*/, select(selectBackendCapabilities)];
            case 8:
                capabilities = _b.sent();
                _unusedProp = dashboardDescriptor.isUnderStrictControl, dashboardDescriptorRest = __rest(dashboardDescriptor, ["isUnderStrictControl"]);
                dashboardFromState = __assign(__assign({ type: "IDashboard" }, dashboardDescriptorRest), { filterContext: __assign({}, filterContextDefinition), layout: layout,
                    dateFilterConfig: dateFilterConfig });
                pluginsProp = (persistedDashboard === null || persistedDashboard === void 0 ? void 0 : persistedDashboard.plugins) ? { plugins: persistedDashboard.plugins } : {};
                shareProp = settings.enableAnalyticalDashboardPermissions && capabilities.supportsAccessControl
                    ? {
                        isLocked: false,
                        shareStatus: "private",
                        isUnderStrictControl: true,
                    }
                    : {
                        isLocked: false,
                        shareStatus: "public",
                    };
                dashboardToSave = __assign(__assign(__assign(__assign(__assign({}, dashboardFromState), titleProp), { layout: dashboardLayoutRemoveIdentity(layout, function () { return true; }) }), shareProp), pluginsProp);
                return [2 /*return*/, {
                        cmd: cmd,
                        dashboardFromState: dashboardFromState,
                        dashboardToSave: dashboardToSave,
                    }];
        }
    });
}
function saveAs(ctx, saveAsCtx) {
    var dashboard, identityMapping, batch;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, call(createDashboard, ctx, saveAsCtx)];
            case 1:
                dashboard = _a.sent();
                if (!saveAsCtx.cmd.payload.switchToCopy) {
                    return [2 /*return*/, {
                            dashboard: dashboard,
                        }];
                }
                identityMapping = dashboardLayoutWidgetIdentityMap(saveAsCtx.dashboardFromState.layout, dashboard.layout);
                batch = batchActions([
                    metaActions.setMeta({ dashboard: dashboard }),
                    alertsActions.setAlerts([]),
                    filterContextActions.updateFilterContextIdentity({
                        filterContextIdentity: dashboardFilterContextIdentity(dashboard),
                    }),
                    layoutActions.updateWidgetIdentities(identityMapping),
                    layoutActions.clearLayoutHistory(),
                ], "@@GDC.DASH.SAVE_AS");
                return [2 /*return*/, {
                        batch: batch,
                        dashboard: dashboard,
                    }];
        }
    });
}
export function saveAsDashboardHandler(ctx, cmd) {
    var saveAsCtx, switchToCopy, result, dashboard, batch, context, e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                _a.trys.push([0, 9, , 11]);
                return [4 /*yield*/, put(savingActions.setSavingStart())];
            case 1:
                _a.sent();
                return [4 /*yield*/, call(createDashboardSaveAsContext, cmd)];
            case 2:
                saveAsCtx = _a.sent();
                switchToCopy = cmd.payload.switchToCopy;
                return [4 /*yield*/, call(saveAs, ctx, saveAsCtx)];
            case 3:
                result = _a.sent();
                dashboard = result.dashboard, batch = result.batch;
                if (!batch) return [3 /*break*/, 5];
                return [4 /*yield*/, put(batch)];
            case 4:
                _a.sent();
                _a.label = 5;
            case 5:
                context = ctx;
                if (!switchToCopy) return [3 /*break*/, 7];
                context = __assign(__assign({}, ctx), { dashboardRef: dashboard.ref });
                return [4 /*yield*/, setContext({
                        dashboardContext: context,
                    })];
            case 6:
                _a.sent();
                _a.label = 7;
            case 7: return [4 /*yield*/, put(savingActions.setSavingSuccess())];
            case 8:
                _a.sent();
                return [2 /*return*/, dashboardCopySaved(context, dashboard, cmd.correlationId)];
            case 9:
                e_1 = _a.sent();
                return [4 /*yield*/, put(savingActions.setSavingError(e_1))];
            case 10:
                _a.sent();
                throw e_1;
            case 11: return [2 /*return*/];
        }
    });
}
//# sourceMappingURL=saveAsDashboardHandler.js.map