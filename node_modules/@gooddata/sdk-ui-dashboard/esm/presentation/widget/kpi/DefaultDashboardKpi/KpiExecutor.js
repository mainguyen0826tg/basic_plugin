import { __assign, __rest } from "tslib";
// (C) 2020 GoodData Corporation
import React, { memo, useCallback, useEffect, useMemo } from "react";
import { useIntl } from "react-intl";
import compact from "lodash/compact";
import isEqual from "lodash/isEqual";
import isNil from "lodash/isNil";
import isNumber from "lodash/isNumber";
import flowRight from "lodash/flowRight";
import round from "lodash/round";
import { widgetRef, } from "@gooddata/sdk-backend-spi";
import { isMeasureFormatInPercent, measureLocalId, objRefToString, } from "@gooddata/sdk-model";
import { convertDrillableItemsToPredicates, createNumberJsFormatter, isSomeHeaderPredicateMatched, NoDataSdkError, withBackend, withExecution, } from "@gooddata/sdk-ui";
import { filterContextItemsToFiltersForWidget } from "../../../../converters";
import { selectDrillableItems, selectPermissions, selectSettings, selectUser, useDashboardAsyncRender, useDashboardSelector, useDashboardUserInteraction, useWidgetExecutionsHandler, selectValidConfiguredDrillsByWidgetRef, uiActions, useDashboardDispatch, selectIsKpiAlertOpenedByWidgetRef, selectIsKpiAlertHighlightedByWidgetRef, } from "../../../../model";
import { DashboardItemHeadline } from "../../../presentationComponents";
import { KpiRenderer } from "./KpiRenderer";
import { KpiAlertDialogWrapper } from "./KpiAlertDialogWrapper";
import { useKpiAlertOperations } from "./useKpiAlertOperations";
import { DashboardItemWithKpiAlert, evaluateAlertTriggered } from "./KpiAlerts";
import { dashboardFilterToFilterContextItem, stripDateDatasets } from "./utils/filterUtils";
import { useWidgetBrokenAlertsQuery } from "../../common/useWidgetBrokenAlertsQuery";
import { invariant } from "ts-invariant";
var KpiExecutorCore = function (props) {
    var backend = props.backend, workspace = props.workspace, dashboardRef = props.dashboardRef, kpiWidget = props.kpiWidget, primaryMeasure = props.primaryMeasure, secondaryMeasure = props.secondaryMeasure, separators = props.separators, effectiveFilters = props.effectiveFilters, result = props.result, alert = props.alert, alertExecutionResult = props.alertExecutionResult, error = props.error, alertExecutionError = props.alertExecutionError, isLoading = props.isLoading, isAlertExecutionLoading = props.isAlertExecutionLoading, onDrill = props.onDrill, onError = props.onError, onFiltersChange = props.onFiltersChange, isReadOnly = props.isReadOnly, disableDrillUnderline = props.disableDrillUnderline;
    var intl = useIntl();
    var currentUser = useDashboardSelector(selectUser);
    var permissions = useDashboardSelector(selectPermissions);
    var settings = useDashboardSelector(selectSettings);
    var drillableItems = useDashboardSelector(selectDrillableItems);
    var widgetDrills = useDashboardSelector(selectValidConfiguredDrillsByWidgetRef(kpiWidget.ref));
    var isAlertDialogOpen = useDashboardSelector(selectIsKpiAlertOpenedByWidgetRef(kpiWidget.ref));
    var isAlertHighlighted = useDashboardSelector(selectIsKpiAlertHighlightedByWidgetRef(kpiWidget.ref));
    var dispatch = useDashboardDispatch();
    var openAlertDialog = useCallback(function () {
        dispatch(uiActions.openKpiAlertDialog(kpiWidget.ref));
    }, [kpiWidget]);
    var closeAlertDialog = useCallback(function () {
        dispatch(uiActions.closeKpiAlertDialog());
    }, []);
    var brokenAlertsBasicInfo = useWidgetBrokenAlertsQuery(kpiWidget, alert).result;
    var isAlertBroken = !!(brokenAlertsBasicInfo === null || brokenAlertsBasicInfo === void 0 ? void 0 : brokenAlertsBasicInfo.length);
    var executionsHandler = useWidgetExecutionsHandler(widgetRef(kpiWidget));
    useEffect(function () {
        var err = error !== null && error !== void 0 ? error : alertExecutionError;
        if (err) {
            onError === null || onError === void 0 ? void 0 : onError(err);
        }
        // for executions we care only about KPI errors
        if (error) {
            executionsHandler.onError(error);
        }
    }, [error, alertExecutionError]);
    useEffect(function () {
        if (result) {
            // empty data is considered an error for execution handling
            if (result.rawData().isEmpty()) {
                executionsHandler.onError(new NoDataSdkError());
            }
            else {
                executionsHandler.onSuccess(result.result());
            }
        }
    }, [result]);
    var handleOnDrill = useCallback(function (drillContext) {
        if (!onDrill) {
            return false;
        }
        return onDrill({
            dataView: result === null || result === void 0 ? void 0 : result.dataView,
            drillContext: drillContext,
            drillDefinitions: kpiWidget.drills,
            widgetRef: widgetRef(kpiWidget),
        });
    }, [onDrill, result, kpiWidget]);
    var kpiAlertOperations = useKpiAlertOperations(closeAlertDialog);
    var canSetAlert = permissions === null || permissions === void 0 ? void 0 : permissions.canCreateScheduledMail;
    var _a = useDashboardAsyncRender(objRefToString(widgetRef(kpiWidget))), onRequestAsyncRender = _a.onRequestAsyncRender, onResolveAsyncRender = _a.onResolveAsyncRender;
    useEffect(function () {
        if (isLoading) {
            onRequestAsyncRender();
        }
        else {
            onResolveAsyncRender();
        }
        executionsHandler.onLoadingChanged({ isLoading: !!isLoading });
    }, [isLoading, onRequestAsyncRender, onResolveAsyncRender]);
    var _b = useDashboardUserInteraction(), kpiAlertDialogClosed = _b.kpiAlertDialogClosed, kpiAlertDialogOpened = _b.kpiAlertDialogOpened;
    var kpiResult = !(result === null || result === void 0 ? void 0 : result.dataView.totalCount[0])
        ? getNoDataKpiResult(result, primaryMeasure)
        : getKpiResult(result, primaryMeasure, secondaryMeasure, separators);
    var kpiAlertResult = getKpiAlertResult(alertExecutionResult, primaryMeasure, separators);
    var _c = useMemo(function () { return getAlertThresholdInfo(kpiResult, intl); }, [kpiResult, intl]), isThresholdRepresentingPercent = _c.isThresholdRepresentingPercent, thresholdPlaceholder = _c.thresholdPlaceholder;
    var predicates = convertDrillableItemsToPredicates(drillableItems);
    var isDrillable = ((kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureDescriptor) &&
        result &&
        status !== "error" &&
        isSomeHeaderPredicateMatched(predicates, kpiResult.measureDescriptor, result)) ||
        widgetDrills.length > 0;
    var enableCompactSize = settings.enableKDWidgetCustomHeight;
    var alertSavingStatus = kpiAlertOperations.creatingStatus === "inProgress" ||
        kpiAlertOperations.updatingStatus === "inProgress"
        ? "inProgress"
        : kpiAlertOperations.creatingStatus === "error" || kpiAlertOperations.updatingStatus === "error"
            ? "error"
            : "idle";
    return (React.createElement(DashboardItemWithKpiAlert, { kpi: kpiWidget, alert: alert, filters: effectiveFilters, userWorkspaceSettings: settings, kpiResult: kpiResult, renderHeadline: function (clientHeight) { return (React.createElement(DashboardItemHeadline, { title: kpiWidget.title, clientHeight: clientHeight })); }, kpiAlertResult: kpiAlertResult, canSetAlert: canSetAlert, isReadOnlyMode: isReadOnly, alertExecutionError: alertExecutionError !== null && alertExecutionError !== void 0 ? alertExecutionError : 
        /*
         * if alert is broken, behave as if its execution yielded no data (which is true, we do not execute it)
         * context: the problem is alerts on KPIs without dateDataset, their date filters are invalid
         * and we have no idea what date dataset to put there hence it is sometimes impossible
         * to execute them (unlike KPI Dashboards, we do not have the guarantee that there is a date
         * filter in the filters)
         */
        (isAlertBroken ? new NoDataSdkError() : undefined), isLoading: false /* content is always loaded at this point */, isAlertLoading: false /* alerts are always loaded at this point */, isAlertExecutionLoading: isAlertExecutionLoading, isAlertBroken: isAlertBroken, isAlertDialogOpen: isAlertDialogOpen, isAlertHighlighted: isAlertHighlighted, onAlertDialogOpenClick: function () {
            kpiAlertDialogOpened(!!alert);
            openAlertDialog();
        }, renderAlertDialog: function () { return (React.createElement(KpiAlertDialogWrapper, { alert: alert, dateFormat: settings.responsiveUiDateFormat, userEmail: currentUser.email, onAlertDialogCloseClick: function () {
                kpiAlertDialogClosed();
                closeAlertDialog();
            }, onAlertDialogDeleteClick: function () {
                kpiAlertOperations.onRemoveAlert(alert);
            }, onAlertDialogSaveClick: function (threshold, whenTriggered) {
                var _a, _b;
                if (alert) {
                    return kpiAlertOperations.onUpdateAlert(__assign(__assign({}, alert), { threshold: threshold,
                        whenTriggered: whenTriggered, isTriggered: evaluateAlertTriggered(kpiAlertResult.measureResult, threshold, whenTriggered) }));
                }
                // alerts are not possible when the dashboard is not yet persisted. if the code bombs here
                // then it means we use view-mode KPI widget in edit-mode dashboard - there is a configuration
                // customization error somewhere.
                invariant(dashboardRef, "attempting to create alert of an unsaved dashboard");
                return kpiAlertOperations.onCreateAlert({
                    dashboard: dashboardRef,
                    widget: widgetRef(kpiWidget),
                    threshold: threshold,
                    whenTriggered: whenTriggered,
                    isTriggered: evaluateAlertTriggered((_a = kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureResult) !== null && _a !== void 0 ? _a : 0, threshold, whenTriggered),
                    filterContext: {
                        title: "filterContext",
                        description: "",
                        filters: (_b = effectiveFilters === null || effectiveFilters === void 0 ? void 0 : effectiveFilters.map(dashboardFilterToFilterContextItem).map(stripDateDatasets)) !== null && _b !== void 0 ? _b : [],
                    },
                    description: "",
                    title: "",
                });
            }, onAlertDialogUpdateClick: function () {
                var _a, _b;
                return kpiAlertOperations.onUpdateAlert(__assign(__assign({}, alert), { 
                    // evaluate triggered as if the alert already used the correct filters (i.e. use the KPI execution itself)
                    isTriggered: evaluateAlertTriggered((_a = kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureResult) !== null && _a !== void 0 ? _a : 0, alert.threshold, alert.whenTriggered), 
                    // change the filters to the filters currently used by the KPI
                    filterContext: __assign(__assign({}, alert.filterContext), { filters: (_b = effectiveFilters === null || effectiveFilters === void 0 ? void 0 : effectiveFilters.map(dashboardFilterToFilterContextItem).map(stripDateDatasets)) !== null && _b !== void 0 ? _b : [] }) }));
            }, onApplyAlertFiltersClick: onFiltersChange
                ? function () {
                    var _a, _b;
                    return onFiltersChange(filterContextItemsToFiltersForWidget((_b = (_a = alert === null || alert === void 0 ? void 0 : alert.filterContext) === null || _a === void 0 ? void 0 : _a.filters) !== null && _b !== void 0 ? _b : [], kpiWidget), true);
                }
                : undefined, isAlertLoading: isAlertExecutionLoading, alertDeletingStatus: kpiAlertOperations.removingStatus, alertSavingStatus: alertSavingStatus, alertUpdatingStatus: alertSavingStatus, filters: effectiveFilters, isThresholdRepresentingPercent: isThresholdRepresentingPercent, thresholdPlaceholder: thresholdPlaceholder, brokenAlertFiltersBasicInfo: brokenAlertsBasicInfo, backend: backend, workspace: workspace })); }, alertDeletingStatus: kpiAlertOperations.removingStatus, alertSavingStatus: alertSavingStatus }, function () {
        return (React.createElement(KpiRenderer, { kpi: kpiWidget, kpiResult: kpiResult, filters: effectiveFilters !== null && effectiveFilters !== void 0 ? effectiveFilters : [], disableDrillUnderline: disableDrillUnderline, isDrillable: isDrillable, onDrill: onDrill && handleOnDrill, separators: separators, enableCompactSize: enableCompactSize, error: error, errorHelp: intl.formatMessage({ id: "kpi.error.view" }), isLoading: props.isLoading }));
    }));
};
/**
 * Executes the given measures and displays them as KPI
 * @internal
 */
export var KpiExecutor = flowRight(memo, withBackend, withExecution({
    shouldRefetch: function (prevProps, nextProps) {
        return (prevProps.alert !== nextProps.alert ||
            !isEqual(prevProps.primaryMeasure, nextProps.primaryMeasure) ||
            !isEqual(prevProps.effectiveFilters, nextProps.effectiveFilters));
    },
    execution: function (props) {
        var backend = props.backend, workspace = props.workspace, effectiveFilters = props.effectiveFilters, primaryMeasure = props.primaryMeasure;
        return backend.workspace(workspace).execution().forItems([primaryMeasure], effectiveFilters);
    },
    exportTitle: "",
    loadOnMount: true,
}), function (WrappedComponent) {
    var withAlertProps = function (_a) {
        var result = _a.result, error = _a.error, isLoading = _a.isLoading, props = __rest(_a, ["result", "error", "isLoading"]);
        return (React.createElement(WrappedComponent, __assign({ alertExecutionResult: result, alertExecutionError: error, isAlertExecutionLoading: isLoading }, props)));
    };
    return withAlertProps;
}, withExecution({
    shouldRefetch: function (prevProps, nextProps) {
        return (!isEqual(prevProps.primaryMeasure, nextProps.primaryMeasure) ||
            !isEqual(prevProps.secondaryMeasure, nextProps.secondaryMeasure) ||
            !isEqual(prevProps.effectiveFilters, nextProps.effectiveFilters));
    },
    execution: function (props) {
        var backend = props.backend, workspace = props.workspace, primaryMeasure = props.primaryMeasure, secondaryMeasure = props.secondaryMeasure, effectiveFilters = props.effectiveFilters;
        return backend
            .workspace(workspace)
            .execution()
            .forItems(compact([primaryMeasure, secondaryMeasure]), effectiveFilters);
    },
    exportTitle: "",
    loadOnMount: true,
}))(KpiExecutorCore);
function getSeriesResult(series) {
    if (!series) {
        return null;
    }
    var value = series.dataPoints()[0].rawValue;
    if (isNil(value)) {
        return null;
    }
    if (isNumber(value)) {
        return value;
    }
    return Number.parseFloat(value);
}
function getNoDataKpiResult(result, primaryMeasure) {
    var _a, _b;
    if (!result) {
        return;
    }
    return {
        measureDescriptor: result.meta().measureDescriptor(measureLocalId(primaryMeasure)),
        measureFormat: (_b = (_a = result.meta().measureDescriptor(measureLocalId(primaryMeasure))) === null || _a === void 0 ? void 0 : _a.measureHeaderItem) === null || _b === void 0 ? void 0 : _b.format,
        measureResult: undefined,
        measureForComparisonResult: undefined,
    };
}
function getKpiResult(result, primaryMeasure, secondaryMeasure, separators) {
    var series = result === null || result === void 0 ? void 0 : result.data({ valueFormatter: createNumberJsFormatter(separators) }).series();
    var primarySeries = series === null || series === void 0 ? void 0 : series.firstForMeasure(primaryMeasure);
    var secondarySeries = secondaryMeasure ? series === null || series === void 0 ? void 0 : series.firstForMeasure(secondaryMeasure) : undefined;
    return primarySeries
        ? {
            measureDescriptor: primarySeries.descriptor.measureDescriptor,
            measureFormat: primarySeries.measureFormat(),
            measureResult: getSeriesResult(primarySeries),
            measureForComparisonResult: getSeriesResult(secondarySeries),
        }
        : undefined;
}
function getKpiAlertResult(result, primaryMeasure, separators) {
    var alertSeries = result === null || result === void 0 ? void 0 : result.data({ valueFormatter: createNumberJsFormatter(separators) }).series();
    return alertSeries
        ? {
            measureFormat: alertSeries.count
                ? alertSeries.firstForMeasure(primaryMeasure).measureFormat()
                : undefined,
            measureResult: alertSeries.count
                ? getSeriesResult(alertSeries.firstForMeasure(primaryMeasure))
                : 0,
        }
        : undefined;
}
function getAlertThresholdInfo(kpiResult, intl) {
    var isThresholdRepresentingPercent = (kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureFormat) ? isMeasureFormatInPercent(kpiResult.measureFormat)
        : false;
    var value = round((kpiResult === null || kpiResult === void 0 ? void 0 : kpiResult.measureResult) || 0, 2); // sure about rounding?
    var thresholdPlaceholder = isThresholdRepresentingPercent
        ? intl.formatMessage({ id: "kpi.alertBox.example" }) + " " + value * 100
        : intl.formatMessage({ id: "kpi.alertBox.example" }) + " " + value; // TODO fix floating point multiply
    return {
        isThresholdRepresentingPercent: isThresholdRepresentingPercent,
        thresholdPlaceholder: thresholdPlaceholder,
    };
}
//# sourceMappingURL=KpiExecutor.js.map