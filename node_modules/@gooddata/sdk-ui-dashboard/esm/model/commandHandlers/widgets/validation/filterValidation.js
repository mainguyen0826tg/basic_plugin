import { __generator, __values } from "tslib";
// (C) 2021 GoodData Corporation
import { queryDateDatasetsForInsight, queryDateDatasetsForMeasure, } from "../../../queries";
import { call, select } from "redux-saga/effects";
import { query } from "../../../store/_infra/queryCall";
import { newCatalogDateDatasetMap } from "../../../../_staging/metadata/objRefMap";
import { invalidArgumentsProvided } from "../../../events/general";
import { areObjRefsEqual, objRefToString } from "@gooddata/sdk-model";
import { resolveDisplayFormMetadata } from "../../../utils/displayFormResolver";
import isEmpty from "lodash/isEmpty";
import { selectFilterContextAttributeFilters } from "../../../store/filterContext/filterContextSelectors";
/**
 * This generator validates that a date dataset with the provided ref can be used for date filtering of insight in
 * particular insight widget. If the result is positive, a catalog entry of the date dataset will be returned.
 *
 * If the result is negative a DashboardCommandFailed will be thrown.
 *
 * The validation will trigger the QueryInsightDateDatasets to obtain a list of all available, valid date datasets for
 * the insight widget - that's where the actual complex logic takes place.
 *
 * Note that the query is a cached query - first execution will cache all available date dataset information in state and
 * the subsequent calls will be instant.
 *
 * @param ctx - dashboard context in which the validation is done
 * @param cmd - dashboard command it the context of which the validation is done
 * @param widget - insight that whose date filter is about to change
 * @param dateDataSet - ref of a date dataset to validate
 * @param resolvedInsight - optionally specify entire insight used by the insight widget; if provided, the query
 *  to obtain date datasets for the insight will use insight instead of looking up insight ref in the current dashboard state.
 *  Passing resolved insight is essential in cases when this validation is done before the insight widget
 *  is actually added onto dashboard - because in that case the insight itself is not yet part of the state and
 *  the query is limited (intentionally) to query only by refs of insights that are on the dashboard
 */
export function validateDatasetForInsightWidgetDateFilter(ctx, cmd, widget, dateDataSet, resolvedInsight) {
    var insightDateDatasets, catalogDataSet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, call(query, queryDateDatasetsForInsight(resolvedInsight ? resolvedInsight : widget.insight))];
            case 1:
                insightDateDatasets = _a.sent();
                catalogDataSet = newCatalogDateDatasetMap(insightDateDatasets.allAvailableDateDatasets).get(dateDataSet);
                if (!catalogDataSet) {
                    throw invalidArgumentsProvided(ctx, cmd, "Attempting to use date dataset " + objRefToString(dateDataSet) + "\n            to filter insight widget " + objRefToString(widget.ref) + " but the data set either does not exist or\n            is not valid to use for filtering the insight.");
                }
                return [2 /*return*/, catalogDataSet];
        }
    });
}
/**
 * This generator validates that a date dataset with the provided ref can be used for date filtering of a particular
 * KPI widget. If the result is positive, a normalized ref of the date dataset will be returned - this ref
 * should be used going forward, stored in state etc etc. If the result is negative a DashboardCommandFailed will be
 * thrown.
 *
 * The validation will trigger the QueryInsightDateDatasets to obtain a list of all available, valid date datasets for
 * the insight widget - that's where the actual complex logic takes place.
 *
 * Note that the query is a cached query - first execution will cache all available date dataset information in state and
 * the subsequent calls will be instant.
 *
 * @param ctx - dashboard context in which the validation is done
 * @param cmd - dashboard command it the context of which the validation is done
 * @param widget - insight that whose date filter is about to change
 * @param dateDataSet - ref of a date dataset to validate
 */
export function validateDatasetForKpiWidgetDateFilter(ctx, cmd, widget, dateDataSet) {
    var measureDateDatasets, catalogDataSet;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, call(query, queryDateDatasetsForMeasure(widget.kpi.metric))];
            case 1:
                measureDateDatasets = _a.sent();
                catalogDataSet = newCatalogDateDatasetMap(measureDateDatasets.dateDatasets).get(dateDataSet);
                if (!catalogDataSet) {
                    throw invalidArgumentsProvided(ctx, cmd, "Attempting to use date dataset " + objRefToString(dateDataSet) + "\n            to filter insight widget " + objRefToString(widget.ref) + " but the data set either does not exist or\n            is not valid to use for filtering the insight.");
                }
                return [2 /*return*/, catalogDataSet];
        }
    });
}
/**
 * This generator validates whether it is possible to disable attribute filtering based on the refs of attribute display forms.
 * The validation is not widget-specific - it does not need any info from the widget. It validates that the display forms
 * used to specify filters to ignore are valid and that they are actually used in attribute filters that are currently
 * on the dashboard.
 *
 * If the result is positive, a list of normalized display form refs will be returned - these refs should be used going forward, stored in state etc. If the
 * result is negative a DashboardCommandFailed will be thrown.
 *
 * The validation may be trigger asynchronous processing when a display form cannot be resolved directly from the workspace
 * catalog that is stored in state. This can happen in two cases:
 *
 * -  ref is for a display form that is not part of production workspace catalog that is stored in the state; for instance
 *    happens when there are CSV, non-production datasets loaded and used on some of the dashboard insights
 * -  ref is for a bogus display form; code must check on backend and will find that backend has no such display form
 *    and will eventually bomb
 *
 * @param ctx - dashboard context in which the validation is done
 * @param cmd - dashboard command in the context of which the validation is done
 * @param _widget - widget on which the filters should be ignored
 * @param toIgnore - refs of display forms used in attribute filters that should be ignored
 */
export function validateAttributeFiltersToIgnore(ctx, cmd, _widget, toIgnore) {
    var resolvedDisplayForms, missing, resolved, existingFilters, badIgnores, filtersToIgnore, _loop_1, _a, _b, toIgnore_1;
    var e_1, _c;
    return __generator(this, function (_d) {
        switch (_d.label) {
            case 0: return [4 /*yield*/, call(resolveDisplayFormMetadata, ctx, toIgnore)];
            case 1:
                resolvedDisplayForms = _d.sent();
                missing = resolvedDisplayForms.missing, resolved = resolvedDisplayForms.resolved;
                if (!isEmpty(missing)) {
                    throw invalidArgumentsProvided(ctx, cmd, "Attempting to disable attribute filters but some of the display form refs to disable filters by do not exist: " + missing
                        .map(objRefToString)
                        .join(", "));
                }
                return [4 /*yield*/, select(selectFilterContextAttributeFilters)];
            case 2:
                existingFilters = _d.sent();
                badIgnores = [];
                filtersToIgnore = [];
                _loop_1 = function (toIgnore_1) {
                    var filterForDisplayForm = existingFilters.find(function (filter) {
                        return areObjRefsEqual(filter.attributeFilter.displayForm, toIgnore_1.ref);
                    });
                    if (!filterForDisplayForm) {
                        badIgnores.push(toIgnore_1.ref);
                    }
                    else {
                        filtersToIgnore.push(filterForDisplayForm);
                    }
                };
                try {
                    for (_a = __values(resolved.values()), _b = _a.next(); !_b.done; _b = _a.next()) {
                        toIgnore_1 = _b.value;
                        _loop_1(toIgnore_1);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                if (!isEmpty(badIgnores)) {
                    throw invalidArgumentsProvided(ctx, cmd, "Attempting to disable attribute filters but some of the display form refs to disable filters by are not used for filtering at all: " + badIgnores
                        .map(objRefToString)
                        .join(", "));
                }
                return [2 /*return*/, filtersToIgnore];
        }
    });
}
//# sourceMappingURL=filterValidation.js.map