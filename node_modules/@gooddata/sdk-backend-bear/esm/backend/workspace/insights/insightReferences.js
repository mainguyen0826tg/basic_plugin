// (C) 2019-2021 GoodData Corporation
import { __assign, __awaiter, __generator } from "tslib";
import { insightUri } from "@gooddata/sdk-model";
import { GdcMetadataObject } from "@gooddata/api-model-bear";
import { getObjectIdFromUri } from "../../../utils/api";
import union from "lodash/union";
import { convertMetadataObject } from "../../../convertors/fromBackend/MetaConverter";
import flow from "lodash/flow";
import isEmpty from "lodash/isEmpty";
import values from "lodash/values";
import keyBy from "lodash/keyBy";
import flatMap from "lodash/fp/flatMap";
import uniqBy from "lodash/fp/uniqBy";
import { convertMetric, convertWrappedFact, convertWrappedAttribute, } from "../../../convertors/fromBackend/CatalogConverter";
var objectTypeToObjectCategory = function (type) {
    switch (type) {
        case "displayForm":
            return "attributeDisplayForm";
        case "measure":
            return "metric";
        case "variable":
            return "prompt";
        default:
            return type;
    }
};
var objectTypesWithLinkToDataset = ["fact", "attribute"];
var objectCategoriesWithLinkToDataset = objectTypesWithLinkToDataset.map(objectTypeToObjectCategory);
/**
 * Given requested types, return types of objects that should be queried using 'using2' resource
 *
 * 1. When user wants data set info, then facts and attributes always must be queried
 * 2. When user wants attribute or display form, then both must be queried because they are needed
 *    for the CatalogItem
 */
function typesForXref(types) {
    var enrichedTypes = types.includes("dataSet")
        ? union(types, objectTypesWithLinkToDataset)
        : types;
    if (types.includes("attribute") || types.includes("displayForm")) {
        enrichedTypes = union(enrichedTypes, ["attribute", "displayForm"]);
    }
    return enrichedTypes;
}
/**
 * Given requested types, return types of objects that should be loaded.
 *
 * When user wants attribute or display form, then both must be queried because they are needed for CatalogItem
 */
function typesForLoad(types) {
    if (types.includes("attribute") || types.includes("displayForm")) {
        return union(types, ["attribute", "displayForm"]);
    }
    return types;
}
var InsightReferencesQuery = /** @class */ (function () {
    function InsightReferencesQuery(authCall, workspace, insight, requestedTypes) {
        var _this = this;
        this.authCall = authCall;
        this.workspace = workspace;
        this.insight = insight;
        this.requestedTypes = requestedTypes;
        this.run = function () { return __awaiter(_this, void 0, void 0, function () {
            var xrefs, datasets, objects;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (isEmpty(this.typesForXref)) {
                            return [2 /*return*/, {}];
                        }
                        return [4 /*yield*/, this.findReferencedObjects()];
                    case 1:
                        xrefs = _a.sent();
                        if (!this.requestedTypes.includes("dataSet")) return [3 /*break*/, 3];
                        return [4 /*yield*/, this.findDatasets(xrefs)];
                    case 2:
                        datasets = _a.sent();
                        xrefs.push.apply(xrefs, datasets);
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.loadObjects(xrefs)];
                    case 4:
                        objects = _a.sent();
                        return [2 /*return*/, this.createResult(objects)];
                }
            });
        }); };
        //
        //
        //
        /**
         * Uses the query resource to obtain all objects of the desired types which are used by the insight.
         */
        this.findReferencedObjects = function () { return __awaiter(_this, void 0, void 0, function () {
            var categories, allDirectObjects;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        categories = this.typesForXref.map(objectTypeToObjectCategory);
                        return [4 /*yield*/, this.authCall(function (sdk) {
                                return sdk.xhr.getParsed("/gdc/md/" + _this.workspace + "/using2/" + _this.objectId + "?types=" + categories.join(","));
                            })];
                    case 1:
                        allDirectObjects = (_a.sent()).entries;
                        return [2 /*return*/, allDirectObjects];
                }
            });
        }); };
        /**
         * Given objects used by the insight, retrieve dataSets to which they belong. The usedBy2 is bulk mode
         * is used for this.
         */
        this.findDatasets = function (objects) { return __awaiter(_this, void 0, void 0, function () {
            var uris, usedByPayload, datasetResponses;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        uris = objects
                            .filter(function (i) {
                            return objectCategoriesWithLinkToDataset.includes(i.category);
                        })
                            .map(function (i) { return i.link; });
                        usedByPayload = {
                            inUseMany: {
                                uris: uris,
                                types: ["dataSet"],
                                nearest: false,
                            },
                        };
                        return [4 /*yield*/, this.authCall(function (sdk) {
                                return sdk.xhr.postParsed("/gdc/md/" + _this.workspace + "/usedby2", {
                                    body: usedByPayload,
                                });
                            })];
                    case 1:
                        datasetResponses = _a.sent();
                        return [2 /*return*/, flow(flatMap(function (response) { return response.entries; }), uniqBy(function (dataSet) { return dataSet.identifier; }))(values(datasetResponses.useMany))];
                }
            });
        }); };
        /**
         * Give the discovered references, bulk load data for objects of those types that the caller is interested in.
         */
        this.loadObjects = function (xrefs) { return __awaiter(_this, void 0, void 0, function () {
            var categories, objectUrisToObtain;
            var _this = this;
            return __generator(this, function (_a) {
                categories = this.typesForLoad.map(objectTypeToObjectCategory);
                objectUrisToObtain = xrefs
                    .filter(function (i) { return categories.includes(i.category); })
                    .map(function (meta) { return meta.link; });
                return [2 /*return*/, this.authCall(function (sdk) { return sdk.md.getObjects(_this.workspace, objectUrisToObtain); })];
            });
        }); };
        var uri = insightUri(this.insight);
        this.objectId = getObjectIdFromUri(uri);
        this.typesForXref = typesForXref(this.requestedTypes);
        this.typesForLoad = typesForLoad(this.requestedTypes);
    }
    //
    //
    //
    InsightReferencesQuery.prototype.createResult = function (objects) {
        var unwrappedObjects = objects.map(GdcMetadataObject.unwrapMetadataObject);
        var convertedObjects = unwrappedObjects.map(convertMetadataObject);
        var wantDatasets = this.requestedTypes.includes("dataSet");
        if (this.requestedTypes.length === 1 && wantDatasets) {
            return {
                dataSetMeta: convertedObjects,
            };
        }
        var objectsByUri = keyBy(unwrappedObjects, function (obj) { return obj.meta.uri; });
        var catalogItems = [];
        var dataSetMeta = [];
        convertedObjects.forEach(function (obj) {
            var fullObject = objectsByUri[obj.uri];
            switch (obj.type) {
                case "displayForm":
                case "variable":
                    /*
                     * TODO: implement conversions in order to support these additional types;
                     *  attributeDf -> catalog item? or tis this reliably covered by "attribute" objects
                     *  variable -> ?? not catalog item, probably something else..
                     */
                    break;
                case "attribute":
                    catalogItems.push(convertWrappedAttribute({ attribute: fullObject }));
                    break;
                case "fact":
                    catalogItems.push(convertWrappedFact({ fact: fullObject }));
                    break;
                case "measure":
                    catalogItems.push(convertMetric({ metric: fullObject }));
                    break;
                case "dataSet":
                    dataSetMeta.push(obj);
                    break;
            }
        });
        var datasetProp = wantDatasets ? { dataSetMeta: dataSetMeta } : {};
        return __assign(__assign({}, datasetProp), { catalogItems: catalogItems });
    };
    return InsightReferencesQuery;
}());
export { InsightReferencesQuery };
//# sourceMappingURL=insightReferences.js.map