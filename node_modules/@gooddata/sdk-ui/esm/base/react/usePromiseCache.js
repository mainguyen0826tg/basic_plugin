import { __assign, __read } from "tslib";
// (C) 2007-2020 GoodData Corporation
import { useEffect, useState, useRef } from "react";
import { PromiseCache } from "./PromiseCache";
var initialState = {
    isLoading: false,
    results: [],
    errors: [],
};
/**
 * Hook for promise caching
 * It caches promises by params passed to provided factory function
 * It returns only new results
 * @internal
 */
export function usePromiseCache(promiseFactory, fetchParams, fetchDeps, resetDeps, getCacheKey) {
    var promiseCacheRef = useRef(new PromiseCache(promiseFactory, getCacheKey));
    var _a = __read(useState(initialState), 2), state = _a[0], setState = _a[1];
    var setInitialState = function () { return setState(initialState); };
    var setResults = function (results) { return setState(function (state) { return (__assign(__assign({}, state), { results: results })); }); };
    var setErrors = function (errors) { return setState(function (state) { return (__assign(__assign({}, state), { errors: errors })); }); };
    var setLoading = function (isLoading) { return setState(function (state) { return (__assign(__assign({}, state), { isLoading: isLoading })); }); };
    useEffect(function () {
        return function () {
            promiseCacheRef.current.reset();
            setInitialState();
        };
    }, resetDeps);
    useEffect(function () {
        var newParams = fetchParams.filter(function (params) { return !promiseCacheRef.current.getResult(params); });
        var newPromises = newParams.map(promiseCacheRef.current.load);
        if (newPromises.length === 0) {
            return;
        }
        // Because promises have their own lifecycle independent on react lifecycle,
        // we need to check if promise cache was not reset before their resolution
        // and our results are still relevant.
        // We do this by storing current promise cache in effect closure
        // so when promises are resolved, we have still access to it
        var usedPromiseCache = promiseCacheRef.current;
        setLoading(true);
        Promise.all(newPromises)
            .then(function (results) {
            setLoading(false);
            if (usedPromiseCache === promiseCacheRef.current) {
                setResults(results);
            }
        })
            .catch(function (errors) {
            setLoading(false);
            if (usedPromiseCache === promiseCacheRef.current) {
                setErrors(errors);
            }
        });
    }, fetchDeps);
    return state;
}
//# sourceMappingURL=usePromiseCache.js.map