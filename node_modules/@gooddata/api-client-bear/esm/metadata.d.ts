import { GdcVisualizationObject, GdcMetadata, GdcMetadataObject, GdcProjectDashboard } from "@gooddata/api-model-bear";
import { ApiResponse, XhrModule } from "./xhr";
import { IGetObjectsByQueryOptions, IGetObjectUsingOptions, IGetObjectsByQueryWithPagingResponse } from "./interfaces";
export interface IUriIdentifierPair {
    uri: string;
    identifier: string;
}
/**
 * Functions for working with metadata objects
 *
 * @class metadata
 * @module metadata
 */
export declare class MetadataModule {
    private xhr;
    constructor(xhr: XhrModule);
    /**
     * Get default display form value of provided attribute element uri
     * @param attributeElementUri string
     */
    getAttributeElementDefaultDisplayFormValue(attributeElementUri: string): Promise<GdcMetadata.IAttributeElement | undefined>;
    /**
     * Get default display form of provided attribute uri
     * @param attributeUri string
     */
    getAttributeDefaultDisplayForm(attributeUri: string): Promise<GdcMetadata.IAttributeDisplayForm>;
    /**
     * Get metadata object by provided identifier
     * @param projectId string
     * @param identifier string
     */
    getObjectByIdentifier<T extends GdcMetadataObject.WrappedObject = GdcMetadataObject.WrappedObject>(projectId: string, identifier: string): Promise<T>;
    /**
     * Get metadata objects by provided identifiers
     * @param projectId string
     * @param identifiers string[]
     */
    getObjectsByIdentifiers<T extends GdcMetadataObject.WrappedObject = GdcMetadataObject.WrappedObject>(projectId: string, identifiers: string[]): Promise<T[]>;
    /**
     * Load all objects with given uris
     * (use bulk loading instead of getting objects one by one)
     *
     * @method getObjects
     * @param {String} projectId id of the project
     * @param {Array} objectUris array of uris for objects to be loaded
     * @return {Array} array of loaded elements
     */
    getObjects<T extends GdcMetadataObject.WrappedObject = GdcMetadataObject.WrappedObject>(projectId: string, objectUris: string[]): Promise<T[]>;
    /**
     * Loads all objects by query (fetches all pages, one by one)
     *
     * @method getObjectsByQuery
     * @param {String} projectId id of the project
     * @param {Object} options (see https://developer.gooddata.com/api endpoint: /gdc/md/{project_id}/objects/query)
     *        - category {String} for example 'dataSets' or 'projectDashboard'
     *        - mode {String} 'enriched' or 'raw'
     *        - author {String} the URI of the author of the metadata objects
     *        - limit {number} default is 50 (also maximum)
     *        - deprecated {boolean} show also deprecated objects
     * @return {Promise<Array>} array of returned objects
     */
    getObjectsByQuery<T extends GdcMetadataObject.WrappedObject = GdcMetadataObject.WrappedObject>(projectId: string, options: IGetObjectsByQueryOptions): Promise<T[]>;
    /**
     * Loads all objects by query with paging
     *
     * @method getObjectsByQueryWithPaging
     * @param {String} projectId id of the project
     * @param {Object} options (see https://developer.gooddata.com/api endpoint: /gdc/md/{project_id}/objects/query)
     *        - category {String} for example 'dataSets' or 'projectDashboard'
     *        - mode {String} 'enriched' or 'raw'
     *        - author {String} the URI of the author of the metadata objects
     *        - limit {number} default is 50 (also maximum)
     *        - deprecated {boolean} show also deprecated objects
     *        - orderBy {id|title|updated} order the results by id, title or the last updated (newest first)
     *        - getTotalCount {boolean} include total count of items in the paging object
     * @return {Promise<Array>} array of returned objects
     */
    getObjectsByQueryWithPaging<T = any>(projectId: string, options: IGetObjectsByQueryOptions): Promise<IGetObjectsByQueryWithPagingResponse<T>>;
    /**
     * Get MD objects from using2 resource. Include only objects of given types
     * and take care about fetching only nearest objects if requested.
     *
     * @method getObjectUsing
     * @param {String} projectId id of the project
     * @param {String} uri uri of the object for which dependencies are to be found
     * @param {Object} options objects with options:
     *        - types {Array} array of strings with object types to be included
     *        - nearest {Boolean} whether to include only nearest dependencies
     * @return {Promise} promise promise once resolved returns an array of
     *         entries returned by using2 resource
     */
    getObjectUsing(projectId: string, uri: string, options?: IGetObjectUsingOptions): Promise<GdcMetadata.IObjectLink[]>;
    /**
     * Get MD objects from using2 resource. Include only objects of given types
     * and take care about fetching only nearest objects if requested.
     *
     * @method getObjectUsingMany
     * @param {String} projectId id of the project
     * @param {Array} uris uris of objects for which dependencies are to be found
     * @param {Object} options objects with options:
     *        - types {Array} array of strings with object types to be included
     *        - nearest {Boolean} whether to include only nearest dependencies
     * @return {Promise} promise promise once resolved returns an array of
     *         entries returned by using2 resource
     */
    getObjectUsingMany(projectId: string, uris: string[], options?: IGetObjectUsingOptions): Promise<GdcMetadata.IGetObjectUsingManyEntry[]>;
    /**
     * Get MD objects from usedby2 resource. Include only objects of given types
     * and take care about fetching only nearest objects if requested.
     *
     * @method getObjectUsedBy
     * @param {String} projectId id of the project
     * @param {String} uri uri of the object for which dependencies are to be found
     * @param {Object} options objects with options:
     *        - types {Array} array of strings with object types to be included
     *        - nearest {Boolean} whether to include only nearest dependencies (default is false)
     * @return {Promise} promise promise once resolved returns an array of
     *         entries returned by usedby2 resource
     */
    getObjectUsedBy(projectId: string, uri: string, options: {
        types: GdcMetadata.ObjectCategory[];
        nearest: boolean;
    }): Promise<GdcMetadata.IObjectLink[]>;
    /**
     * Get MD objects from usedby2 resource. Include only objects of given types
     * and take care about fetching only nearest objects if requested.
     *
     * @method getObjectsUsedByMany
     * @param {String} projectId id of the project
     * @param {Array} uris uris of objects for which dependencies are to be found
     * @param {Object} options objects with options:
     *        - types {Array} array of strings with object types to be included
     *        - nearest {Boolean} whether to include only nearest dependencies (default is false)
     * @return {Promise} promise promise once resolved returns an array of
     *         entries returned by usedby2 resource
     */
    getObjectsUsedByMany(projectId: string, uris: string[], options: {
        types: GdcMetadata.ObjectCategory[];
        nearest: boolean;
    }): Promise<GdcMetadata.IGetObjectsUsedByManyEntry[]>;
    /**
     * Returns all visualizationObjects metadata in a project specified by projectId param
     *
     * @method getVisualizations
     * @param {string} projectId Project identifier
     * @return {Array} An array of visualization objects metadata
     */
    getVisualizations(projectId: string): Promise<any>;
    /**
     * Returns all attributes in a project specified by projectId param
     *
     * @method getAttributes
     * @param {string} projectId Project identifier
     * @return {Array} An array of attribute objects
     */
    getAttributes(projectId: string): Promise<any>;
    /**
     * Returns all dimensions in a project specified by projectId param
     *
     * @method getDimensions
     * @param {string} projectId Project identifier
     * @return {Array} An array of dimension objects
     * @see getFolders
     */
    getDimensions(projectId: string): Promise<any>;
    /**
     * Returns project folders. Folders can be of specific types and you can specify
     * the type you need by passing and optional `type` parameter
     *
     * @method getFolders
     * @param {String} projectId - Project identifier
     * @param {String} type - Optional, possible values are `metric`, `fact`, `attribute`
     * @return {Array} An array of dimension objects
     */
    getFolders(projectId: string, type: string): Promise<any>;
    /**
     * Returns all facts in a project specified by the given projectId
     *
     * @method getFacts
     * @param {string} projectId Project identifier
     * @return {Array} An array of fact objects
     */
    getFacts(projectId: string): Promise<any>;
    /**
     * Returns all metrics in a project specified by the given projectId
     *
     * @method getMetrics
     * @param {string} projectId Project identifier
     * @return {Array} An array of metric objects
     */
    getMetrics(projectId: string): Promise<any>;
    /**
     * Returns all project dashboards (pixel perfect dashboards) in a project specified by the given projectId
     *
     * @method getProjectDashboards
     * @param {string} projectId Project identifier
     * @return {Array} An array of project dashboard objects
     */
    getProjectDashboards(projectId: string): Promise<GdcProjectDashboard.IWrappedProjectDashboard[]>;
    /**
     * Returns all analytical dashboards (kpi dashboards) in a project specified by the given projectId
     *
     * @method getAnalyticalDashboards
     * @param {string} projectId Project identifier
     * @return {Array} An array of links to analytical dashboard objects
     */
    getAnalyticalDashboards(projectId: string): Promise<GdcMetadata.IObjectLink[]>;
    /**
     * Returns all dashboard plugins in a project specified by the given projectId
     *
     * @method getDashboardPlugins
     * @param {string} projectId Project identifier
     * @return {Array} An array of links to dashboard plugin objects
     */
    getDashboardPlugins(projectId: string): Promise<GdcMetadata.IObjectLink[]>;
    /**
     * Returns all metrics that are reachable (with respect to ldm of the project
     * specified by the given projectId) for given attributes
     *
     * @method getAvailableMetrics
     * @param {String} projectId - Project identifier
     * @param {Array} attrs - An array of attribute uris for which we want to get
     * available metrics
     * @return {Array} An array of reachable metrics for the given attrs
     * @see getAvailableAttributes
     * @see getAvailableFacts
     */
    getAvailableMetrics(projectId: string, attrs?: string[]): Promise<any>;
    /**
     * Returns all attributes that are reachable (with respect to ldm of the project
     * specified by the given projectId) for given metrics (also called as drillCrossPath)
     *
     * @method getAvailableAttributes
     * @param {String} projectId - Project identifier
     * @param {Array} metrics - An array of metric uris for which we want to get
     * available attributes
     * @return {Array} An array of reachable attributes for the given metrics
     * @see getAvailableMetrics
     * @see getAvailableFacts
     */
    getAvailableAttributes(projectId: string, metrics?: string[]): Promise<any>;
    /**
     * Returns all attributes that are reachable (with respect to ldm of the project
     * specified by the given projectId) for given metrics (also called as drillCrossPath)
     *
     * @method getAvailableFacts
     * @param {String} projectId - Project identifier
     * @param {Array} items - An array of metric or attribute uris for which we want to get
     * available facts
     * @return {Array} An array of reachable facts for the given items
     * @see getAvailableAttributes
     * @see getAvailableMetrics
     */
    getAvailableFacts(projectId: string, items?: string[]): Promise<any>;
    /**
     * Get details of a metadata object specified by its uri
     *
     * @method getObjectDetails
     * @param uri uri of the metadata object for which details are to be retrieved
     * @return {Object} object details
     */
    getObjectDetails<T = any>(uri: string): Promise<T>;
    /**
     * Get folders with items.
     * Returns array of folders, each having a title and items property which is an array of
     * corresponding items. Each item is either a metric or attribute, keeping its original
     * verbose structure.
     *
     * @method getFoldersWithItems
     * @param {String} type type of folders to return
     * @return {Array} Array of folder object, each containing title and
     * corresponding items.
     */
    getFoldersWithItems(projectId: string, type: string): Promise<any>;
    /**
     * Get identifier of a metadata object identified by its uri
     *
     * @method getObjectIdentifier
     * @param uri uri of the metadata object for which the identifier is to be retrieved
     * @return {String} object identifier
     */
    getObjectIdentifier(uri: string): Promise<string>;
    /**
     * Get uri of an metadata object, specified by its identifier and project id it belongs to
     *
     * @method getObjectUri
     * @param {string} projectId id of the project
     * @param identifier identifier of the metadata object
     * @return {String} uri of the metadata object
     */
    getObjectUri(projectId: string, identifier: string): Promise<string>;
    /**
     * Get uris specified by identifiers
     *
     * @method getUrisFromIdentifiers
     * @param {String} projectId id of the project
     * @param {Array} identifiers identifiers of the metadata objects
     * @return {Array} array of identifier + uri pairs
     */
    getUrisFromIdentifiers(projectId: string, identifiers: string[]): Promise<IUriIdentifierPair[]>;
    /**
     * Get identifiers specified by uris
     *
     * @method getIdentifiersFromUris
     * @param {String} projectId id of the project
     * @param {Array} uris of the metadata objects
     * @return {Array} array of identifier + uri pairs
     */
    getIdentifiersFromUris(projectId: string, uris: string[]): Promise<IUriIdentifierPair[]>;
    /**
     * Get attribute elements with their labels and uris.
     *
     * @param {String} projectId id of the project
     * @param {String} labelUri uri of the label (display form)
     * @param {Array<String>} patterns elements labels/titles (for EXACT mode), or patterns (for WILD mode)
     * @param {('EXACT'|'WILD')} mode match mode, currently only EXACT supported
     * @return {Array} array of elementLabelUri objects
     */
    translateElementLabelsToUris(projectId: string, labelUri: string, patterns: string[], mode?: string): Promise<any>;
    /**
     * Get valid elements of an attribute, specified by its identifier and project id it belongs to
     *
     * @method getValidElements
     * @param {string} projectId id of the project
     * @param id display form id of the metadata object
     * @param {Object} options objects with options:
     *      - limit {Number}
     *      - offset {Number}
     *      - order {String} 'asc' or 'desc'
     *      - filter {String}
     *      - prompt {String}
     *      - uris {Array}
     *      - complement {Boolean}
     *      - includeTotalCountWithoutFilters {Boolean}
     *      - restrictiveDefinition {String}
     *      - afm {Object}
     * @return {Object} ValidElements response with:
     *      - items {Array} elements
     *      - paging {Object}
     *      - elementsMeta {Object}
     */
    getValidElements(projectId: string, id: string, options?: GdcMetadata.IValidElementsParams): Promise<GdcMetadata.IValidElementsResponse>;
    /**
     * Get visualization by Uri and process data
     *
     * @method getVisualization
     * @param {String} visualizationUri
     */
    getVisualization(uri: string): Promise<GdcVisualizationObject.IVisualization>;
    /**
     * Save visualization
     *
     * @method saveVisualization
     * @param {String} visualizationUri
     */
    saveVisualization(projectId: string, visualization: GdcVisualizationObject.IVisualization): Promise<{
        visualizationObject: GdcVisualizationObject.IVisualizationObject;
    }>;
    /**
     * Update visualization
     *
     * @method updateVisualization
     * @param {String} visualizationUri
     */
    updateVisualization(projectId: string, visualizationUri: string, visualization: GdcVisualizationObject.IVisualization): Promise<{
        uri: string;
    }>;
    /**
     * Delete visualization
     *
     * @method deleteVisualization
     * @param {String} visualizationUri
     */
    deleteVisualization(visualizationUri: string): Promise<ApiResponse<any>>;
    /**
     * Delete object
     *
     * @experimental
     * @method deleteObject
     * @param {String} uri of the object to be deleted
     */
    deleteObject(uri: string): Promise<ApiResponse<any>>;
    /**
     * Bulk delete objects
     */
    bulkDeleteObjects(projectId: string, uris: string[], mode?: "cascade" | "multi"): Promise<void>;
    /**
     * Create object
     *
     * @experimental
     * @method createObject
     * @param {String} projectId
     * @param {String} obj object definition
     */
    createObject<T extends GdcMetadataObject.WrappedObject = GdcMetadataObject.WrappedObject>(projectId: string, obj: T): Promise<T>;
    /**
     * Update object
     *
     * @experimental
     * @method updateObject
     * @param {String} projectId
     * @param {String} objectId
     * @param {String} obj object definition
     */
    updateObject(projectId: string, objectId: string, obj: any): Promise<any>;
    /**
     * Converts the visualization object to legacy report.
     * @param {String} projectId
     * @param mdObject visualization object to convert
     * @return uri to the converted report
     */
    openVisualizationAsReport(projectId: string, mdObject: GdcVisualizationObject.IVisualization): Promise<string>;
    /**
     * LDM manage
     *
     * @experimental
     * @method ldmManage
     * @param {String} projectId
     * @param {String} maql
     * @param {Object} options for polling (maxAttempts, pollStep)
     */
    ldmManage(projectId: string, maql: string, options?: {}): Promise<any>;
    /**
     * ETL pull
     *
     * @experimental
     * @method etlPull
     * @param {String} projectId
     * @param {String} uploadsDir
     * @param {Object} options for polling (maxAttempts, pollStep)
     */
    etlPull(projectId: string, uploadsDir: string, options?: {}): Promise<any>;
    private isTaskFinished;
    private checkStatusForError;
}
