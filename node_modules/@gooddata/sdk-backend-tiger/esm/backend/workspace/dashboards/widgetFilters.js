// (C) 2020-2021 GoodData Corporation
import { __awaiter, __generator, __spreadArrays } from "tslib";
import { dashboardFilterReferenceObjRef } from "@gooddata/sdk-backend-spi";
import { filterObjRef, isAllTimeDateFilter, isAttributeFilter, isDateFilter, } from "@gooddata/sdk-model";
import last from "lodash/last";
import zip from "lodash/zip";
/**
 * Performs widget filter resolution:
 * - removes all attribute filters hit by ignoreDashboardFilters
 * - removes all date filters for date dimension different than dateDataSet
 * - picks the last date filter for the dateDataSet dimension
 *   - if it is all time, removes all date filters
 *   - otherwise returns the last date filter specified
 *
 * @param widget - widget to resolve filters for
 * @param filters - filters to try
 * @param normalizeIds - function providing normalization of any ObjRef to identifier
 * @internal
 */
export function resolveWidgetFilters(filters, ignoreDashboardFilters, dateDataSet, normalizeIds) {
    return __awaiter(this, void 0, void 0, function () {
        var dateFilters, attributeFilters, isIgnorableFilter, _a, dateFiltersToKeep, attributeFiltersToKeep, filtersToKeep;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    dateFilters = filters.filter(isDateFilter);
                    attributeFilters = filters.filter(isAttributeFilter);
                    isIgnorableFilter = function (obj) {
                        return isDateFilter(obj) || isAttributeFilter(obj);
                    };
                    if (!dateFilters.length && !attributeFilters.length) {
                        return [2 /*return*/, filters];
                    }
                    return [4 /*yield*/, Promise.all([
                            getRelevantDateFiltersForWidget(dateFilters, dateDataSet, normalizeIds),
                            getRelevantAttributeFiltersForWidget(attributeFilters, ignoreDashboardFilters, normalizeIds),
                        ])];
                case 1:
                    _a = _b.sent(), dateFiltersToKeep = _a[0], attributeFiltersToKeep = _a[1];
                    filtersToKeep = __spreadArrays(dateFiltersToKeep, attributeFiltersToKeep);
                    // filter the original filter array to maintain order of the items
                    return [2 /*return*/, filters.filter(function (filter) { return !isIgnorableFilter(filter) || filtersToKeep.includes(filter); })];
            }
        });
    });
}
function getRelevantDateFiltersForWidget(filters, dateDataSet, normalizeIds) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, dateDatasetId, filterIds, withRelevantDimension, candidate;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!dateDataSet || !filters.length || filters.every(isAllTimeDateFilter)) {
                        return [2 /*return*/, []];
                    }
                    return [4 /*yield*/, normalizeIds(__spreadArrays([
                            dateDataSet
                        ], filters.map(function (filter) { return filterObjRef(filter); })))];
                case 1:
                    _a = _b.sent(), dateDatasetId = _a[0], filterIds = _a.slice(1);
                    withRelevantDimension = zip(filters, filterIds)
                        .filter(function (_a) {
                        var id = _a[1];
                        return dateDatasetId === id;
                    })
                        .map(function (_a) {
                        var filter = _a[0];
                        return filter;
                    });
                    candidate = last(withRelevantDimension);
                    return [2 /*return*/, !candidate || isAllTimeDateFilter(candidate) ? [] : [candidate]];
            }
        });
    });
}
function getRelevantAttributeFiltersForWidget(filters, ignoreDashboardFilters, normalizeIds) {
    return __awaiter(this, void 0, void 0, function () {
        var ids, divide, ignoredIds, filterIds;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!ignoreDashboardFilters.length) {
                        return [2 /*return*/, filters];
                    }
                    if (!filters.length) {
                        return [2 /*return*/, []];
                    }
                    return [4 /*yield*/, normalizeIds(__spreadArrays(ignoreDashboardFilters.map(dashboardFilterReferenceObjRef), filters.map(function (filter) { return filterObjRef(filter); })))];
                case 1:
                    ids = _a.sent();
                    divide = ignoreDashboardFilters.length;
                    ignoredIds = ids.slice(0, divide);
                    filterIds = ids.slice(divide);
                    return [2 /*return*/, zip(filters, filterIds)
                            .filter(function (_a) {
                            var id = _a[1];
                            return !ignoredIds.includes(id);
                        })
                            .map(function (_a) {
                            var filter = _a[0];
                            return filter;
                        })];
            }
        });
    });
}
//# sourceMappingURL=widgetFilters.js.map