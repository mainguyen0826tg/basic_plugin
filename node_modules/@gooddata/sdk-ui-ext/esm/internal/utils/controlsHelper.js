import { __assign } from "tslib";
// (C) 2019-2020 GoodData Corporation
import set from "lodash/set";
import { getTranslation } from "./translations";
function fixEmptyMaxValue(value) {
    return value === "" ? Number.MAX_SAFE_INTEGER : Number(value);
}
function fixEmptyMinValue(value) {
    return value === "" ? Number.MIN_SAFE_INTEGER : Number(value);
}
function isValueMinusOrEmpty(value) {
    return value === "-" || value === "";
}
function isInvalidOrMinMaxError(value, minNumberValue, maxNumberValue) {
    var valueIsMinus = value === "-";
    var maxMinNumbers = !isNaN(minNumberValue) && !isNaN(maxNumberValue);
    return valueIsMinus || !maxMinNumbers || minNumberValue > maxNumberValue;
}
export function maxInputValidateAndPushData(data, state, props, setState, defaultState) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var basePath = props.basePath;
    var maxValue = (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data.properties) === null || _a === void 0 ? void 0 : _a.controls) === null || _b === void 0 ? void 0 : _b[basePath]) === null || _c === void 0 ? void 0 : _c.max;
    var incorrectMinValue = (_e = (_d = state === null || state === void 0 ? void 0 : state.minScale) === null || _d === void 0 ? void 0 : _d.incorrectValue) !== null && _e !== void 0 ? _e : "";
    var correctMinValue = (_j = (_h = (_g = (_f = props === null || props === void 0 ? void 0 : props.properties) === null || _f === void 0 ? void 0 : _f.controls) === null || _g === void 0 ? void 0 : _g[basePath]) === null || _h === void 0 ? void 0 : _h.min) !== null && _j !== void 0 ? _j : "";
    var incorrectMinInvalid = isValueMinusOrEmpty(incorrectMinValue);
    var minNumberValue = incorrectMinInvalid
        ? fixEmptyMinValue(correctMinValue)
        : Number(incorrectMinValue);
    var maxNumberValue = fixEmptyMaxValue(maxValue);
    var maxIsMinus = maxValue === "-";
    var propertiesMeta = props.propertiesMeta, pushData = props.pushData;
    set(propertiesMeta, "undoApplied", false);
    // dash, non-numeric or min/max mismatch: set error
    if (isInvalidOrMinMaxError(maxValue, minNumberValue, maxNumberValue)) {
        setState({
            minScale: __assign(__assign({}, state.minScale), { hasWarning: incorrectMinValue === "-" }),
            maxScale: {
                hasWarning: true,
                // no error message for dash
                warningMessage: maxIsMinus ? "" : getTranslation("properties.axis.max.warning", props.intl),
                incorrectValue: maxValue,
            },
        });
        pushData({ propertiesMeta: propertiesMeta }); // post undoApplied flag to AD
        return;
    }
    // valid, set new value
    var properties = props.properties;
    set(properties, "controls." + basePath + ".max", maxValue);
    // if incorrect value was set previously but now validation passed, set incorrect value as correct value
    if (isNaN(parseFloat(incorrectMinValue))) {
        setState({
            maxScale: defaultState.maxScale,
        });
    }
    else {
        set(properties, "controls." + basePath + ".min", incorrectMinValue);
        setState(defaultState);
    }
    pushData({ properties: properties, propertiesMeta: propertiesMeta });
}
export function minInputValidateAndPushData(data, state, props, setState, defaultState) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    var basePath = props.basePath;
    var minValue = (_c = (_b = (_a = data === null || data === void 0 ? void 0 : data.properties) === null || _a === void 0 ? void 0 : _a.controls) === null || _b === void 0 ? void 0 : _b[basePath]) === null || _c === void 0 ? void 0 : _c.min;
    var incorrectMaxValue = (_e = (_d = state === null || state === void 0 ? void 0 : state.maxScale) === null || _d === void 0 ? void 0 : _d.incorrectValue) !== null && _e !== void 0 ? _e : "";
    var correctMaxValue = (_j = (_h = (_g = (_f = props === null || props === void 0 ? void 0 : props.properties) === null || _f === void 0 ? void 0 : _f.controls) === null || _g === void 0 ? void 0 : _g[basePath]) === null || _h === void 0 ? void 0 : _h.max) !== null && _j !== void 0 ? _j : "";
    var incorrectMaxInvalid = isValueMinusOrEmpty(incorrectMaxValue);
    var maxNumberValue = incorrectMaxInvalid
        ? fixEmptyMaxValue(correctMaxValue)
        : Number(incorrectMaxValue);
    var minNumberValue = fixEmptyMinValue(minValue);
    var minIsDash = minValue === "-";
    var propertiesMeta = props.propertiesMeta, pushData = props.pushData;
    set(propertiesMeta, "undoApplied", false);
    // dash, non-numeric or min/max mismatch: set error
    if (isInvalidOrMinMaxError(minValue, minNumberValue, maxNumberValue)) {
        setState({
            maxScale: __assign(__assign({}, state.maxScale), { hasWarning: incorrectMaxValue === "-" }),
            minScale: {
                hasWarning: true,
                // no error message for dash
                warningMessage: minIsDash ? "" : getTranslation("properties.axis.min.warning", props.intl),
                incorrectValue: minValue,
            },
        });
        pushData({ propertiesMeta: propertiesMeta }); // post undoApplied flag to AD
        return;
    }
    // valid, set new value
    var properties = props.properties;
    set(properties, "controls." + basePath + ".min", minValue);
    // if incorrect value was set previously but now validation passed, set incorrect value as correct value
    if (isNaN(parseFloat(incorrectMaxValue))) {
        setState({
            minScale: defaultState.minScale,
        });
    }
    else {
        set(properties, "controls." + basePath + ".max", incorrectMaxValue);
        setState(defaultState);
    }
    pushData({ properties: properties, propertiesMeta: propertiesMeta });
}
//# sourceMappingURL=controlsHelper.js.map