import { __assign } from "tslib";
import { filterIsEmpty, isAbsoluteDateFilter, isAttributeFilter, isComparisonCondition, isMeasureValueFilter, isPositiveAttributeFilter, isRankingFilter, } from "@gooddata/sdk-model";
import isNil from "lodash/isNil";
import { toBearRef, toScopedBearRef } from "../ObjRefConverter";
import compact from "lodash/compact";
function convertAttributeFilter(filter) {
    /*
     * When sending either positive or negative filter and the in/notIn is empty, backend will bomb
     * with "Cannot parse MAQL expression(s): %s". Previously code was only throwing away empty negative
     * filters.
     */
    if (filterIsEmpty(filter)) {
        return null;
    }
    if (!isPositiveAttributeFilter(filter)) {
        return {
            negativeAttributeFilter: {
                displayForm: toBearRef(filter.negativeAttributeFilter.displayForm),
                notIn: filter.negativeAttributeFilter.notIn,
            },
        };
    }
    return {
        positiveAttributeFilter: {
            displayForm: toBearRef(filter.positiveAttributeFilter.displayForm),
            in: filter.positiveAttributeFilter.in,
        },
    };
}
export function convertAbsoluteDateFilter(filter) {
    var absoluteDateFilter = filter.absoluteDateFilter;
    if (absoluteDateFilter.from === undefined || absoluteDateFilter.to === undefined) {
        return null;
    }
    return {
        absoluteDateFilter: {
            dataSet: toBearRef(absoluteDateFilter.dataSet),
            from: String(absoluteDateFilter.from),
            to: String(absoluteDateFilter.to),
        },
    };
}
export function convertRelativeDateFilter(filter) {
    var relativeDateFilter = filter.relativeDateFilter;
    if (relativeDateFilter.from === undefined || !relativeDateFilter.to === undefined) {
        return null;
    }
    return {
        relativeDateFilter: {
            dataSet: toBearRef(relativeDateFilter.dataSet),
            granularity: relativeDateFilter.granularity,
            from: Number(relativeDateFilter.from),
            to: Number(relativeDateFilter.to),
        },
    };
}
// Bear supports up to 6 decimal places
var MAX_DECIMAL_PLACES = 6;
function trimNumberToSupportedPrecision(num) {
    return parseFloat(num.toFixed(MAX_DECIMAL_PLACES));
}
function trimConditionToSupportedPrecision(condition) {
    if (isComparisonCondition(condition)) {
        var nullValuesProp = !isNil(condition.comparison.treatNullValuesAs)
            ? { treatNullValuesAs: condition.comparison.treatNullValuesAs }
            : {};
        return {
            comparison: __assign({ operator: condition.comparison.operator, value: trimNumberToSupportedPrecision(condition.comparison.value) }, nullValuesProp),
        };
    }
    else {
        var nullValuesProp = !isNil(condition.range.treatNullValuesAs)
            ? { treatNullValuesAs: condition.range.treatNullValuesAs }
            : {};
        return {
            range: __assign({ operator: condition.range.operator, from: trimNumberToSupportedPrecision(condition.range.from), to: trimNumberToSupportedPrecision(condition.range.to) }, nullValuesProp),
        };
    }
}
export function convertMeasureValueFilter(filter) {
    if (filter.measureValueFilter.condition === undefined) {
        return null;
    }
    return {
        measureValueFilter: {
            measure: toScopedBearRef(filter.measureValueFilter.measure),
            condition: trimConditionToSupportedPrecision(filter.measureValueFilter.condition),
        },
    };
}
export function convertRankingFilter(filter) {
    var _a = filter.rankingFilter, measure = _a.measure, attributes = _a.attributes, operator = _a.operator, value = _a.value;
    return {
        rankingFilter: {
            measures: [toScopedBearRef(measure)],
            attributes: attributes === null || attributes === void 0 ? void 0 : attributes.map(toScopedBearRef),
            operator: operator,
            value: value,
        },
    };
}
export function convertFilter(filter) {
    if (isMeasureValueFilter(filter)) {
        return convertMeasureValueFilter(filter);
    }
    if (isRankingFilter(filter)) {
        return convertRankingFilter(filter);
    }
    return convertMeasureFilter(filter);
}
export function convertMeasureFilter(filter) {
    if (isAttributeFilter(filter)) {
        return convertAttributeFilter(filter);
    }
    else if (isAbsoluteDateFilter(filter)) {
        return convertAbsoluteDateFilter(filter);
    }
    else {
        return convertRelativeDateFilter(filter);
    }
}
export function convertFilters(filters) {
    return filters ? compact(filters.map(convertFilter)) : [];
}
//# sourceMappingURL=FilterConverter.js.map