import { __awaiter, __generator } from "tslib";
// (C) 2021 GoodData Corporation
import invariant from "ts-invariant";
import { NotSupported, } from "@gooddata/sdk-backend-spi";
import { useBackend, useCancelablePromise, useWorkspace, } from "@gooddata/sdk-ui";
import { isAttributeElementsByRef, objRefToString } from "@gooddata/sdk-model";
import { dateDatasetsDataLoaderFactory } from "../../../dataLoaders";
import { isBrokenAlertAttributeFilterInfo, } from "../../../internal";
/**
 * the amount of elements to load, this should be small enough to be efficient,
 * and large enough to always be longer than the broken alert filters display
 */
var DEFAULT_ATTRIBUTE_ELEMENT_COUNT = 20;
/**
 * @internal
 */
export function useBrokenAlertFiltersMeta(_a) {
    var _this = this;
    var backend = _a.backend, brokenAlertFilters = _a.brokenAlertFilters, workspace = _a.workspace, onCancel = _a.onCancel, onError = _a.onError, onLoading = _a.onLoading, onPending = _a.onPending, onSuccess = _a.onSuccess;
    var effectiveBackend = useBackend(backend);
    var effectiveWorkspace = useWorkspace(workspace);
    invariant(effectiveBackend, "The backend in useBrokenAlertFiltersMeta must be defined. Either pass it as a config prop or make sure there is a BackendProvider up the component tree.");
    invariant(effectiveWorkspace, "The workspace in useBrokenAlertFiltersMeta must be defined. Either pass it as a config prop or make sure there is a WorkspaceProvider up the component tree.");
    var promise = brokenAlertFilters
        ? function () { return __awaiter(_this, void 0, void 0, function () {
            var filtersToLoad, dateDatasetLoader, dateDatasetsPromise, filterDataPromise, _a, filterData, dateDatasets, attributeFiltersMeta;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        filtersToLoad = brokenAlertFilters.filter(isBrokenAlertAttributeFilterInfo);
                        dateDatasetLoader = dateDatasetsDataLoaderFactory.forWorkspace(effectiveWorkspace);
                        dateDatasetsPromise = dateDatasetLoader.getDateDatasets(effectiveBackend);
                        filterDataPromise = Promise.all(filtersToLoad.map(function (filter) { return __awaiter(_this, void 0, void 0, function () {
                            var attributeFilter, displayForm, attributesService, _a, elements, displayFormData;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        attributeFilter = filter.alertFilter.attributeFilter;
                                        if (!isAttributeElementsByRef(attributeFilter.attributeElements)) {
                                            throw new NotSupported("Only URI attribute filters are supported in useBrokenAlertFiltersMeta");
                                        }
                                        displayForm = attributeFilter.displayForm;
                                        attributesService = effectiveBackend.workspace(effectiveWorkspace).attributes();
                                        return [4 /*yield*/, Promise.all([
                                                attributesService
                                                    .elements()
                                                    .forDisplayForm(displayForm)
                                                    .withLimit(DEFAULT_ATTRIBUTE_ELEMENT_COUNT)
                                                    .withOptions({
                                                    uris: attributeFilter.negativeSelection
                                                        ? undefined // for negative filters we need to load the items NOT selected, however there is no way of doing that, so we load everything
                                                        : attributeFilter.attributeElements.uris,
                                                    includeTotalCountWithoutFilters: true,
                                                })
                                                    .query(),
                                                attributesService.getAttributeDisplayForm(displayForm),
                                            ])];
                                    case 1:
                                        _a = _b.sent(), elements = _a[0], displayFormData = _a[1];
                                        return [2 /*return*/, {
                                                elements: elements,
                                                displayForm: displayForm,
                                                title: displayFormData.title,
                                            }];
                                }
                            });
                        }); }));
                        return [4 /*yield*/, Promise.all([filterDataPromise, dateDatasetsPromise])];
                    case 1:
                        _a = _b.sent(), filterData = _a[0], dateDatasets = _a[1];
                        attributeFiltersMeta = filterData.reduce(function (acc, curr) {
                            acc[objRefToString(curr.displayForm)] = {
                                title: curr.title,
                                totalElementsCount: curr.elements.totalCount,
                                validElements: curr.elements.items,
                            };
                            return acc;
                        }, {});
                        return [2 /*return*/, {
                                attributeFiltersMeta: attributeFiltersMeta,
                                dateDatasets: dateDatasets.map(function (ds) { return ds.dataSet; }),
                            }];
                }
            });
        }); }
        : null;
    return useCancelablePromise({ promise: promise, onCancel: onCancel, onError: onError, onLoading: onLoading, onPending: onPending, onSuccess: onSuccess }, [
        effectiveBackend,
        effectiveWorkspace,
        brokenAlertFilters,
    ]);
}
//# sourceMappingURL=useBrokenAlertFiltersMeta.js.map