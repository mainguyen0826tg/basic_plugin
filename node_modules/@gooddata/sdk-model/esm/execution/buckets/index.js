import { __assign } from "tslib";
// (C) 2019-2021 GoodData Corporation
import isEmpty from "lodash/isEmpty";
import { anyAttribute, attributeIdentifier, idMatchAttribute, isAttribute, } from "../attribute";
import { anyMeasure, idMatchMeasure, isMeasure, isSimpleMeasure, measureIdentifier, } from "../measure";
import { isTotal } from "../base/totals";
import invariant from "ts-invariant";
import { modifySimpleMeasure } from "../measure/factory";
import isArray from "lodash/isArray";
import identity from "lodash/identity";
import findIndex from "lodash/findIndex";
import intersection from "lodash/intersection";
import stringify from "json-stable-stringify";
/**
 * This predicate evaluates true for any bucket.
 *
 * @public
 */
export var anyBucket = function (_) { return true; };
/**
 * Factory function for predicates that will evaluate true if bucket's id is same as the provided id.
 *
 * @public
 */
export var idMatchBucket = function (id) { return function (bucket) {
    return bucket.localIdentifier === id;
}; };
//
// Type guards
//
/**
 * Type-guard testing whether the provided object is an instance of {@link IBucket}.
 *
 * @param obj - object to test
 * @public
 */
export function isBucket(obj) {
    return (!isEmpty(obj) &&
        obj.localIdentifier !== undefined &&
        obj.items !== undefined);
}
//
// Functions
//
var AGGREGATION_KEYS = ["Sum", "Count", "Avg", "Min", "Max", "Median", "Runsum"];
function getIdentifier(obj) {
    if (isMeasure(obj)) {
        return measureIdentifier(obj);
    }
    if (isAttribute(obj)) {
        return attributeIdentifier(obj);
    }
    return undefined;
}
function getAttributeDisplayFormIdentifiers(obj) {
    var _a;
    var result = [];
    for (var _i = 0, _b = Object.keys(obj); _i < _b.length; _i++) {
        var objKey = _b[_i];
        var identifier = getIdentifier(obj[objKey]);
        if (identifier) {
            result.push((_a = {},
                _a[objKey] = identifier,
                _a));
        }
    }
    return result;
}
/**
 * Creates a new bucket with the provided id and all the specified content.
 *
 * @param localId - bucket identifier
 * @param content - items to put into the bucket; attributes, measures and/or totals
 * @returns always new instance
 * @public
 */
export function newBucket(localId) {
    var content = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        content[_i - 1] = arguments[_i];
    }
    invariant(localId, "local identifier must be specified");
    var items = [];
    var totals = [];
    (content ? content : []).forEach(function (i) {
        if (!i) {
            return;
        }
        var contentErrorMessage = "Contents of a bucket must be either attribute, measure or total.";
        if (isAttribute(i) || isMeasure(i)) {
            items.push(i);
        }
        else if (isTotal(i)) {
            totals.push(i);
        }
        else if (isArray(i)) {
            invariant(false, "newBucket called with an array of length " + i.length + " as one of the items for bucket " + localId + "." +
                "Please make sure that you are not trying to put an array of items into a bucket that only accepts single item.");
        }
        else if (typeof i === "object") {
            if (Object.keys(i).indexOf("Default") > -1) {
                var identifiers = getAttributeDisplayFormIdentifiers(i).map(function (identifier) {
                    var k = Object.keys(identifier)[0];
                    var value = identifier[k];
                    return k + ": " + value;
                });
                invariant(false, contentErrorMessage + " It looks like you used an attribute from generated metadata containing more than one display form. Use one of the following display forms instead: " + identifiers.join(", ") + ".");
            }
            var keys = intersection(AGGREGATION_KEYS, Object.keys(i));
            if (!isEmpty(keys)) {
                var identifier = getIdentifier(i[keys[0]]);
                invariant(false, contentErrorMessage + " It looks like you used an object " + identifier + " from generated metadata. You need to use one of the following aggregation functions instead: " + keys.join(", ") + ".");
            }
            invariant(false, contentErrorMessage + " Got unknown content object: " + stringify(i) + ".");
        }
        else {
            invariant(false, contentErrorMessage + " Got unsupported content of type " + typeof i + ": " + i + ".");
        }
    });
    var totalsProp = !isEmpty(totals) ? { totals: totals } : {};
    return __assign({ localIdentifier: localId, items: items }, totalsProp);
}
/**
 * Tests whether the provided bucket is empty = contains no items and no totals.
 *
 * @param bucket - bucket to test
 * @returns true if empty, false if not
 * @public
 */
export function bucketIsEmpty(bucket) {
    invariant(bucket, "bucket must be specified");
    return bucket.items.length === 0 && (!bucket.totals || bucket.totals.length === 0);
}
/**
 * Gets the index of the first attribute matching the provided predicate from the bucket.
 *
 * If no predicate is provided, then the function defaults to anyAttribute predicate - meaning first found attribute
 * will be returned.
 *
 * This function also provides convenience to find attribute by its local identifier - if you pass predicate as
 * string the function will automatically create idMatchAttribute predicate.
 *
 * @param bucket - bucket to to search in
 * @param idOrFun - attribute identifier or instance of AttributePredicate; {@link anyAttribute} predicate is default
 * @returns -1 if no matching attribute is found
 * @public
 */
export function bucketAttributeIndex(bucket, idOrFun) {
    if (idOrFun === void 0) { idOrFun = anyAttribute; }
    invariant(bucket, "bucket must be specified");
    var predicate = typeof idOrFun === "string" ? idMatchAttribute(idOrFun) : idOrFun;
    var compositeGuard = function (obj) {
        return isAttribute(obj) && predicate(obj);
    };
    return findIndex(bucket.items, compositeGuard);
}
/**
 * Gets first attribute matching the provided predicate from the bucket.
 *
 * If no predicate is provided, then the function defaults to anyAttribute predicate - meaning first found attribute
 * will be returned.
 *
 * This function also provides convenience to find attribute by its local identifier - if you pass predicate as
 * string the function will automatically create idMatchAttribute predicate.
 *
 * @param bucket - bucket to to search in
 * @param idOrFun - attribute identifier or instance of AttributePredicate; {@link anyAttribute} predicate is default
 * @returns undefined if no matching attribute is found
 * @public
 */
export function bucketAttribute(bucket, idOrFun) {
    if (idOrFun === void 0) { idOrFun = anyAttribute; }
    var index = bucketAttributeIndex(bucket, idOrFun);
    return index >= 0 ? bucket.items[index] : undefined;
}
/**
 * Gets all attributes matching the provided predicate from the bucket.
 *
 * If no predicate is provided, then the function defaults to anyAttribute predicate - meaning all attributes
 * from the bucket will be returned.
 *
 * @param bucket - bucket to work with
 * @param predicate - attribute predicate; {@link anyAttribute} predicate is default
 * @returns empty list if none match
 * @public
 */
export function bucketAttributes(bucket, predicate) {
    if (predicate === void 0) { predicate = anyAttribute; }
    invariant(bucket, "bucket must be specified");
    // need custom type-guard so as not to break type inference in filter() method
    var compositeGuard = function (obj) {
        return isAttribute(obj) && predicate(obj);
    };
    return bucket.items.filter(compositeGuard);
}
/**
 * Gets the index of the first measure matching the provided predicate from the bucket.
 *
 * If no predicate is provided, then the function defaults to anyMeasure predicate - meaning first found measure
 * will be returned.
 *
 * This function also provides convenience to find measure by its local identifier - if you pass predicate as
 * string the function will automatically create idMatchMeasure predicate.
 *
 * @param bucket - bucket to to search in
 * @param idOrFun - measure identifier or instance of MeasurePredicate; {@link anyMeasure} predicate is default
 * @returns -1 if no matching measure is found
 * @public
 */
export function bucketMeasureIndex(bucket, idOrFun) {
    if (idOrFun === void 0) { idOrFun = anyMeasure; }
    invariant(bucket, "bucket must be specified");
    var predicate = typeof idOrFun === "string" ? idMatchMeasure(idOrFun) : idOrFun;
    var compositeGuard = function (obj) {
        return isMeasure(obj) && predicate(obj);
    };
    return findIndex(bucket.items, compositeGuard);
}
/**
 * Gets first measure matching the provided predicate from the bucket.
 *
 * If no predicate is provided, then the function defaults to anyMeasure predicate - meaning first found measure
 * will be returned.
 *
 * This function also provides convenience to find measure by its local identifier - if you pass predicate as
 * string the function will automatically create idMatchMeasure predicate.
 *
 * @param bucket - bucket to to search in
 * @param idOrFun - measure identifier or instance of MeasurePredicate; {@link anyMeasure} predicate is default
 * @returns undefined if no matching measure is found
 * @public
 */
export function bucketMeasure(bucket, idOrFun) {
    if (idOrFun === void 0) { idOrFun = anyMeasure; }
    var index = bucketMeasureIndex(bucket, idOrFun);
    return index >= 0 ? bucket.items[index] : undefined;
}
/**
 * Gets all measures matching the provided predicate from the bucket.
 *
 * If no predicate is provided, then the function defaults to anyMeasure predicate - meaning all measures from
 * the bucket will be returned.
 *
 * @param bucket - bucket to work with
 * @param predicate - measure predicate; {@link anyMeasure} predicate is default
 * @returns empty list if none match
 * @public
 */
export function bucketMeasures(bucket, predicate) {
    if (predicate === void 0) { predicate = anyMeasure; }
    invariant(bucket, "bucket must be specified");
    // need custom type-guard so as not to break type inference in filter() method
    var compositeGuard = function (obj) {
        return isMeasure(obj) && predicate(obj);
    };
    return bucket.items.filter(compositeGuard);
}
/**
 * Gets all attributes and measures from the bucket.
 *
 * @param bucket - bucket to work with
 * @returns empty list if no items
 * @public
 */
export function bucketItems(bucket) {
    invariant(bucket, "bucket must be specified");
    return bucket.items;
}
/**
 * Gets all totals from the bucket
 *
 * @param bucket - bucket to work with
 * @returns empty list if no totals
 * @public
 */
export function bucketTotals(bucket) {
    invariant(bucket, "bucket must be specified");
    if (!bucket.totals) {
        return [];
    }
    return bucket.totals;
}
/**
 * Gets a new bucket that 'inherits' all data from the provided bucket but has different totals. New
 * totals will be used in the new bucket as-is, no merging with existing totals.
 *
 * @param bucket - bucket to work with
 * @param totals - new totals to apply
 * @returns new bucket
 * @public
 */
export function bucketSetTotals(bucket, totals) {
    if (totals === void 0) { totals = []; }
    invariant(bucket, "bucket must be specified");
    return __assign(__assign({}, bucket), { totals: totals });
}
/**
 * Defines possible compute ratio sanitization rules.
 *
 * @public
 */
export var ComputeRatioRule;
(function (ComputeRatioRule) {
    /**
     * Compute ratio must not be used in any measure
     */
    ComputeRatioRule[ComputeRatioRule["NEVER"] = 0] = "NEVER";
    /**
     * Compute ratio can be used if there is just a single measure
     */
    ComputeRatioRule[ComputeRatioRule["SINGLE_MEASURE_ONLY"] = 1] = "SINGLE_MEASURE_ONLY";
    /**
     * Compute ratio can be used on any measure
     */
    ComputeRatioRule[ComputeRatioRule["ANY_MEASURE"] = 2] = "ANY_MEASURE";
})(ComputeRatioRule || (ComputeRatioRule = {}));
/**
 * Applies compute ratio rule to all measures in a list - this MAY be done to sanitize measure definitions
 * so that the computed results make sense when visualized in a chart.
 *
 * The function will return a new list with updated measures according to the specified rule; see {@link ComputeRatioRule}.
 *
 * For convenience this function can work with list of measures AND attributes; attributes will be ignored
 * in processing and kept in resulting array as-is.
 *
 * @param items - list of attributes or measures to sanitize; attributes will be lef
 * @param rule - rule to apply; see {@link ComputeRatioRule}
 * @returns new list with modified measures; the original list and measures in it are left intact
 * @public
 */
export function applyRatioRule(items, rule) {
    if (rule === void 0) { rule = ComputeRatioRule.SINGLE_MEASURE_ONLY; }
    invariant(items, "items must be specified");
    if (rule === ComputeRatioRule.ANY_MEASURE) {
        return items;
    }
    var numberOfMeasures = items.filter(isMeasure).length;
    if (numberOfMeasures > 1 || rule === ComputeRatioRule.NEVER) {
        return items.map(disableComputeRatio);
    }
    return items;
}
/**
 * Disables compute ratio if set on a simple measure. Does not do anything for other measures.
 *
 * @param item - maybe a simple measure where compute ratio should be disabled
 * @returns an instance of measure with compute ratio disabled
 * @public
 */
export function disableComputeRatio(item) {
    if (isSimpleMeasure(item)) {
        return modifySimpleMeasure(item, function (m) { return m.noRatio(); });
    }
    return item;
}
/**
 * Creates a new bucket by modifying items of the provided input bucket.
 * Each item from the input bucket will be dispatched to the modification function
 * and the result of the modification will be included in the new bucket.
 *
 * Note: it is valid for the modification function to just return the original item.
 * In that case the item will be included in the bucket without modification.
 *
 * @param bucket - bucket in which all items are applied the modification function
 * @param modifications - the modification to apply to the bucket items
 * @returns new instance of bucket with modified bucket items
 * @public
 */
export function bucketModifyItems(bucket, modifications) {
    if (modifications === void 0) { modifications = identity; }
    invariant(bucket, "bucket must be specified");
    var items = bucketItems(bucket);
    return __assign(__assign({}, bucket), { items: items.map(function (bucketItem) { return modifications(bucketItem); }) });
}
/**
 * Creates a new bucket by modifying items of the provided input bucket.
 * Array of item from the input bucket will be dispatched to the reducer function
 * and the result of the modification will be included in the new bucket.
 *
 *
 * @param bucket - bucket in which all items are applied the modification function
 * @param reducer - the reducer function to apply to the bucket items
 * @returns new instance of bucket with modified bucket items
 * @public
 */
export function bucketItemReduce(bucket, reducer) {
    if (reducer === void 0) { reducer = identity; }
    invariant(bucket, "bucket must be specified");
    var items = bucketItems(bucket);
    var result = items.reduce(function (acc, cur, idx, src) {
        return reducer(acc, cur, idx, src);
    }, []);
    return __assign(__assign({}, bucket), { items: result });
}
//# sourceMappingURL=index.js.map