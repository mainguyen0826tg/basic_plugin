import { __generator } from "tslib";
import { idRef } from "@gooddata/sdk-model";
import { selectObjectAvailabilityConfig } from "../store/config/configSelectors";
import { call, select } from "redux-saga/effects";
/**
 * This generator function will communicate with backend to obtain the available date data sets that can be
 * used for date-filtering of the provided insight.
 *
 * The available date datasets vary based on the contents (measures, attributes) of the insight & the shape of
 * the LDM itself. Some data sets will not be available as they are unreachable given the measures/attributes
 * used in the insight.
 *
 * This generator will take into account the current object availability config.
 *
 * @param ctx - dashboard context in which the resolution should be done
 * @param insight - insight to use during availability check
 */
export function loadDateDatasetsForInsight(ctx, insight) {
    var backend, workspace, availability, catalogLoader, catalog, availableDateDataSetsLoader, loadedAvailableDateDataSets;
    var _a, _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                backend = ctx.backend, workspace = ctx.workspace;
                return [4 /*yield*/, select(selectObjectAvailabilityConfig)];
            case 1:
                availability = _c.sent();
                catalogLoader = backend.workspace(workspace).catalog().load;
                return [4 /*yield*/, call(catalogLoader)];
            case 2:
                catalog = _c.sent();
                availableDateDataSetsLoader = catalog.availableItems().withOptions({
                    types: ["dateDataset"],
                    insight: insight,
                    excludeTags: ((_a = availability.excludeObjectsWithTags) !== null && _a !== void 0 ? _a : []).map(function (tag) { return idRef(tag); }),
                    includeTags: ((_b = availability.includeObjectsWithTags) !== null && _b !== void 0 ? _b : []).map(function (tag) { return idRef(tag); }),
                }).load;
                return [4 /*yield*/, call(availableDateDataSetsLoader)];
            case 3:
                loadedAvailableDateDataSets = _c.sent();
                /*
                 * You may also remember from KD that the code was cleaning up the relevance values from the available date
                 * datasets. This was there to carefully align data to get feasible results from the `getRecommendedDateDataset`
                 */
                return [2 /*return*/, loadedAvailableDateDataSets.availableDateDatasets()];
        }
    });
}
//# sourceMappingURL=loadAvailableDateDatasets.js.map