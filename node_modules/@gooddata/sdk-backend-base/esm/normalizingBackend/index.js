// (C) 2007-2021 GoodData Corporation
import { __awaiter, __extends, __generator } from "tslib";
import { NotSupported, isNoDataError, NoDataError, } from "@gooddata/sdk-backend-spi";
import { decoratedBackend } from "../decoratedBackend";
import { DecoratedExecutionFactory, DecoratedPreparedExecution } from "../decoratedBackend/execution";
import { defFingerprint } from "@gooddata/sdk-model";
import { Denormalizer, Normalizer } from "./normalizer";
import cloneDeep from "lodash/cloneDeep";
var WithNormalizationExecutionFactory = /** @class */ (function (_super) {
    __extends(WithNormalizationExecutionFactory, _super);
    function WithNormalizationExecutionFactory(decorated, config) {
        var _this = _super.call(this, decorated) || this;
        _this.config = config;
        _this.wrap = function (original) {
            return new NormalizingPreparedExecution(original, _this.decorated, _this.config);
        };
        return _this;
    }
    WithNormalizationExecutionFactory.prototype.forInsightByRef = function (insight, filters) {
        var isFallbackAllowed = this.config.executeByRefMode === "fallback";
        if (isFallbackAllowed) {
            return this.forInsight(insight, filters);
        }
        throw new NotSupported("Execution by reference is not supported when using normalizing backend. " +
            "Use forInsight() instead.");
    };
    return WithNormalizationExecutionFactory;
}(DecoratedExecutionFactory));
/**
 * Prepared execution which does normalization. The prepared execution works with the original
 * exec definition all the time. All operations are done on top of it - except for the execution itself.
 *
 * Once the execute() is called, the prepared execution will perform normalization and will prepare execution
 * for the normalized definition. It uses the original, non-normalizing exec factory for this.
 *
 * It thus obtains the normalized execution and starts it, obtaining the normalized result.
 */
var NormalizingPreparedExecution = /** @class */ (function (_super) {
    __extends(NormalizingPreparedExecution, _super);
    function NormalizingPreparedExecution(decorated, originalExecutionFactory, config) {
        var _this = _super.call(this, decorated) || this;
        _this.originalExecutionFactory = originalExecutionFactory;
        _this.config = config;
        _this.execute = function () {
            var _a, _b;
            var normalizationState = Normalizer.normalize(_this.definition);
            var normalizedExecution = _this.originalExecutionFactory.forDefinition(normalizationState.normalized);
            (_b = (_a = _this.config).normalizationStatus) === null || _b === void 0 ? void 0 : _b.call(_a, normalizationState);
            return normalizedExecution.execute().then(function (result) {
                return new DenormalizingExecutionResult(result, normalizationState, _this, _this.decorated);
            });
        };
        _this.createNew = function (decorated) {
            return new NormalizingPreparedExecution(decorated, _this.originalExecutionFactory, _this.config);
        };
        return _this;
    }
    return NormalizingPreparedExecution;
}(DecoratedPreparedExecution));
/**
 * An implementation of de-normalizing execution result.
 *
 * It receives the result of normalized execution + normalization metadata, and at
 * construction time sets up the results definition to be the original definition, and
 * then de-normalizes the dimension headers so that they match the original definition.
 *
 * The result instance receives also receives the normalizing execution which triggered creation of
 * the result -> this is so that when client calls transform(), they can get back to further customizing the
 * execution.
 *
 * The result instance receives also the original, non-normalizing prepared execution -> this is needed
 * because of export(). Exports are a server side thing that must be done for the original execution - because
 * the normalization process normally takes away the essential detail that is importat in the exports - such as
 * titles, formats and so on. See the export() implementation - this actually performs the original execution
 * and exports result from it.
 */
var DenormalizingExecutionResult = /** @class */ (function () {
    function DenormalizingExecutionResult(normalizedResult, normalizationState, normalizingExecution, originalExecution) {
        var _this = this;
        this.normalizedResult = normalizedResult;
        this.normalizationState = normalizationState;
        this.normalizingExecution = normalizingExecution;
        this.originalExecution = originalExecution;
        this.transform = function () {
            return _this.normalizingExecution;
        };
        this.export = function (options) { return __awaiter(_this, void 0, void 0, function () {
            var originalResult;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.originalExecution.execute()];
                    case 1:
                        originalResult = _a.sent();
                        return [2 /*return*/, originalResult.export(options)];
                }
            });
        }); };
        this.readAll = function () {
            var promisedDataView = _this.normalizedResult.readAll();
            return promisedDataView
                .then(function (dataView) {
                return new DenormalizedDataView(_this, dataView, _this.denormalizer);
            })
                .catch(_this.handleDataViewError);
        };
        this.readWindow = function (offset, size) {
            var promisedDataView = _this.normalizedResult.readWindow(offset, size);
            return promisedDataView
                .then(function (dataView) {
                return new DenormalizedDataView(_this, dataView, _this.denormalizer);
            })
                .catch(_this.handleDataViewError);
        };
        this.equals = function (other) {
            return _this._fingerprint === other.fingerprint();
        };
        this.fingerprint = function () {
            return _this._fingerprint;
        };
        this.handleDataViewError = function (error) {
            // make sure that errors with dataViews are repackaged with the dataView denormalized as well
            // otherwise the dataViews will not make sense to the caller
            if (isNoDataError(error) && error.dataView) {
                throw new NoDataError(error.message, new DenormalizedDataView(_this, error.dataView, _this.denormalizer));
            }
            throw error;
        };
        this.denormalizer = Denormalizer.from(normalizationState);
        this.definition = this.normalizationState.original;
        this.dimensions = this.denormalizer.denormalizeDimDescriptors(normalizedResult.dimensions);
        this._fingerprint = "normalizedResult_" + defFingerprint(this.definition);
    }
    return DenormalizingExecutionResult;
}());
/**
 * Denormalized DataView takes mostly copies of the contents of the normalized data view. The only exception is the
 * header items. The measure headers included therein may have normalized, incorrect measure names (defaulted by
 * backend to localId).
 */
var DenormalizedDataView = /** @class */ (function () {
    function DenormalizedDataView(result, normalizedDataView, denormalizer) {
        var _this = this;
        this.normalizedDataView = normalizedDataView;
        this.equals = function (other) {
            return _this._fingerprint === other.fingerprint();
        };
        this.fingerprint = function () {
            return _this._fingerprint;
        };
        this.result = result;
        this.definition = this.result.definition;
        this.count = cloneDeep(this.normalizedDataView.count);
        this.data = cloneDeep(this.normalizedDataView.data);
        this.headerItems = denormalizer.denormalizeHeaders(this.normalizedDataView.headerItems);
        this.offset = cloneDeep(this.normalizedDataView.offset);
        this.totalCount = cloneDeep(this.normalizedDataView.totalCount);
        this.totals = cloneDeep(this.normalizedDataView.totals);
        this._fingerprint = this.result.fingerprint() + "/" + this.offset.join(",") + "-" + this.count.join(",");
    }
    return DenormalizedDataView;
}());
/**
 * Decorates backend with logic which transparently normalizes execution definitions before they are dispatched
 * to the underlying backend. The normalization standardizes local identifiers and removes any fields that do not
 * impact the resulting data itself: aliases, title customizations and measure format customizations.
 *
 * All the detail that is stripped on the way to the execution APIs is restored before the results reach the
 * caller code.
 *
 * The normalization is essential to increase cache hits - be it both on client or on the server.
 *
 * @param realBackend - real backend to decorate
 * @param config - optionally specify configuration of the normalization process, see {@link NormalizationConfig}
 * @returns new instance of backend
 * @beta
 */
export function withNormalization(realBackend, config) {
    if (config === void 0) { config = {}; }
    return decoratedBackend(realBackend, {
        execution: function (original) { return new WithNormalizationExecutionFactory(original, config); },
    });
}
//# sourceMappingURL=index.js.map