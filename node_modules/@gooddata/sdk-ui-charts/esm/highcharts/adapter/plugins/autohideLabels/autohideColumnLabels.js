import { __assign } from "tslib";
// (C) 2007-2021 GoodData Corporation
import map from "lodash/map";
import zip from "lodash/zip";
import values from "lodash/values";
import flatten from "lodash/flatten";
import identity from "lodash/identity";
import isEmpty from "lodash/isEmpty";
import { getAxisRangeForAxes, getDataPointsOfVisibleSeries, getShapeAttributes, isIntersecting, isStacked, toNeighbors, } from "../../../chartTypes/_chartCreators/helpers";
import { areLabelsStacked, getDataLabelAttributes, getShapeVisiblePart, hasDataLabel, hasLabelInside, hasShape, hideDataLabel, hideDataLabels, showDataLabelInAxisRange, showStackLabelInAxisRange, } from "../../../chartTypes/_chartCreators/dataLabelsHelpers";
import { VisualizationTypes } from "@gooddata/sdk-ui";
/*
 * Code in this file accesses Highchart properties that are not included in
 * the official typings:
 *
 * -  Axis.stacking.stacks
 * -  Axis.stacking.stackTotalGroup
 * -  Series.dataLabelsGroup
 * -  Point.label
 * -  Point.dataLabel
 * -  Point.element
 * -  Point.graphic
 * -  Point.shapeArgs
 *
 * For some time, we included the 'extra' stuff in our own types (IAxisConfig). This type was in return
 * used in IChartConfig. The chart config should not be riddled with highchart internals - so that went away
 * and code here started to use Highchart types instead.
 *
 * By using the public Highchart types, the use of undocumented fields became more apparent. Instead of creating
 * types for these internals that we misuse (?), I have opted to casting as UnsafeInternals and accessing
 */
var toggleNonStackedChartLabels = function (visiblePoints, axisRangeForAxes, shouldCheckShapeIntersection) {
    if (shouldCheckShapeIntersection === void 0) { shouldCheckShapeIntersection = false; }
    var foundIntersection = toNeighbors(
    // some data labels may not be rendered (too many points)
    visiblePoints.filter(function (point) {
        return hasDataLabel(point) && hasShape(point);
    })).some(function (pointPair) {
        var _a = pointPair || [], firstPoint = _a[0], nextPoint = _a[1];
        var firstDataLabelAttr = getDataLabelAttributes(firstPoint);
        var nextDataLabelAttr = getDataLabelAttributes(nextPoint);
        if (shouldCheckShapeIntersection) {
            var firstShapeAttr = getShapeAttributes(firstPoint);
            var nextShapeAttr = getShapeAttributes(nextPoint);
            return (isIntersecting(firstDataLabelAttr, nextDataLabelAttr) ||
                isIntersecting(firstDataLabelAttr, nextShapeAttr) ||
                isIntersecting(firstShapeAttr, nextDataLabelAttr));
        }
        return isIntersecting(firstDataLabelAttr, nextDataLabelAttr);
    });
    if (foundIntersection) {
        hideDataLabels(visiblePoints);
    }
    else {
        visiblePoints.forEach(function (point) { return showDataLabelInAxisRange(point, point.y, axisRangeForAxes); });
    }
};
var toggleStackedChartLabels = function (visiblePoints, axisRangeForAxes) {
    var toggleLabel = function (point) {
        var dataLabel = point.dataLabel, shapeArgs = point.shapeArgs, chart = point.series.chart;
        if (dataLabel && shapeArgs) {
            var labelHeight = dataLabel.height + (2 * dataLabel.padding || 0);
            var shapeHeight = getShapeVisiblePart(shapeArgs, chart, shapeArgs.height);
            var isOverlappingHeight = labelHeight > shapeHeight;
            return isOverlappingHeight
                ? hideDataLabel(point)
                : // fix for HCH bug for negative stack labels
                    showStackLabelInAxisRange(point, axisRangeForAxes);
        }
        return null;
    };
    if (isOverlappingWidth(visiblePoints)) {
        hideDataLabels(visiblePoints);
    }
    else {
        visiblePoints.forEach(toggleLabel);
    }
};
export function isOverlappingWidth(visiblePoints) {
    return visiblePoints.filter(hasDataLabel).some(function (point) {
        var dataLabel = point.dataLabel, shapeArgs = point.shapeArgs;
        if (dataLabel && shapeArgs) {
            var labelWidth = dataLabel.width + 2 * dataLabel.padding;
            return labelWidth > shapeArgs.width;
        }
        return false;
    });
}
export function areNeighborsOverlapping(neighbors) {
    return neighbors.some(function (labelsPair) {
        var _a = labelsPair || [], firstLabel = _a[0], nextLabel = _a[1];
        if (!isEmpty(firstLabel) && !isEmpty(nextLabel)) {
            var firstClientRect = firstLabel.element.getBoundingClientRect();
            var nextClientRect = nextLabel.element.getBoundingClientRect();
            if (firstClientRect && nextClientRect) {
                var firstLabelRight = firstClientRect.right;
                var nextLabelLeft = nextClientRect.left;
                return firstLabelRight > nextLabelLeft;
            }
        }
        return false;
    });
}
// Check if Total label overlapping other columns
export function areLabelsOverlappingColumns(labels, visiblePoints) {
    return labels.some(function (label) {
        if (isEmpty(label)) {
            return false;
        }
        var _a = label.element.getBoundingClientRect(), x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        var labelAttr = {
            x: x,
            y: y,
            width: width,
            height: height,
        };
        return visiblePoints.some(function (point) {
            var _a, _b;
            var seriesType = (_b = (_a = point === null || point === void 0 ? void 0 : point.series) === null || _a === void 0 ? void 0 : _a.options) === null || _b === void 0 ? void 0 : _b.type;
            if (isEmpty(point) ||
                isEmpty(point.graphic) ||
                // supportedDualAxesChartTypes is including AREA and LINE
                // won't hide the stacked label if it overlaps with points of AREA and LINE
                seriesType === VisualizationTypes.AREA ||
                seriesType === VisualizationTypes.LINE) {
                return false;
            }
            var _c = point.graphic.element.getBoundingClientRect(), x = _c.x, y = _c.y, width = _c.width, height = _c.height;
            var pointAttr = {
                x: x,
                y: y,
                width: width,
                height: height,
            };
            return isIntersecting(pointAttr, labelAttr);
        });
    });
}
function findColumnKey(key) {
    return key.indexOf("column") === 0;
}
/**
 * Merge stack label points from axes to one
 * Primary axis:    [pointP1, pointP2, pointP3]
 * Secondary axis:  [pointS1, pointS2, pointS3]
 * @param stacks
 * @return [pointP1, pointS1, pointP2, pointS2, pointP3, pointS3]
 */
export function getStackLabelPointsForDualAxis(stacks) {
    return flatten(
    // 'column0' is primary axis and 'column1' is secondary axis
    zip.apply(void 0, stacks.map(function (item) {
        var columnKey = Object.keys(item).find(findColumnKey);
        return values(item[columnKey]);
    }))).filter(identity);
}
export function getStackTotalGroups(yAxis) {
    return flatten(yAxis.map(function (axis) {
        var _a, _b;
        if (!isEmpty((_a = axis) === null || _a === void 0 ? void 0 : _a.stacking.stacks)) {
            return (_b = axis) === null || _b === void 0 ? void 0 : _b.stacking.stackTotalGroup;
        }
        return axis.series.map(function (serie) { return serie.dataLabelsGroup; });
    })).filter(identity);
}
function toggleStackedLabelsForDualAxis() {
    var yAxis = this.yAxis;
    var stackTotalGroups = getStackTotalGroups(yAxis);
    var stacks = getStackItems(yAxis);
    if (stacks && stackTotalGroups) {
        var points = getStackLabelPointsForDualAxis(stacks);
        var labels = getLabelOrDataLabelForPoints(points);
        var neighbors = toNeighbors(labels);
        var neighborsOverlapping = areNeighborsOverlapping(neighbors);
        var areOverlapping_1 = neighborsOverlapping || areLabelsOverlappingColumns(labels, getDataPointsOfVisibleSeries(this));
        stackTotalGroups.forEach(function (stackTotalGroup) {
            return setVisibilityByOpacity(stackTotalGroup, !areOverlapping_1);
        });
    }
}
function toggleStackedLabelsForSingleAxis() {
    var yAxis = this.yAxis;
    var firstYAxis = yAxis[0] || {};
    var stacks = firstYAxis === null || firstYAxis === void 0 ? void 0 : firstYAxis.stacking.stacks;
    var stackTotalGroup = firstYAxis === null || firstYAxis === void 0 ? void 0 : firstYAxis.stacking.stackTotalGroup;
    if (stacks && stackTotalGroup) {
        var columnKey = Object.keys(stacks).find(findColumnKey);
        // We need to use Lodash map, because we are iterating through an object
        var labels = map(stacks[columnKey], function (point) { return point.label; });
        var neighbors = toNeighbors(labels);
        var stackTotalGroupVisible = !areNeighborsOverlapping(neighbors);
        setVisibilityByOpacity(stackTotalGroup, stackTotalGroupVisible);
    }
}
function setVisibilityByOpacity(stackTotalGroup, visible) {
    stackTotalGroup.attr({ opacity: visible ? 1 : 0 });
}
function toggleStackedLabels() {
    var yAxis = this.yAxis;
    // CL-10676 - Return if yAxis is undefined
    if (!yAxis || yAxis.length === 0) {
        return;
    }
    if (yAxis.length === 2) {
        return toggleStackedLabelsForDualAxis.call(this);
    }
    return toggleStackedLabelsForSingleAxis.call(this);
}
export var autohideColumnLabels = function (chart) {
    var isStackedChart = isStacked(chart);
    var hasLabelsStacked = areLabelsStacked(chart);
    var visiblePoints = getDataPointsOfVisibleSeries(chart);
    var axisRangeForAxes = getAxisRangeForAxes(chart);
    // stack chart labels is displayed inside column
    if (isStackedChart) {
        toggleStackedChartLabels(visiblePoints.filter(hasLabelInside), axisRangeForAxes);
    }
    else {
        toggleNonStackedChartLabels(visiblePoints, axisRangeForAxes, true);
    }
    // stack labels are total values displayed on top of columns
    if (hasLabelsStacked) {
        toggleStackedLabels.call(chart);
    }
};
export var handleColumnLabelsOutsideChart = function (chart) {
    var visiblePoints = getDataPointsOfVisibleSeries(chart);
    var axisRangeForAxes = getAxisRangeForAxes(chart);
    visiblePoints.forEach(function (point) {
        if (!isStacked(chart)) {
            showDataLabelInAxisRange(point, point.y, axisRangeForAxes);
        }
        else {
            // fix for HCH bug for negative stack labels
            showStackLabelInAxisRange(point, axisRangeForAxes);
        }
    });
};
export function getLabelOrDataLabelForPoints(points) {
    return points
        .map(function (point) {
        return point.label || point.dataLabel;
    })
        .filter(identity);
}
export function getStackItems(yAxis) {
    return flatten(yAxis.map(function (axis) {
        var _a, _b;
        if (!isEmpty((_a = axis) === null || _a === void 0 ? void 0 : _a.stacking.stacks)) {
            return (_b = axis) === null || _b === void 0 ? void 0 : _b.stacking.stacks;
        }
        var series = axis.series;
        return series.map(function (serie) {
            return {
                column: __assign({}, serie.data),
            };
        });
    }));
}
//# sourceMappingURL=autohideColumnLabels.js.map