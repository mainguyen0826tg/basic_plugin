import { __assign, __spreadArrays } from "tslib";
// (C) 2019-2021 GoodData Corporation
import set from "lodash/set";
import uniq from "lodash/uniq";
import uniqBy from "lodash/uniqBy";
import negate from "lodash/negate";
import includes from "lodash/includes";
import every from "lodash/every";
import forEach from "lodash/forEach";
import cloneDeep from "lodash/cloneDeep";
import isEmpty from "lodash/isEmpty";
import flatMap from "lodash/flatMap";
import compact from "lodash/compact";
import without from "lodash/without";
import { BucketNames, OverTimeComparisonTypes, VisualizationTypes, } from "@gooddata/sdk-ui";
import { bucketItems, bucketsFind, bucketsMeasures, insightBuckets, isSimpleMeasure, areObjRefsEqual, } from "@gooddata/sdk-model";
import { DATE_DATASET_ATTRIBUTE, } from "../interfaces/Visualization";
import { ATTRIBUTE, BUCKETS, DATE, METRIC, SHOW_ON_SECONDARY_AXIS } from "../constants/bucket";
import { getTranslation } from "./translations";
export function isDateFilter(filter) {
    return !!filter && filter.attribute === DATE_DATASET_ATTRIBUTE;
}
export function isFiltersBucketItem(filter) {
    return !!filter && filter.attribute === DATE_DATASET_ATTRIBUTE;
}
export function isAttributeFilter(filter) {
    var filterAsAttributeFilter = filter;
    return (!!filter &&
        filterAsAttributeFilter.attribute !== DATE_DATASET_ATTRIBUTE &&
        filterAsAttributeFilter.attribute !== undefined);
}
export function isMeasureValueFilter(filter) {
    return !!filter && !!filter.measureLocalIdentifier;
}
export function isActiveMeasureValueFilter(filter) {
    if (!isMeasureValueFilter(filter)) {
        return false;
    }
    return !!filter.condition;
}
export function isRankingFilter(filter) {
    var filterAsRankingFilter = filter;
    return (!!filter &&
        typeof filterAsRankingFilter.measure === "string" &&
        typeof filterAsRankingFilter.operator === "string" &&
        typeof filterAsRankingFilter.value === "number");
}
export function sanitizeFilters(newReferencePoint) {
    var attributeBucketItems = getAllAttributeItems(newReferencePoint.buckets);
    var measureBucketItems = getAllMeasureItems(newReferencePoint.buckets);
    newReferencePoint.filters = newReferencePoint.filters || {
        localIdentifier: "filters",
        items: [],
    };
    var filteredFilters = newReferencePoint.filters.items.filter(function (filterBucketItem) {
        var filter = filterBucketItem.filters[0];
        if (isAttributeFilter(filter) || isDateFilter(filter)) {
            if (filterBucketItem.autoCreated === false) {
                return true;
            }
            return attributeBucketItems.some(function (attributeBucketItem) { return attributeBucketItem.attribute === filter.attribute; });
        }
        else if (isMeasureValueFilter(filter)) {
            if (attributeBucketItems.length === 0) {
                return false;
            }
            return measureBucketItems.some(function (measureBucketItem) {
                return measureBucketItem.localIdentifier === filter.measureLocalIdentifier;
            });
        }
        else if (isRankingFilter(filter)) {
            if (attributeBucketItems.length === 0) {
                return false;
            }
            var hasValidMeasure = measureBucketItems.some(function (measureBucketItem) { return measureBucketItem.localIdentifier === filter.measure; });
            var hasValidAttributes = !filter.attributes ||
                filter.attributes.every(function (localIdentifier) {
                    return attributeBucketItems.some(function (attributeBucketItem) { return attributeBucketItem.localIdentifier === localIdentifier; });
                });
            return hasValidMeasure && hasValidAttributes;
        }
        return false;
    });
    return __assign(__assign({}, newReferencePoint), { filters: __assign(__assign({}, newReferencePoint.filters), { items: filteredFilters }) });
}
export function isDerivedBucketItem(measureItem) {
    return !!measureItem.masterLocalIdentifier;
}
function isArithmeticBucketItem(bucketItem) {
    return !!bucketItem.operandLocalIdentifiers;
}
function isDerivedOfTypeBucketItem(measureItem, derivedType) {
    if (!isDerivedBucketItem(measureItem)) {
        return false;
    }
    return measureItem.overTimeComparisonType === derivedType;
}
function findDerivedTypesReferencedByArithmeticMeasure(measure, allMeasures, visitedMeasures) {
    return measure.operandLocalIdentifiers.reduce(function (types, operandIdentifier) {
        if (operandIdentifier === null || visitedMeasures.has(operandIdentifier)) {
            return types;
        }
        var operand = findMeasureByLocalIdentifier(operandIdentifier, allMeasures);
        if (operand === undefined) {
            return types;
        }
        if (isArithmeticBucketItem(operand)) {
            visitedMeasures.add(operandIdentifier);
            findDerivedTypesReferencedByArithmeticMeasure(operand, allMeasures, visitedMeasures).forEach(function (type) { return types.add(type); });
        }
        else if (isDerivedBucketItem(operand) && !types.has(operand.overTimeComparisonType)) {
            types.add(operand.overTimeComparisonType);
        }
        return types;
    }, new Set());
}
/**
 * Get array of unique over time comparison types used in ancestors of the provided arithmetic measure.
 *
 * @param measure - the (possibly) arithmetic measure
 * @param buckets - all buckets
 * @return empty array if there are no derived measures in the arithmetic measure ancestors, empty array if provided
 * measure is not arithmetic, array of unique {OverTimeComparisonType} of derived ancestor measures found in arithmetic
 * measure tree.
 */
export function getDerivedTypesFromArithmeticMeasure(measure, buckets) {
    if (!isArithmeticBucketItem(measure)) {
        return [];
    }
    var allMeasures = flatMap(buckets, function (bucket) { return bucket.items; });
    var overTimeComparisonTypes = findDerivedTypesReferencedByArithmeticMeasure(measure, allMeasures, new Set());
    return Array.from(overTimeComparisonTypes);
}
export function filterOutDerivedMeasures(measures) {
    return measures.filter(function (measure) { return !isDerivedBucketItem(measure); });
}
function isArithmeticMeasureFromDerived(measure, buckets) {
    return getDerivedTypesFromArithmeticMeasure(measure, buckets).length > 0;
}
export function filterOutArithmeticMeasuresFromDerived(measures, buckets) {
    return measures.filter(function (measure) { return !isArithmeticMeasureFromDerived(measure, buckets); });
}
function isArithmeticMeasureFromDerivedOfTypeOnly(measure, buckets, derivedType) {
    var arithmeticMeasureDerivedTypes = getDerivedTypesFromArithmeticMeasure(measure, buckets);
    return arithmeticMeasureDerivedTypes.length === 1 && arithmeticMeasureDerivedTypes[0] === derivedType;
}
export function keepOnlyMasterAndDerivedMeasuresOfType(measures, derivedType) {
    return measures.filter(function (measure) { return !isDerivedBucketItem(measure) || isDerivedOfTypeBucketItem(measure, derivedType); });
}
export function filterOutIncompatibleArithmeticMeasures(measures, buckets, derivedOfTypeToKeep) {
    return measures.filter(function (measure) {
        return !isArithmeticBucketItem(measure) ||
            !isArithmeticMeasureFromDerived(measure, buckets) ||
            isArithmeticMeasureFromDerivedOfTypeOnly(measure, buckets, derivedOfTypeToKeep);
    });
}
export function isDateBucketItem(bucketItem) {
    return !!bucketItem && bucketItem.type === DATE;
}
export var isNotDateBucketItem = negate(isDateBucketItem);
export function getDateFilter(filtersBucket) {
    if (!filtersBucket) {
        return null;
    }
    var dateFiltersInclEmpty = flatMap(filtersBucket.items, function (filterItem) {
        var _a;
        var filters = (_a = filterItem.filters) !== null && _a !== void 0 ? _a : [];
        return filters.find(isDateFilter);
    });
    var dateFilters = compact(dateFiltersInclEmpty);
    return dateFilters.length ? dateFilters[0] : null;
}
export function getComparisonTypeFromFilters(filtersBucket) {
    if (isEmpty(filtersBucket)) {
        return OverTimeComparisonTypes.NOTHING;
    }
    var dateFilter = getDateFilter(filtersBucket);
    return !isEmpty(dateFilter) && dateFilter.overTimeComparisonType
        ? dateFilter.overTimeComparisonType
        : OverTimeComparisonTypes.NOTHING;
}
function bucketSupportsSubtitle(visualizationType, bucketLocalIdentifier) {
    if (visualizationType === VisualizationTypes.HEADLINE) {
        return true;
    }
    if (visualizationType === VisualizationTypes.SCATTER) {
        return bucketLocalIdentifier !== BucketNames.ATTRIBUTE;
    }
    if (visualizationType === VisualizationTypes.BUBBLE) {
        return bucketLocalIdentifier !== BucketNames.VIEW;
    }
    if (visualizationType === VisualizationTypes.COMBO) {
        return bucketLocalIdentifier !== BucketNames.VIEW;
    }
    if (visualizationType === VisualizationTypes.BULLET) {
        return bucketLocalIdentifier !== BucketNames.VIEW;
    }
    if (visualizationType === VisualizationTypes.PUSHPIN) {
        return (bucketLocalIdentifier !== BucketNames.LOCATION && bucketLocalIdentifier !== BucketNames.SEGMENT);
    }
    return false;
}
export function setBucketTitles(referencePoint, visualizationType, intl) {
    var buckets = referencePoint === null || referencePoint === void 0 ? void 0 : referencePoint.buckets;
    var updatedUiConfig = cloneDeep(referencePoint === null || referencePoint === void 0 ? void 0 : referencePoint.uiConfig);
    forEach(buckets, function (bucket) {
        var _a, _b, _c, _d;
        var localIdentifier = (_a = bucket.localIdentifier) !== null && _a !== void 0 ? _a : "";
        // skip disabled buckets
        if (!((_d = (_c = (_b = updatedUiConfig === null || updatedUiConfig === void 0 ? void 0 : updatedUiConfig.buckets) === null || _b === void 0 ? void 0 : _b[localIdentifier]) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : false)) {
            return;
        }
        if (bucketSupportsSubtitle(visualizationType, localIdentifier)) {
            var subtitleId = generateBucketSubtitleId(localIdentifier, visualizationType);
            var subtitle = getTranslation(subtitleId, intl);
            set(updatedUiConfig, [BUCKETS, localIdentifier, "subtitle"], subtitle);
        }
        var titleId = generateBucketTitleId(localIdentifier, visualizationType);
        var title = getTranslation(titleId, intl);
        set(updatedUiConfig, [BUCKETS, localIdentifier, "title"], title);
    });
    return updatedUiConfig;
}
export function generateBucketTitleId(localIdentifier, visualizationType) {
    return "dashboard.bucket." + localIdentifier + "_title." + visualizationType;
}
function generateBucketSubtitleId(localIdentifier, visualizationType) {
    return "dashboard.bucket." + localIdentifier + "_subtitle." + visualizationType;
}
export function getItemsCount(buckets, localIdentifier) {
    return getBucketItems(buckets, localIdentifier).length;
}
export function getBucketItems(buckets, localIdentifier) {
    var _a, _b;
    return (_b = (_a = buckets.find(function (bucket) { return bucket.localIdentifier === localIdentifier; })) === null || _a === void 0 ? void 0 : _a.items) !== null && _b !== void 0 ? _b : [];
}
// return bucket items matching localIdentifiers from any bucket
export function getItemsFromBuckets(buckets, localIdentifiers, types) {
    return localIdentifiers.reduce(function (bucketItems, localIdentifier) {
        return bucketItems.concat(types
            ? getBucketItemsByType(buckets, localIdentifier, types)
            : getBucketItems(buckets, localIdentifier));
    }, []);
}
export function getBucketItemsByType(buckets, localIdentifier, types) {
    var itemsOfType = [];
    var bucketItems = getBucketItems(buckets, localIdentifier);
    bucketItems.forEach(function (item) {
        if (includes(types, item.type)) {
            itemsOfType.push(item);
        }
    });
    return itemsOfType;
}
export function getPreferredBucketItems(buckets, preference, type) {
    var _a;
    var bucket = getPreferredBucket(buckets, preference, type);
    return (_a = bucket === null || bucket === void 0 ? void 0 : bucket.items) !== null && _a !== void 0 ? _a : [];
}
function getPreferredBucket(buckets, preference, type) {
    return preference.reduce(function (result, preference) {
        if (result) {
            return result;
        }
        return buckets.find(function (bucket) {
            var _a;
            var preferenceMatch = bucket.localIdentifier === preference;
            var typeMatch = every((_a = bucket === null || bucket === void 0 ? void 0 : bucket.items) !== null && _a !== void 0 ? _a : [], function (item) { return type.indexOf(item.type) !== -1; });
            return preferenceMatch && typeMatch;
        });
    }, undefined);
}
function getAllBucketItemsByType(bucket, types) {
    return bucket.items.reduce(function (resultItems, item) {
        if (includes(types, item.type)) {
            resultItems.push(item);
        }
        return resultItems;
    }, []);
}
export function getAllItemsByType(buckets, types) {
    return buckets.reduce(function (items, bucket) { return __spreadArrays(items, getAllBucketItemsByType(bucket, types)); }, []);
}
export function removeDuplicateBucketItems(buckets) {
    var usedIdentifiersMap = {};
    return buckets.map(function (bucket) {
        var filteredBucketItems = bucket.items.filter(function (bucketItem) {
            var isDuplicate = usedIdentifiersMap[bucketItem.localIdentifier];
            usedIdentifiersMap[bucketItem.localIdentifier] = true;
            return !isDuplicate;
        });
        return filteredBucketItems.length === bucket.items.length
            ? bucket
            : __assign(__assign({}, bucket), { items: filteredBucketItems });
    });
}
export function getTotalsFromBucket(buckets, bucketName) {
    var _a;
    var selectedBucket = buckets.find(function (bucket) { return bucket.localIdentifier === bucketName; });
    return (_a = selectedBucket === null || selectedBucket === void 0 ? void 0 : selectedBucket.totals) !== null && _a !== void 0 ? _a : [];
}
function getUniqueAttributes(buckets) {
    var attributes = getAllItemsByType(buckets, [ATTRIBUTE, DATE]);
    return uniqBy(attributes, function (attribute) { return attribute === null || attribute === void 0 ? void 0 : attribute.attribute; });
}
export function getMeasuresFromMdObject(insight) {
    if (!insight) {
        return [];
    }
    return bucketsMeasures(insightBuckets(insight), isSimpleMeasure);
}
export function getAllMeasures(buckets) {
    return getAllItemsByType(buckets, [METRIC]);
}
export function getFirstValidMeasure(buckets) {
    var measures = getAllMeasures(buckets);
    var validMeasures = measures.filter(isValidMeasure);
    return validMeasures[0] || null;
}
function isValidMeasure(measure) {
    if (isArithmeticBucketItem(measure)) {
        return measure.operandLocalIdentifiers.every(function (operandLocalIdentifier) { return operandLocalIdentifier !== null; });
    }
    return true;
}
export function getFirstAttribute(buckets) {
    return getUniqueAttributes(buckets)[0] || null;
}
export function getMeasureItems(buckets) {
    var preference = [BucketNames.MEASURES, BucketNames.SECONDARY_MEASURES, BucketNames.TERTIARY_MEASURES];
    var preferredMeasures = preference.reduce(function (acc, pref) {
        var prefBucketItems = getPreferredBucketItems(buckets, [pref], [METRIC]);
        return __spreadArrays(acc, prefBucketItems);
    }, []);
    // if no preferred items are found, return all available items
    if (isEmpty(preferredMeasures)) {
        return getAllMeasures(buckets);
    }
    return preferredMeasures;
}
export function getBucketItemsWithExcludeByType(buckets, excludedBucket, type) {
    var includedBuckets = buckets.filter(function (bucket) { return !includes(excludedBucket, bucket.localIdentifier); });
    return getAllItemsByType(includedBuckets, type);
}
export function getStackItems(buckets, itemTypes) {
    var _a;
    if (itemTypes === void 0) { itemTypes = [ATTRIBUTE]; }
    var preferredStacks = getPreferredBucket(buckets, [BucketNames.STACK, BucketNames.SEGMENT], itemTypes);
    return (_a = preferredStacks === null || preferredStacks === void 0 ? void 0 : preferredStacks.items) !== null && _a !== void 0 ? _a : [];
}
export function getViewItems(buckets, itemTypes) {
    var _a;
    if (itemTypes === void 0) { itemTypes = [ATTRIBUTE]; }
    var preferredStacks = getPreferredBucket(buckets, [BucketNames.VIEW], itemTypes);
    return (_a = preferredStacks === null || preferredStacks === void 0 ? void 0 : preferredStacks.items) !== null && _a !== void 0 ? _a : [];
}
export function getAttributeItems(buckets) {
    return getAllAttributeItemsWithPreference(buckets, [
        BucketNames.LOCATION,
        BucketNames.VIEW,
        BucketNames.TREND,
    ]);
}
export function getAttributeItemsWithoutStacks(buckets, itemTypes) {
    if (itemTypes === void 0) { itemTypes = [ATTRIBUTE]; }
    return getAttributeItems(buckets).filter(function (attribute) {
        return !includes(getStackItems(buckets, itemTypes), attribute);
    });
}
export function getAllCategoriesAttributeItems(buckets) {
    var stackItemsWithDate = getStackItems(buckets, [ATTRIBUTE, DATE]);
    return getAttributeItems(buckets).filter(function (attribute) {
        return !includes(stackItemsWithDate, attribute);
    });
}
export function getAllAttributeItems(buckets) {
    return getAllItemsByType(buckets, [ATTRIBUTE, DATE]);
}
function getAllMeasureItems(buckets) {
    return getAllItemsByType(buckets, [METRIC]);
}
// get all attributes from buckets, but items from preferred buckets are first
export function getAllAttributeItemsWithPreference(buckets, preference) {
    var preferredAttributes = preference.reduce(function (acc, pref) {
        var _a;
        var prefBucket = getPreferredBucket(buckets, [pref], [ATTRIBUTE, DATE]);
        return __spreadArrays(acc, ((_a = prefBucket === null || prefBucket === void 0 ? void 0 : prefBucket.items) !== null && _a !== void 0 ? _a : []));
    }, []);
    var allBucketNames = buckets.map(function (bucket) { return bucket === null || bucket === void 0 ? void 0 : bucket.localIdentifier; });
    var otherBucketNames = allBucketNames.filter(function (bucketName) { return !includes(preference, bucketName); });
    var allOtherAttributes = otherBucketNames.reduce(function (attributes, bucketName) {
        return attributes.concat(getBucketItemsByType(buckets, bucketName, [ATTRIBUTE, DATE]));
    }, []);
    return __spreadArrays(preferredAttributes, allOtherAttributes);
}
export function getDateItems(buckets) {
    return getAttributeItemsWithoutStacks(buckets).filter(isDateBucketItem);
}
export function getDateItemsWithMultipleDates(buckets) {
    return getAttributeItemsWithoutStacks(buckets, [ATTRIBUTE, DATE]).filter(isDateBucketItem);
}
export function getFistDateItemWithMultipleDates(buckets) {
    var dateItems = getDateItemsWithMultipleDates(buckets);
    return dateItems[0];
}
export function getFistDateItem(buckets) {
    var dateItems = getDateItems(buckets);
    return dateItems[0];
}
export function getMainDateItem(dateItems) {
    // first item for now, can be replaced by item matching the dimension of date filter in future
    return dateItems[0];
}
function hasItemsAboveLimit(bucket, itemsLimit) {
    var masterBucketItems = filterOutDerivedMeasures(bucket.items);
    return masterBucketItems.length > itemsLimit;
}
function applyItemsLimit(bucket, itemsLimit) {
    if (itemsLimit !== undefined && hasItemsAboveLimit(bucket, itemsLimit)) {
        var newBucket = cloneDeep(bucket);
        newBucket.items = newBucket.items.slice(0, itemsLimit);
        return newBucket;
    }
    return bucket;
}
function applyUiConfigOnBucket(bucket, bucketUiConfig) {
    return applyItemsLimit(bucket, bucketUiConfig === null || bucketUiConfig === void 0 ? void 0 : bucketUiConfig.itemsLimit);
}
export function applyUiConfig(referencePoint) {
    var buckets = referencePoint.buckets;
    var uiConfig = referencePoint.uiConfig.buckets;
    var newBuckets = buckets.map(function (bucket) {
        return applyUiConfigOnBucket(bucket, uiConfig[bucket.localIdentifier]);
    });
    set(referencePoint, "buckets", newBuckets);
    return referencePoint;
}
export function hasBucket(buckets, localIdentifier) {
    return buckets.some(function (bucket) { return bucket.localIdentifier === localIdentifier; });
}
export function findBucket(buckets, localIdentifier) {
    return buckets.find(function (bucket) { return (bucket === null || bucket === void 0 ? void 0 : bucket.localIdentifier) === localIdentifier; });
}
export function getBucketsByNames(buckets, names) {
    return buckets.filter(function (bucket) { return includes(names, bucket === null || bucket === void 0 ? void 0 : bucket.localIdentifier); });
}
export function getFirstMasterWithDerived(measureItems) {
    var masters = filterOutDerivedMeasures(measureItems);
    var chosenMaster = masters[0];
    return measureItems.filter(function (measureItem) {
        return measureItem.masterLocalIdentifier === chosenMaster.localIdentifier ||
            measureItem === chosenMaster;
    });
}
export function removeAllArithmeticMeasuresFromDerived(extendedReferencePoint) {
    var originalBuckets = cloneDeep(extendedReferencePoint.buckets);
    forEach(extendedReferencePoint.buckets, function (bucket) {
        bucket.items = filterOutArithmeticMeasuresFromDerived(bucket.items, originalBuckets);
    });
    return extendedReferencePoint;
}
export function removeAllDerivedMeasures(extendedReferencePoint) {
    forEach(extendedReferencePoint.buckets, function (bucket) {
        bucket.items = filterOutDerivedMeasures(bucket.items);
    });
    return extendedReferencePoint;
}
export function findMasterBucketItem(derivedBucketItem, bucketItems) {
    return bucketItems.find(function (item) { return item.localIdentifier === derivedBucketItem.masterLocalIdentifier; });
}
export function findMasterBucketItems(bucketItems) {
    return bucketItems.filter(function (measure) { return !isDerivedBucketItem(measure); });
}
export function findDerivedBucketItems(masterBucketItem, bucketItems) {
    return bucketItems.filter(function (measure) { return measure.masterLocalIdentifier === masterBucketItem.localIdentifier; });
}
export function findDerivedBucketItem(masterBucketItem, bucketItems) {
    return bucketItems.find(function (bucketItem) { return bucketItem.masterLocalIdentifier === masterBucketItem.localIdentifier; });
}
export function hasDerivedBucketItems(masterBucketItem, buckets) {
    return buckets.some(function (bucket) {
        return bucket.items.some(function (bucketItem) { return bucketItem.masterLocalIdentifier === masterBucketItem.localIdentifier; });
    });
}
export function getFilteredMeasuresForStackedCharts(buckets) {
    var hasStacks = getStackItems(buckets, [ATTRIBUTE, DATE]).length > 0;
    if (hasStacks) {
        var limitedBuckets = limitNumberOfMeasuresInBuckets(buckets, 1);
        return getMeasureItems(limitedBuckets);
    }
    return getMeasureItems(buckets);
}
export function noRowsAndHasOneMeasure(buckets) {
    var measuresBucket = bucketsFind(buckets, BucketNames.MEASURES);
    var measures = measuresBucket ? bucketItems(measuresBucket) : [];
    var rowsBucket = bucketsFind(buckets, BucketNames.VIEW);
    var rows = rowsBucket ? bucketItems(rowsBucket) : [];
    var hasOneMeasure = measures.length === 1;
    var hasRows = rows.length > 0;
    return Boolean(hasOneMeasure && !hasRows);
}
export function noColumnsAndHasOneMeasure(buckets) {
    var measuresBucket = bucketsFind(buckets, BucketNames.MEASURES);
    var measures = measuresBucket ? bucketItems(measuresBucket) : [];
    var columnsBucket = bucketsFind(buckets, BucketNames.STACK);
    var columns = columnsBucket ? bucketItems(columnsBucket) : [];
    var hasOneMeasure = measures.length === 1;
    var hasColumn = columns.length > 0;
    return hasOneMeasure && !hasColumn;
}
export function limitNumberOfMeasuresInBuckets(buckets, measuresLimitCount, tryToSelectDerivedWithMaster) {
    if (tryToSelectDerivedWithMaster === void 0) { tryToSelectDerivedWithMaster = false; }
    var allMeasures = getAllMeasures(buckets);
    var selectedMeasuresLocalIdentifiers = [];
    // try to select measures one per bucket
    buckets.forEach(function (bucket) {
        var currentBucketMeasures = getAllBucketItemsByType(bucket, [METRIC]);
        if (currentBucketMeasures.length === 0) {
            return;
        }
        selectedMeasuresLocalIdentifiers = getLimitedMeasuresLocalIdentifiers(currentBucketMeasures, 1, allMeasures, measuresLimitCount, tryToSelectDerivedWithMaster, selectedMeasuresLocalIdentifiers);
    });
    // if it was not possible to select all measures one per bucket then limit them globally
    if (selectedMeasuresLocalIdentifiers.length < measuresLimitCount) {
        selectedMeasuresLocalIdentifiers = getLimitedMeasuresLocalIdentifiers(allMeasures, measuresLimitCount, allMeasures, measuresLimitCount, tryToSelectDerivedWithMaster, selectedMeasuresLocalIdentifiers);
    }
    return pruneBucketMeasureItems(buckets, selectedMeasuresLocalIdentifiers);
}
function getLimitedMeasuresLocalIdentifiers(measures, measuresLimitCount, allMeasures, allMeasuresLimitCount, tryToSelectDerivedWithMaster, alreadySelectedMeasures) {
    var selectedMeasures = alreadySelectedMeasures;
    // try to select measures one by one together with their dependencies
    measures.forEach(function (measure) {
        if (selectedMeasures.length - alreadySelectedMeasures.length === measuresLimitCount) {
            return;
        }
        var measureDependencies = getDependenciesLocalIdentifiers(measure, allMeasures);
        var measureWithDependencies = __spreadArrays([measure.localIdentifier], measureDependencies);
        if (tryToSelectDerivedWithMaster) {
            var derivedMeasures = getDerivedLocalIdentifiers(measure, allMeasures);
            var masterDerivedAndDependencies = __spreadArrays(measureWithDependencies, derivedMeasures);
            selectedMeasures = tryToSelectMeasures(masterDerivedAndDependencies, selectedMeasures, allMeasuresLimitCount);
        }
        selectedMeasures = tryToSelectMeasures(measureWithDependencies, selectedMeasures, allMeasuresLimitCount);
    });
    return selectedMeasures;
}
function getDerivedLocalIdentifiers(measure, allMeasures) {
    var derivedMeasures = findDerivedBucketItems(measure, allMeasures);
    return derivedMeasures.map(function (derivedMeasure) { return derivedMeasure.localIdentifier; });
}
function findMeasureByLocalIdentifier(localIdentifier, measures) {
    return measures.find(function (measure) { return measure.localIdentifier === localIdentifier; });
}
function getDependenciesLocalIdentifiers(measure, allMeasures) {
    var directDependencies = [];
    if (measure.masterLocalIdentifier) {
        directDependencies.push(measure.masterLocalIdentifier);
    }
    if (measure.operandLocalIdentifiers) {
        measure.operandLocalIdentifiers
            .filter(function (operandLocalIdentifier) { return operandLocalIdentifier !== null; })
            .forEach(function (operandLocalIdentifier) {
            var operandMeasure = findMeasureByLocalIdentifier(operandLocalIdentifier, allMeasures);
            if (operandMeasure !== undefined) {
                directDependencies.push(operandLocalIdentifier);
            }
        });
    }
    var indirectDependencies = [];
    directDependencies.forEach(function (dependencyLocalIdentifier) {
        var dependencyMeasure = findMeasureByLocalIdentifier(dependencyLocalIdentifier, allMeasures);
        var dependenciesOfDependency = getDependenciesLocalIdentifiers(dependencyMeasure, allMeasures);
        indirectDependencies.push.apply(indirectDependencies, dependenciesOfDependency);
    });
    return uniq(__spreadArrays(directDependencies, indirectDependencies));
}
function tryToSelectMeasures(measures, alreadySelectedMeasures, limit) {
    var measuresToBePlaced = without.apply(void 0, __spreadArrays([measures], alreadySelectedMeasures));
    if (measuresToBePlaced.length <= limit - alreadySelectedMeasures.length) {
        return __spreadArrays(alreadySelectedMeasures, measuresToBePlaced);
    }
    return alreadySelectedMeasures;
}
function pruneBucketMeasureItems(buckets, measureLocalIdentifiersToBeKept) {
    return buckets.map(function (bucket) {
        var prunedItems = bucket.items.filter(function (item) {
            return measureLocalIdentifiersToBeKept.indexOf(item.localIdentifier) > -1 || item.type !== METRIC;
        });
        return __assign(__assign({}, bucket), { items: prunedItems });
    });
}
function isShowOnSecondaryAxis(item) {
    var _a;
    return (_a = item === null || item === void 0 ? void 0 : item.showOnSecondaryAxis) !== null && _a !== void 0 ? _a : false;
}
export function setMeasuresShowOnSecondaryAxis(items, value) {
    return items.map(function (item) {
        var _a;
        return (__assign(__assign({}, item), (_a = {}, _a[SHOW_ON_SECONDARY_AXIS] = value, _a)));
    });
}
export function removeShowOnSecondaryAxis(items) {
    return setMeasuresShowOnSecondaryAxis(items, null);
}
export function getAllMeasuresShowOnSecondaryAxis(buckets) {
    return getAllItemsByType(buckets, [METRIC]).filter(isShowOnSecondaryAxis);
}
export function getItemsLocalIdentifiers(items) {
    return items.map(function (item) { var _a; return (_a = item === null || item === void 0 ? void 0 : item.localIdentifier) !== null && _a !== void 0 ? _a : ""; });
}
export var transformMeasureBuckets = function (measureBucketItemsLimits, buckets) {
    var unusedMeasures = [];
    var newBuckets = measureBucketItemsLimits.map(function (_a) {
        var localIdentifier = _a.localIdentifier, itemsLimit = _a.itemsLimit;
        var preferredBucketLocalIdentifiers = localIdentifier === BucketNames.MEASURES
            ? [BucketNames.MEASURES, BucketNames.SIZE]
            : localIdentifier === BucketNames.SECONDARY_MEASURES
                ? [BucketNames.SECONDARY_MEASURES, BucketNames.COLOR]
                : [localIdentifier];
        var preferredBucketItems = getPreferredBucketItems(buckets, preferredBucketLocalIdentifiers, [
            METRIC,
        ]);
        var measuresToBePlaced = preferredBucketItems.splice(0, itemsLimit);
        if (measuresToBePlaced.length === 0) {
            return {
                localIdentifier: localIdentifier,
                items: unusedMeasures.splice(0, itemsLimit),
            };
        }
        unusedMeasures = __spreadArrays(unusedMeasures, preferredBucketItems);
        return {
            localIdentifier: localIdentifier,
            items: measuresToBePlaced,
        };
    });
    return newBuckets.map(function (bucket, bucketIndex) {
        var bucketItemsLimit = measureBucketItemsLimits[bucketIndex].itemsLimit;
        var freeSlotsCount = bucketItemsLimit - bucket.items.length;
        if (freeSlotsCount === 0) {
            return bucket;
        }
        return __assign(__assign({}, bucket), { items: __spreadArrays(bucket.items, unusedMeasures.splice(0, freeSlotsCount)) });
    });
};
export var hasSameDateDimension = function (dateItem, referenceDateItem) {
    if (isDateBucketItem(dateItem) && isDateBucketItem(referenceDateItem)) {
        return areObjRefsEqual(dateItem.dateDatasetRef, referenceDateItem.dateDatasetRef);
    }
    return false;
};
export var removeDivergentDateItems = function (viewItems, mainDateItem) {
    return viewItems.filter(function (item) { return isNotDateBucketItem(item) || hasSameDateDimension(item, mainDateItem); });
};
var getDateFilterRef = function (filters) {
    var _a;
    var dateFilter = (_a = filters === null || filters === void 0 ? void 0 : filters.items) === null || _a === void 0 ? void 0 : _a.find(isFiltersBucketItem);
    if (!dateFilter) {
        return undefined;
    }
    return dateFilter.dateDatasetRef;
};
export var isComparisonAvailable = function (buckets, filters) {
    var itemsFromBucket = buckets.reduce(function (acc, bucket) { return acc.concat(bucket.items); }, []);
    var bucketDateItems = itemsFromBucket.filter(isDateBucketItem);
    var areDateBucketItemsEmpty = bucketDateItems.length === 0;
    var dateFilterRef = getDateFilterRef(filters);
    if (areDateBucketItemsEmpty) {
        return true;
    }
    return bucketDateItems.some(function (bucketDateItem) {
        return areObjRefsEqual(bucketDateItem.dateDatasetRef, dateFilterRef);
    });
};
//# sourceMappingURL=bucketHelper.js.map