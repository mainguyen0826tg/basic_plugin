import { __assign, __spreadArrays } from "tslib";
// (C) 2007-2021 GoodData Corporation
import { SortDirection as TigerSortDirection, } from "@gooddata/api-client-tiger";
import { isAttributeLocator, isAttributeSort, MeasureGroupIdentifier, } from "@gooddata/sdk-model";
import isEmpty from "lodash/isEmpty";
import findIndex from "lodash/findIndex";
function merge(dims, sorting) {
    return dims.map(function (dim, idx) {
        if (!isEmpty(sorting[idx])) {
            return __assign(__assign({}, dim), { sorting: sorting[idx] });
        }
        return dim;
    });
}
function convertSortDirection(direction) {
    if (direction === "asc") {
        return TigerSortDirection.ASC;
    }
    return TigerSortDirection.DESC;
}
/**
 * This messed up function exists because PivotTable expects specific (bear) format of attribute element URIs from
 * which it construct table column ids. The logic behind column ids is deeply rooted (rotted-into) that it would
 * mean non-trivial changes / partial rewrites in the pivot table.
 *
 * To avoid that (because it will likely be several weeks worth of effort and testing), we opted for a dirty 'trick'
 * where tiger backend constructs attribute element URIs so that they resemble the bear URIs. The element ID is
 * actually the primaryLabelValue --> thing that can be used for sorting.
 *
 * This function caters for the dirty trick + in case the sorts were created 'normally', programatically by the
 * user who specified primaryLabelValue directly, it has logic to fall back to using the uri as-is.
 */
function extractItemValueFromElement(elementUri) {
    var parsedUri = elementUri.match(/obj\/([^/]*)(\/elements\?id=)?(.*)?$/);
    if (parsedUri && parsedUri[3]) {
        return parsedUri[3];
    }
    return elementUri;
}
function convertMeasureLocators(locators) {
    var dataColumnLocators = locators.map(function (locator) {
        var _a, _b;
        if (isAttributeLocator(locator)) {
            return _a = {},
                _a[locator.attributeLocatorItem.attributeIdentifier] = extractItemValueFromElement(locator.attributeLocatorItem.element),
                _a;
        }
        else {
            return _b = {},
                _b[MeasureGroupIdentifier] = locator.measureLocatorItem.measureIdentifier,
                _b;
        }
    });
    return Object.assign.apply(Object, __spreadArrays([{}], dataColumnLocators));
}
/**
 * Places sorting into dimensions. Returns new dimensions augmented by sorting. Does not mutate.
 *
 * Tiger does sorting differently from bear so this is somewhat more complicated than pure object conversions.
 *
 * 1. Sorting is now placed in the dimension that has to be sorted
 * 2. When sorting by attribute (headers), then the attribute sort key must be placed into the dimension that
 *    contains the attribute
 * 3. When sorting by measure, we now fall back to 'bear-like' behavior: the dimension opposite to the one
 *    that contains the measures will be sorted. It will be sorted using the measure (possibly scoped for
 *    particular attribute values) located in the MeasureGroup dimension.
 *
 * At the end, this function walks the sort items in the order defined by the user and distributes them into
 * the dimensions. The function is lenient for now and will log warnings and ignore anything weird that it
 * cannot process (e.g. measure sorting when there is no dim with MeasureGroup, or if there is only dim with MeasureGroup
 * and no other dim).
 *
 * @param dims - dimensions to add sorting to
 * @param sorts - sort items defined by SDK user
 */
function dimensionsWithSorts(dims, sorts) {
    if (isEmpty(sorts)) {
        return dims;
    }
    var nonMeasureDimIdx = findIndex(dims, function (dim) { return !dim.itemIdentifiers.includes(MeasureGroupIdentifier); });
    var measureDim = dims.find(function (dim) { return dim.itemIdentifiers.includes(MeasureGroupIdentifier); });
    var sorting = dims.map(function (_) { return []; });
    sorts.forEach(function (sortItem) {
        var _a;
        if (isAttributeSort(sortItem)) {
            var attributeIdentifier_1 = sortItem.attributeSortItem.attributeIdentifier;
            var attributeSortKey = {
                attribute: {
                    attributeIdentifier: attributeIdentifier_1,
                    direction: convertSortDirection(sortItem.attributeSortItem.direction),
                },
            };
            var dimIdx = findIndex(dims, function (dim) { return dim.itemIdentifiers.includes(attributeIdentifier_1); });
            if (dimIdx < 0) {
                // eslint-disable-next-line no-console
                console.log("attempting to sort by attribute with localId " + attributeIdentifier_1 + " but this attribute is not in any dimension.");
                return;
            }
            sorting[dimIdx].push(attributeSortKey);
        }
        else {
            if (nonMeasureDimIdx < 0) {
                // eslint-disable-next-line no-console
                console.warn("Trying to use measure sort in an execution that only contains dimension with MeasureGroup. " +
                    "This is not valid sort. Measure sort is used to sort the non-measure dimension by values from measure dimension. Ignoring");
                return;
            }
            if (!measureDim) {
                // eslint-disable-next-line no-console
                console.warn("Trying to use measure sort in an execution that does not contain MeasureGroup. Ignoring.");
                return;
            }
            var valueSortKey = {
                value: {
                    direction: convertSortDirection(sortItem.measureSortItem.direction),
                    dataColumnLocators: (_a = {},
                        _a[measureDim.localIdentifier] = convertMeasureLocators(sortItem.measureSortItem.locators),
                        _a),
                },
            };
            sorting[nonMeasureDimIdx].push(valueSortKey);
        }
    });
    return merge(dims, sorting);
}
/**
 * Converts data in execution definition into dimension specifications for tiger. The tiger specifics
 * are that dimensions have localIds and that sorting is specified per-dimension.
 *
 * @param def
 */
export function convertDimensions(def) {
    var dimensionsWithoutSorts = def.dimensions.map(function (dim, idx) {
        return {
            localIdentifier: "dim_" + idx,
            itemIdentifiers: dim.itemIdentifiers,
        };
    });
    return dimensionsWithSorts(dimensionsWithoutSorts, def.sortBy);
}
//# sourceMappingURL=DimensionsConverter.js.map