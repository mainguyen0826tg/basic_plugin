import { __assign, __awaiter, __generator } from "tslib";
// (C) 2019-2021 GoodData Corporation
import { factory as createSdk } from "@gooddata/api-client-bear";
import { NotAuthenticated, isNotAuthenticated, } from "@gooddata/sdk-backend-spi";
import invariant from "ts-invariant";
import isEmpty from "lodash/isEmpty";
import { convertApiError, isApiResponseError } from "../utils/errorHandling";
import { BearWorkspace } from "./workspace";
import { BearWorkspaceQueryFactory } from "./workspaces";
import { BearUserService } from "./user";
import { convertInsight } from "../convertors/toBackend/InsightConverter";
import { sanitizeDrillingActivationPostMessageData } from "./drillingPostMessageData";
import { NoopAuthProvider, AuthProviderCallGuard, } from "@gooddata/sdk-backend-base";
import { BearOrganization, BearOrganizations } from "./organization";
var CAPABILITIES = {
    canCalculateGrandTotals: true,
    canCalculateSubTotals: true,
    canCalculateTotals: true,
    canCalculateNativeTotals: true,
    canExportCsv: true,
    canExportXlsx: true,
    canSortData: true,
    canTransformExistingResult: false,
    maxDimensions: 2,
    supportsElementUris: true,
    supportsObjectUris: true,
    supportsCsvUploader: true,
    supportsLegacyReports: true,
    supportsRankingFilter: true,
    supportsRankingFilterWithMeasureValueFilter: true,
    supportsElementsQueryParentFiltering: true,
    supportsKpiWidget: true,
    supportsHyperlinkAttributeLabels: true,
    supportsGenericDateAttributeElements: true,
    supportsExplain: false,
    supportsAccessControl: true,
    usesStrictAccessControl: false,
};
/**
 * This implementation of analytical backend uses the gooddata-js API client to realize the SPI.
 *
 * The only thing worth noting about this impl is the handling of SDK instance creation and authentication:
 *
 * - New instance of SDK is created for each instance of BearBackend; new instance of BearBackend is created
 *   every time onHostname, withCredentials or withTelemetry methods are called (similar to how we did it
 *   so far with the clone())
 *
 * - Authentication (login) WILL be done every time credentials are provided using the
 *   withCredentials. No other methods in the bear backend lead to login.
 *
 * - Authentication is done at construction time; the constructor MAY receive an instance of deferred authentication -
 *   this is to cater for cases when withCredentials is called, new instance of backend is returned and then
 *   someone calls withTelemetry on this instance => in that case there is no need to re-initiate login.
 *
 */
var BearBackend = /** @class */ (function () {
    function BearBackend(config, implConfig, telemetry, authProvider) {
        var _this = this;
        var _a, _b;
        this.capabilities = CAPABILITIES;
        this.isAuthenticated = function () {
            return new Promise(function (resolve, reject) {
                _this.authProvider
                    .getCurrentPrincipal({ client: _this.sdk, backend: _this })
                    .then(function (res) {
                    resolve(res);
                })
                    .catch(function (err) {
                    if (isNotAuthenticatedResponse(err)) {
                        resolve(null);
                    }
                    reject(err);
                });
            });
        };
        this.authenticate = function (force) {
            if (!force) {
                return _this.authApiCall(function (sdk) { return __awaiter(_this, void 0, void 0, function () {
                    var principal;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.authProvider.getCurrentPrincipal({ client: sdk, backend: this })];
                            case 1:
                                principal = _a.sent();
                                invariant(principal, "Principal must be defined");
                                return [2 /*return*/, principal];
                        }
                    });
                }); });
            }
            return _this.triggerAuthentication(true);
        };
        /**
         * Perform API call that requires authentication. The call will be decorated with error handling
         * such that not authenticated errors will trigger authentication flow AND other errors will be
         * converted using the provided converter and throw.
         *
         * @param call - a call which requires an authenticated session
         * @param errorConverter - converter from rest client errors to analytical backend errors
         */
        this.authApiCall = function (call, errorConverter) {
            if (errorConverter === void 0) { errorConverter = convertApiError; }
            return __awaiter(_this, void 0, void 0, function () {
                var _a, _b;
                var _this = this;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0:
                            _a = call;
                            _b = [this.sdk];
                            return [4 /*yield*/, this.getAsyncCallContext()];
                        case 1: return [2 /*return*/, _a.apply(void 0, _b.concat([_c.sent()]))
                                .catch(function (err) {
                                if (!isNotAuthenticatedResponse(err)) {
                                    throw errorConverter(err);
                                }
                                return _this.triggerAuthentication()
                                    .then(function (_) { return __awaiter(_this, void 0, void 0, function () {
                                    var _a, _b;
                                    return __generator(this, function (_c) {
                                        switch (_c.label) {
                                            case 0:
                                                _a = call;
                                                _b = [this.sdk];
                                                return [4 /*yield*/, this.getAsyncCallContext()];
                                            case 1: return [2 /*return*/, _a.apply(void 0, _b.concat([_c.sent()])).catch(function (e) {
                                                    throw errorConverter(e);
                                                })];
                                        }
                                    });
                                }); })
                                    .catch(function (err2) {
                                    throw errorConverter(err2);
                                });
                            })
                                .catch(this.handleNotAuthenticated)];
                    }
                });
            });
        };
        this.getAuthenticationContext = function () { return ({ client: _this.sdk, backend: _this }); };
        this.triggerAuthentication = function (reset) {
            if (reset === void 0) { reset = false; }
            if (!_this.authProvider) {
                return Promise.reject(new NotAuthenticated("Backend is not set up with authentication provider."));
            }
            if (reset) {
                _this.authProvider.reset();
            }
            return _this.authProvider
                .authenticate(_this.getAuthenticationContext())
                .catch(function (e) {
                throw convertApiError(e);
            })
                .catch(_this.handleNotAuthenticated);
        };
        this.handleNotAuthenticated = function (err) {
            var _a, _b;
            if (isNotAuthenticated(err)) {
                (_b = (_a = _this.authProvider).onNotAuthenticated) === null || _b === void 0 ? void 0 : _b.call(_a, { client: _this.sdk, backend: _this }, err);
            }
            throw err;
        };
        this.getAsyncCallContext = function () { return __awaiter(_this, void 0, void 0, function () {
            var getPrincipal;
            var _this = this;
            return __generator(this, function (_a) {
                getPrincipal = function () { return __awaiter(_this, void 0, void 0, function () {
                    var principal;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!this.authProvider) {
                                    throw new NotAuthenticated("Cannot obtain principal without an authProvider.");
                                }
                                return [4 /*yield*/, this.authProvider.getCurrentPrincipal({
                                        client: this.sdk,
                                        backend: this,
                                    })];
                            case 1:
                                principal = _a.sent();
                                if (principal) {
                                    return [2 /*return*/, principal];
                                }
                                return [2 /*return*/, this.authProvider.authenticate(this.getAuthenticationContext())];
                        }
                    });
                }); };
                return [2 /*return*/, {
                        getPrincipal: getPrincipal,
                    }];
            });
        }); };
        this.config = configSanitize(config);
        this.implConfig = bearConfigSanitize(implConfig);
        this.telemetry = telemetrySanitize(telemetry);
        this.authProvider = authProvider || new NoopAuthProvider();
        this.sdk = newSdkInstance(this.config, this.implConfig, this.telemetry);
        (_b = (_a = this.authProvider).initializeClient) === null || _b === void 0 ? void 0 : _b.call(_a, this.sdk);
        if (this.implConfig.onLegacyCallbacksReady) {
            var legacyFunctions = {
                openAsReport: function (workspace, insight) {
                    var visualizationObject = convertInsight(insight);
                    return _this.authApiCall(function (sdk) {
                        return sdk.md.openVisualizationAsReport(workspace, { visualizationObject: visualizationObject });
                    });
                },
                getBootstrapResource: function (options) {
                    return _this.authApiCall(function (sdk) { return sdk.user.getBootstrapResource(options); });
                },
                ajaxSetup: function (settings) {
                    _this.sdk.xhr.ajaxSetup(settings);
                },
                log: function (uri, logMessages) { return _this.sdk.xhr.post(uri, { data: JSON.stringify({ logMessages: logMessages }) }); },
                updateProfileCurrentWorkspace: function (workspace, profileSetting) { return __awaiter(_this, void 0, void 0, function () {
                    var userId, newProfileSetting;
                    var _a, _b;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                userId = (_b = (_a = profileSetting.links) === null || _a === void 0 ? void 0 : _a.profile) === null || _b === void 0 ? void 0 : _b.split("/").pop();
                                invariant(userId, "Cannot obtain userId from IProfileSetting");
                                newProfileSetting = __assign(__assign({}, profileSetting), { currentProjectUri: "/gdc/projects/" + workspace });
                                return [4 /*yield*/, this.authApiCall(function (sdk) {
                                        return sdk.user.updateProfileSettings(userId, { profileSetting: newProfileSetting });
                                    })];
                            case 1:
                                _c.sent();
                                return [2 /*return*/];
                        }
                    });
                }); },
                sanitizeDrillingActivationPostMessageData: function (workspace, postMessageData) {
                    return sanitizeDrillingActivationPostMessageData(workspace, postMessageData, function (workspace, identifiers) {
                        return _this.authApiCall(function (sdk) { return sdk.md.getUrisFromIdentifiers(workspace, identifiers); });
                    });
                },
                getProjectDashboards: function (workspace) {
                    return _this.authApiCall(function (sdk) { return sdk.md.getProjectDashboards(workspace); });
                },
                getUrisFromIdentifiers: function (workspace, identifiers) {
                    return _this.authApiCall(function (sdk) { return sdk.md.getUrisFromIdentifiers(workspace, identifiers); });
                },
                getObjectsByUri: function (workspace, uris) {
                    return _this.authApiCall(function (sdk) { return sdk.md.getObjects(workspace, uris); });
                },
                getVisualizationObject: function (workspace, uri) {
                    return _this.authApiCall(function (sdk) { return __awaiter(_this, void 0, void 0, function () {
                        var visObject;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, sdk.md.getObjects(workspace, [uri])];
                                case 1:
                                    visObject = (_a.sent())[0];
                                    return [2 /*return*/, visObject];
                            }
                        });
                    }); });
                },
                getUISettings: function () {
                    return _this.sdk.xhr
                        .get("/gdc/account/organization/settings")
                        .then(function (response) { return response.getData(); });
                },
            };
            this.implConfig.onLegacyCallbacksReady(legacyFunctions);
        }
    }
    BearBackend.prototype.onHostname = function (hostname) {
        return new BearBackend(__assign(__assign({}, this.config), { hostname: hostname }), this.implConfig, this.telemetry);
    };
    BearBackend.prototype.withTelemetry = function (componentName, props) {
        return new BearBackend(this.config, this.implConfig, { componentName: componentName, props: Object.keys(props) }, this.authProvider);
    };
    BearBackend.prototype.withAuthentication = function (provider) {
        var guardedAuthProvider = new AuthProviderCallGuard(provider);
        return new BearBackend(this.config, this.implConfig, this.telemetry, guardedAuthProvider);
    };
    BearBackend.prototype.deauthenticate = function () {
        if (!this.authProvider) {
            throw new NotAuthenticated("Backend is not set up with authentication provider.");
        }
        return this.authProvider.deauthenticate(this.getAuthenticationContext());
    };
    BearBackend.prototype.organization = function (organizationId) {
        return new BearOrganization(this.authApiCall, organizationId);
    };
    BearBackend.prototype.organizations = function () {
        return new BearOrganizations(this.authApiCall);
    };
    BearBackend.prototype.currentUser = function () {
        return new BearUserService(this.authApiCall);
    };
    BearBackend.prototype.workspace = function (id) {
        return new BearWorkspace(this.authApiCall, id);
    };
    BearBackend.prototype.workspaces = function () {
        return new BearWorkspaceQueryFactory(this.authApiCall);
    };
    return BearBackend;
}());
export { BearBackend };
//
// internals
//
function isNotAuthenticatedResponse(err) {
    return isApiResponseError(err) && err.response.status === 401;
}
function configSanitize(config) {
    return config ? config : {};
}
function bearConfigSanitize(implConfig) {
    return implConfig ? implConfig : {};
}
function telemetrySanitize(telemetry) {
    return telemetry ? telemetry : {};
}
function newSdkInstance(config, implConfig, telemetry) {
    var sdk = createSdk();
    if (config.hostname) {
        sdk.config.setCustomDomain(config.hostname);
    }
    if (implConfig.packageName && implConfig.packageVersion) {
        sdk.config.setJsPackage(implConfig.packageName, implConfig.packageVersion);
    }
    if (telemetry.componentName) {
        sdk.config.setRequestHeader("X-GDC-JS-SDK-COMP", telemetry.componentName);
        if (telemetry.props && !isEmpty(telemetry.props)) {
            sdk.config.setRequestHeader("X-GDC-JS-SDK-COMP-PROPS", telemetry.props.join(","));
        }
    }
    return sdk;
}
//# sourceMappingURL=index.js.map