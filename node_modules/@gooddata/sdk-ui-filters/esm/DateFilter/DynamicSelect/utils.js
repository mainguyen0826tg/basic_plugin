var _a;
import { __spreadArrays } from "tslib";
// (C) 2019-2020 GoodData Corporation
import range from "lodash/range";
import { granularityIntlCodes } from "../constants/i18n";
import { getSelectableItems } from "../Select/utils";
export var DAY = "GDC.time.date";
export var WEEK_US = "GDC.time.week_us";
export var MONTH = "GDC.time.month";
export var QUARTER = "GDC.time.quarter";
export var YEAR = "GDC.time.year";
var emptyInputInfo = {
    inputCategory: "Empty",
};
var tooBigInputInfo = {
    inputCategory: "TooBig",
};
var granularityOffsetLimits = (_a = {},
    _a[DAY] = 365,
    _a[WEEK_US] = 104,
    _a[MONTH] = 60,
    _a[QUARTER] = 20,
    _a[YEAR] = 20,
    _a);
var offsetMaxValue = 99999;
var getTrimmedInput = function (input) { return input && input.trim(); };
var isOffsetReasonablyBig = function (offset) { return Math.abs(offset) <= offsetMaxValue; };
var parseInput = function (trimmedInput) {
    if (!trimmedInput) {
        return emptyInputInfo;
    }
    // matches only integers, we do not want to support floats
    var numericMatch = /^[^-\d]*(-?\d+)(?:\s|$)/.exec(trimmedInput);
    if (numericMatch) {
        var numericText = numericMatch[1];
        var numericValue = Number.parseInt(numericText, 10);
        return isOffsetReasonablyBig(numericValue)
            ? {
                offset: numericValue,
                isOnlyNumber: numericText === trimmedInput,
                inputCategory: "Numeric",
            }
            : tooBigInputInfo;
    }
    return {
        inputCategory: "Textual",
        trimmedValue: trimmedInput,
    };
};
var getOption = function (offset, granularity, intl) {
    var dateCode = granularityIntlCodes[granularity];
    var offsetCode = offset < 0 ? "history" : offset === 0 ? "today" : "future";
    return {
        type: "option",
        value: offset,
        label: intl.formatMessage({ id: "filters.floatingRange.option." + dateCode + ".offset." + offsetCode }, { offset: offset, n: Math.abs(offset) }),
    };
};
var getOptionsForOffsets = function (offsets, granularity, intl) { return offsets.map(function (offset) { return getOption(offset, granularity, intl); }); };
var getDefaultOptions = function (granularity, intl) {
    var optionRange = granularityOffsetLimits[granularity];
    var negativeOptions = getOptionsForOffsets(range(-optionRange, 0), granularity, intl);
    var positiveOptions = getOptionsForOffsets(range(1, optionRange + 1), granularity, intl);
    return __spreadArrays(negativeOptions, [
        { type: "separator" },
        getOption(0, granularity, intl),
        { type: "separator" }
    ], positiveOptions);
};
var getTooBigOptions = function (intl) { return [
    {
        type: "error",
        label: intl.formatMessage({ id: "filters.floatingRange.tooBig" }, { limit: offsetMaxValue }),
    },
]; };
var getNoMatchOptions = function (intl) { return [
    {
        type: "error",
        label: intl.formatMessage({ id: "filters.floatingRange.noMatch" }),
    },
]; };
var getOptionsByNumber = function (offset, granularity, intl) {
    // for positive offsets, show the "ahead" option first
    // to allow power users to use positive numbers for "ahead" and negative for "ago"
    // and doing just -5 -> enter -> 5 -> enter to make the filter from 5 ago to 5 ahead
    var offsets = offset > 0 ? [offset, -offset] : [offset];
    return getOptionsForOffsets(offsets, granularity, intl);
};
var getFullTextOptions = function (offset, granularity, intl) {
    var coreOffsets = [-1, 0, 1];
    var absOffset = Math.abs(offset);
    var offsets = offset !== undefined && absOffset > 1 ? __spreadArrays([-absOffset], coreOffsets, [absOffset]) : coreOffsets;
    return getOptionsForOffsets(offsets, granularity, intl);
};
var getFullTextMatches = function (trimmedInput, offset, granularity, intl) {
    var searchString = trimmedInput.toLowerCase();
    var matches = getFullTextOptions(offset, granularity, intl).filter(function (option) {
        return option.label.toLowerCase().includes(searchString);
    });
    return matches.length > 0 ? matches : getNoMatchOptions(intl);
};
export var findRelativeDateFilterOptionByLabel = function (options, input) {
    var trimmedInput = getTrimmedInput(input);
    return getSelectableItems(options).find(function (option) { return option.label === trimmedInput; });
};
export var findRelativeDateFilterOptionByValue = function (options, value) {
    return getSelectableItems(options).find(function (option) { return option.value === value; });
};
export function getRelativeDateFilterItems(input, granularity, intl) {
    if (input === void 0) { input = ""; }
    if (granularity === void 0) { granularity = DAY; }
    var trimmedInput = getTrimmedInput(input);
    var inputInfo = parseInput(trimmedInput);
    switch (inputInfo.inputCategory) {
        case "Empty":
            return getDefaultOptions(granularity, intl);
        case "TooBig":
            return getTooBigOptions(intl);
        case "Textual":
            return getFullTextMatches(inputInfo.trimmedValue, undefined, granularity, intl);
        case "Numeric": {
            var offset = inputInfo.offset, isOnlyNumber = inputInfo.isOnlyNumber;
            return isOnlyNumber
                ? getOptionsByNumber(offset, granularity, intl)
                : getFullTextMatches(trimmedInput, offset, granularity, intl);
        }
    }
}
//# sourceMappingURL=utils.js.map