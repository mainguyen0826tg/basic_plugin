import { __assign, __extends, __read, __spread } from "tslib";
// (C) 2007-2020 GoodData Corporation
import React, { Component } from "react";
import { FormattedMessage, injectIntl } from "react-intl";
import cx from "classnames";
import keyBy from "lodash/keyBy";
import values from "lodash/values";
import take from "lodash/take";
import has from "lodash/has";
import noop from "lodash/noop";
import { Input } from "../Form";
import LegacyMultiSelectList from "./LegacyMultiSelectList";
import LegacyMultiSelectListItem from "./LegacyMultiSelectListItem";
import { Message } from "../Messages";
import { guidFor } from "./guid";
var NoItemsFound = function () {
    return (React.createElement("div", { className: "gd-list-noResults" },
        React.createElement(FormattedMessage, { id: "gs.list.noItemsFound" })));
};
var LoadingMessage = function () {
    return React.createElement("div", null, "...");
};
var LimitHitWarning = function (_a) {
    var limit = _a.limit, bounce = _a.bounce;
    var classes = cx("gd-list-limitExceeded", {
        "animation-fadeIn": bounce,
    });
    return (React.createElement(Message, { type: "warning", className: classes },
        React.createElement(FormattedMessage, { id: "gs.list.limitExceeded", values: { limit: limit } })));
};
/**
 * @internal
 * @deprecated This component is deprecated use InvertableList instead
 */
var LegacyInvertableList = /** @class */ (function (_super) {
    __extends(LegacyInvertableList, _super);
    function LegacyInvertableList(props) {
        var _this = _super.call(this, props) || this;
        _this.onSelect = function (item) {
            var newSelection = _this.toggleItemInSelection(item);
            if (newSelection.length <= _this.props.maxSelectionSize) {
                _this.notifyUpstreamOfSelectionChange(newSelection);
            }
            if (newSelection.length >= _this.props.maxSelectionSize) {
                // Flash the limit exceeded info
                _this.setState({
                    notifyLimitHit: true,
                });
                // remove the class that causes flashing animation
                setTimeout(function () {
                    _this.setState({
                        notifyLimitHit: false,
                    });
                }, 1000);
            }
        };
        _this.onSelectAll = function () {
            if (_this.props.searchString) {
                if (_this.props.isInverted) {
                    _this.shrinkSelection();
                }
                else {
                    _this.growSelection();
                }
            }
            else {
                _this.props.onSelect([], true);
            }
        };
        _this.onSelectNone = function () {
            if (_this.props.searchString) {
                if (_this.props.isInverted) {
                    _this.growSelection();
                }
                else {
                    _this.shrinkSelection();
                }
            }
            else {
                _this.props.onSelect([], false);
            }
        };
        _this.onSelectOnly = function (item) {
            _this.props.onSelect([item], false);
        };
        // private onSearchChange(searchString: string) {
        //     this.props.onSearch(searchString);
        // }
        _this.onRangeChange = function () {
            var _a;
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            (_a = _this.props).onRangeChange.apply(_a, __spread([_this.props.searchString], args));
        };
        _this.state = {
            notifyLimitHit: false,
        };
        return _this;
    }
    /**
     * Remove selected visible items from selection.
     */
    LegacyInvertableList.prototype.shrinkSelection = function () {
        var _a = this.props, items = _a.items, selection = _a.selection;
        var visibleSelection = this.intersectItems(items, selection);
        var newSelection = this.subtractItems(selection, visibleSelection);
        this.notifyUpstreamOfSelectionChange(newSelection);
    };
    LegacyInvertableList.prototype.intersectItems = function (items, otherItems) {
        var _this = this;
        var otherItemsMap = this.indexByKey(otherItems);
        return items.filter(function (item) {
            var itemKey = _this.props.getItemKey(item);
            return !!otherItemsMap[itemKey];
        });
    };
    LegacyInvertableList.prototype.subtractItems = function (items, otherItems) {
        var _this = this;
        var otherItemsMap = this.indexByKey(otherItems);
        return items.filter(function (item) {
            var itemKey = _this.props.getItemKey(item);
            return !otherItemsMap[itemKey];
        });
    };
    LegacyInvertableList.prototype.indexByKey = function (items) {
        if (items === void 0) { items = []; }
        return keyBy(items, this.props.getItemKey);
    };
    LegacyInvertableList.prototype.toggleItemInSelection = function (item) {
        var selectionMap = this.indexByKey(this.props.selection);
        var itemKey = this.props.getItemKey(item);
        if (selectionMap[itemKey]) {
            delete selectionMap[itemKey];
        }
        else {
            selectionMap[itemKey] = item;
        }
        return values(selectionMap);
    };
    /**
     * Add unselected visible items to the selection until selection size limit is reached.
     */
    LegacyInvertableList.prototype.growSelection = function () {
        var _a = this.props, maxSelectionSize = _a.maxSelectionSize, items = _a.items, selection = _a.selection;
        var selectionSizeLeft = maxSelectionSize - selection.length;
        var selectableItems = this.subtractItems(items, selection);
        var itemsToSelect = take(selectableItems, selectionSizeLeft);
        var newSelection = __spread(selection, itemsToSelect);
        this.notifyUpstreamOfSelectionChange(newSelection);
    };
    /**
     * If change in selection happens to select all or unselect all items it is converted
     * to the respective empty selection.
     */
    LegacyInvertableList.prototype.notifyUpstreamOfSelectionChange = function (newSelection) {
        var _a = this.props, itemsCount = _a.itemsCount, searchString = _a.searchString;
        var isInverted = this.props.isInverted;
        var selection;
        var lastItemSelected = !isInverted && !searchString && newSelection.length === itemsCount;
        if (lastItemSelected) {
            selection = [];
            isInverted = !isInverted;
        }
        else {
            selection = newSelection;
        }
        this.props.onSelect(selection, isInverted);
    };
    LegacyInvertableList.prototype.isItemChecked = function (selectionMap, item) {
        var key = this.props.getItemKey(item);
        var itemInSelection = has(selectionMap, key);
        // in inverted mode selection lists unchecked items
        // in normal mode selection contains checked items
        return this.props.isInverted ? !itemInSelection : itemInSelection;
    };
    LegacyInvertableList.prototype.renderLimitHitWarning = function () {
        var _a = this.props, maxSelectionSize = _a.maxSelectionSize, selection = _a.selection;
        var limitHit = selection.length >= maxSelectionSize;
        if (limitHit) {
            return (React.createElement(this.props.limitHitWarningClass, { limit: maxSelectionSize, bounce: this.state.notifyLimitHit }));
        }
        return null;
    };
    LegacyInvertableList.prototype.renderSearchField = function () {
        return this.props.showSearchField ? (React.createElement(Input, { autofocus: true, className: "gd-list-searchfield gd-flex-item-mobile", clearOnEsc: true, isSearch: true, isSmall: this.props.smallSearch, onChange: this.props.onSearch, placeholder: this.props.searchPlaceholder, value: this.props.searchString })) : null;
    };
    LegacyInvertableList.prototype.renderList = function () {
        return this.props.isLoading ? (this.renderLoading()) : (React.createElement("div", { className: "gd-flex-item-stretch-mobile gd-flex-row-container-mobile" },
            this.renderListOrNoItems(),
            this.renderLimitHitWarning()));
    };
    LegacyInvertableList.prototype.renderListOrNoItems = function () {
        var _a = this.props, items = _a.items, searchString = _a.searchString, filteredItemsCount = _a.filteredItemsCount, height = _a.height, selection = _a.selection;
        if (searchString && filteredItemsCount === 0) {
            return React.createElement(this.props.noItemsFoundClass, { height: height });
        }
        var selectionMap = this.indexByKey(selection);
        var isChecked = this.isItemChecked.bind(this, selectionMap);
        var listProps = __assign(__assign({}, this.props), { itemsCount: filteredItemsCount });
        return (React.createElement(LegacyMultiSelectList, __assign({}, listProps, { onSelect: this.onSelect, onSelectAll: this.onSelectAll, onSelectNone: this.onSelectNone, onSelectOnly: this.onSelectOnly, items: items, isSelected: isChecked, isSearching: !!searchString.length, listItemClass: this.props.listItemClass, onRangeChange: this.onRangeChange, tagName: this.props.tagName })));
    };
    LegacyInvertableList.prototype.renderLoading = function () {
        return React.createElement(this.props.isLoadingClass, { height: this.props.height });
    };
    LegacyInvertableList.prototype.render = function () {
        var _a = this.props, isMobile = _a.isMobile, className = _a.className;
        var classNames = cx(className, {
            "gd-flex-item-stretch-mobile": isMobile,
            "gd-flex-row-container-mobile": isMobile,
        });
        return (React.createElement("div", { className: classNames },
            this.renderSearchField(),
            this.renderList()));
    };
    LegacyInvertableList.defaultProps = {
        actionsAsCheckboxes: false,
        className: undefined,
        getItemKey: guidFor,
        isInverted: true,
        isLoading: false,
        isLoadingClass: LoadingMessage,
        isMobile: false,
        limitHitWarningClass: injectIntl(LimitHitWarning),
        listItemClass: LegacyMultiSelectListItem,
        noItemsFound: false,
        noItemsFoundClass: injectIntl(NoItemsFound),
        onRangeChange: noop,
        onSelect: noop,
        searchPlaceholder: "",
        searchString: "",
        selection: [],
        showSearchField: true,
        smallSearch: false,
        tagName: "",
        selectAllCheckbox: false,
    };
    return LegacyInvertableList;
}(Component));
export { LegacyInvertableList };
/**
 * @internal
 * @deprecated This component is deprecated use InvertableList instead
 */
var LegacyInvertableListWithIntl = injectIntl(LegacyInvertableList);
export default LegacyInvertableListWithIntl;
//# sourceMappingURL=LegacyInvertableList.js.map