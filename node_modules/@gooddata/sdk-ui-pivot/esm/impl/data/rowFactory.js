import { __assign } from "tslib";
import { ROW_SUBTOTAL, ROW_TOTAL } from "../base/constants";
import { isResultAttributeHeader, isResultTotalHeader, } from "@gooddata/sdk-backend-spi";
import invariant from "ts-invariant";
import { isSeriesCol } from "../structure/tableDescriptorTypes";
import { getSubtotalStyles } from "./dataSourceUtils";
import fill from "lodash/fill";
import findIndex from "lodash/findIndex";
function getSubtotalLabelCellIndex(resultHeaderItems, rowIndex) {
    return findIndex(resultHeaderItems, function (headerItem) { return isResultTotalHeader(headerItem[rowIndex]); });
}
function getMinimalRowData(dv) {
    var data = dv.rawData().twoDimData();
    var rowHeaders = dv.meta().allHeaders()[0];
    var numberOfRowHeaderItems = (rowHeaders[0] || []).length;
    return data.length > 0
        ? data
        : // if there are no measures only attributes
            // create array of [null] of length equal to the number of row dimension headerItems
            fill(Array(numberOfRowHeaderItems), [null]);
}
function getCell(rowHeaderData, rowIndex, rowHeader, rowHeaderIndex, intl) {
    var rowHeaderDataItem = rowHeaderData[rowHeaderIndex][rowIndex];
    var cell = {
        field: rowHeader.id,
        rowHeaderDataItem: rowHeaderDataItem,
        isSubtotal: false,
    };
    if (isResultAttributeHeader(rowHeaderDataItem)) {
        return __assign(__assign({}, cell), { value: rowHeaderDataItem.attributeHeaderItem.name });
    }
    if (isResultTotalHeader(rowHeaderDataItem)) {
        var totalName = rowHeaderDataItem.totalHeaderItem.name;
        return __assign(__assign({}, cell), { isSubtotal: true, value: getSubtotalLabelCellIndex(rowHeaderData, rowIndex) === rowHeaderIndex
                ? intl.formatMessage({ id: "visualizations.totals.dropdown.title." + totalName })
                : null });
    }
    invariant(rowHeaderDataItem, "row header is not of type IResultAttributeHeaderItem or IResultTotalHeaderItem");
}
export function getRow(tableDescriptor, cellData, rowIndex, rowHeaderData, subtotalStyles, intl) {
    var row = {
        headerItemMap: {},
    };
    tableDescriptor.headers.sliceCols.forEach(function (rowHeader, rowHeaderIndex) {
        var _a;
        var _b = getCell(rowHeaderData, rowIndex, rowHeader, rowHeaderIndex, intl), isSubtotal = _b.isSubtotal, field = _b.field, value = _b.value, rowHeaderDataItem = _b.rowHeaderDataItem;
        if (isSubtotal) {
            row.type = ROW_SUBTOTAL;
            if (!row.subtotalStyle) {
                row.subtotalStyle = (_a = subtotalStyles[rowHeaderIndex]) !== null && _a !== void 0 ? _a : undefined;
            }
        }
        row[field] = value;
        row.headerItemMap[field] = rowHeaderDataItem;
    });
    if (!tableDescriptor.hasDataLeafCols()) {
        // table has no leaf columns - it is a row-only table listing a bunch of
        // attribute element values. no point in going further as there is no additional
        // data to show
        return row;
    }
    cellData.forEach(function (cell, cellIndex) {
        var colId = tableDescriptor.headers.leafDataCols[cellIndex].id;
        invariant(colId);
        row[colId] = cell;
    });
    return row;
}
export function getRowTotals(tableDescriptor, dv, intl) {
    if (!dv.rawData().hasTotals()) {
        return null;
    }
    var totals = dv.rawData().totals();
    invariant(totals && totals.length > 0);
    var colGrandTotals = totals[0];
    var colGrandTotalDefs = dv.definition.dimensions[0].totals;
    invariant(colGrandTotalDefs);
    var grandTotalColDescriptor = tableDescriptor.getGrandTotalCol();
    var grandTotalAttrDescriptor = grandTotalColDescriptor.attributeDescriptor;
    var leafColumns = tableDescriptor.zippedLeaves;
    return colGrandTotals.map(function (totalsPerLeafColumn, totalIdx) {
        var _a;
        var grandTotalName = grandTotalColDescriptor.effectiveTotals[totalIdx].totalHeaderItem.name;
        var measureCells = {};
        var calculatedForColumns = [];
        var calculatedForMeasures = colGrandTotalDefs
            .filter(function (total) {
            return (grandTotalName === total.type &&
                total.attributeIdentifier === grandTotalAttrDescriptor.attributeHeader.localIdentifier);
        })
            .map(function (total) { return total.measureIdentifier; });
        totalsPerLeafColumn.forEach(function (value, idx) {
            var leafDescriptor = leafColumns[idx][0];
            // if code bombs here then there must be something wrong in the table / datasource code because
            // totals cannot (by definition) appear in a table that does not have measures - yet here we are
            // processing totals
            invariant(isSeriesCol(leafDescriptor));
            measureCells[leafDescriptor.id] = value;
            if (calculatedForMeasures.indexOf(leafDescriptor.seriesDescriptor.measureDescriptor.measureHeaderItem.localIdentifier) > -1) {
                calculatedForColumns.push(leafDescriptor.id);
            }
        });
        return __assign(__assign({ colSpan: {
                count: tableDescriptor.sliceColCount(),
                headerKey: grandTotalColDescriptor.id,
            } }, measureCells), (_a = {}, _a[grandTotalColDescriptor.id] = intl.formatMessage({
            id: "visualizations.totals.dropdown.title." + grandTotalName,
        }), _a.calculatedForColumns = calculatedForColumns, _a.type = ROW_TOTAL, _a));
    });
}
/**
 * Given data view with a page of data and a table descriptor, this factory function creates page for consumption
 * by ag-grid.
 *
 * @param dv - data view with data to process (OK if its empty and has no data)
 * @param tableDescriptor - table descriptor
 * @param intl - intl bundle to get localized subtotal names
 */
export function createAgGridPage(dv, tableDescriptor, intl) {
    var headerItems = dv.meta().allHeaders();
    var dimensions = dv.definition.dimensions;
    var minimalRowData = getMinimalRowData(dv);
    var subtotalStyles = getSubtotalStyles(dimensions === null || dimensions === void 0 ? void 0 : dimensions[0]);
    var rowData = minimalRowData.map(function (dataRow, dataRowIndex) {
        return getRow(tableDescriptor, dataRow, dataRowIndex, headerItems[0], subtotalStyles, intl);
    });
    var rowTotals = getRowTotals(tableDescriptor, dv, intl);
    return {
        rowData: rowData,
        rowTotals: rowTotals,
    };
}
//# sourceMappingURL=rowFactory.js.map