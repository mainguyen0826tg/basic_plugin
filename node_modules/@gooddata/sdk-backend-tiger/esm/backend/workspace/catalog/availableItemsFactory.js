import { __assign, __awaiter, __generator, __spreadArrays } from "tslib";
// (C) 2019-2021 GoodData Corporation
import { isCatalogAttribute, isCatalogFact, isCatalogMeasure, } from "@gooddata/sdk-backend-spi";
import { insightMeasures, insightAttributes, isAttribute, isFilter, isMeasure, insightFilters, areObjRefsEqual, } from "@gooddata/sdk-model";
import { AfmValidObjectsQueryTypesEnum } from "@gooddata/api-client-tiger";
import intersectionWith from "lodash/intersectionWith";
import uniq from "lodash/uniq";
import { TigerWorkspaceCatalogWithAvailableItems } from "./catalogWithAvailableItems";
import { convertMeasure } from "../../../convertors/toBackend/afm/MeasureConverter";
import { convertAttribute } from "../../../convertors/toBackend/afm/AttributeConverter";
import { jsonApiIdToObjRef } from "../../../convertors/fromBackend/ObjRefConverter";
import { InvariantError } from "ts-invariant";
import { convertAfmFilters } from "../../../convertors/toBackend/afm/AfmFiltersConverter";
var typesMatching = {
    attribute: AfmValidObjectsQueryTypesEnum.Attributes,
    fact: AfmValidObjectsQueryTypesEnum.Facts,
    measure: AfmValidObjectsQueryTypesEnum.Measures,
};
var mapToTigerType = function (type) {
    var _a;
    return (_a = typesMatching[type]) !== null && _a !== void 0 ? _a : AfmValidObjectsQueryTypesEnum.UNRECOGNIZED;
};
/**
 * Converts a type T to type U that affects availability of items of type T in tiger.
 * @param type - type to convert
 */
var mapToTigerRestrictingType = function (type) {
    if (type === "dateDataset") {
        // date datasets' availability is restricted by their attributes' availability in tiger
        return "attribute";
    }
    return type;
};
var getRestrictingTypes = function (requested) {
    return uniq(requested.map(mapToTigerRestrictingType));
};
var catalogItemRefs = function (item) {
    return isCatalogAttribute(item)
        ? [item.attribute.ref]
        : isCatalogFact(item)
            ? [item.fact.ref]
            : isCatalogMeasure(item)
                ? [item.measure.ref]
                : item.dateAttributes.map(function (attr) { return attr.attribute.ref; });
};
var TigerWorkspaceCatalogAvailableItemsFactory = /** @class */ (function () {
    function TigerWorkspaceCatalogAvailableItemsFactory(authCall, workspace, groups, items, options) {
        if (options === void 0) { options = {
            types: ["attribute", "measure", "fact", "dateDataset"],
            excludeTags: [],
            includeTags: [],
        }; }
        this.authCall = authCall;
        this.workspace = workspace;
        this.groups = groups;
        this.items = items;
        this.options = options;
    }
    TigerWorkspaceCatalogAvailableItemsFactory.prototype.withOptions = function (options) {
        var newOptions = __assign(__assign({}, this.options), options);
        return new TigerWorkspaceCatalogAvailableItemsFactory(this.authCall, this.workspace, this.groups, this.items, newOptions);
    };
    TigerWorkspaceCatalogAvailableItemsFactory.prototype.forDataset = function (dataset) {
        return this.withOptions({ dataset: dataset });
    };
    TigerWorkspaceCatalogAvailableItemsFactory.prototype.forTypes = function (types) {
        return this.withOptions({ types: types });
    };
    TigerWorkspaceCatalogAvailableItemsFactory.prototype.includeTags = function (tags) {
        return this.withOptions({ includeTags: tags });
    };
    TigerWorkspaceCatalogAvailableItemsFactory.prototype.excludeTags = function (tags) {
        return this.withOptions({ excludeTags: tags });
    };
    TigerWorkspaceCatalogAvailableItemsFactory.prototype.forItems = function (items) {
        return this.withOptions({ items: items });
    };
    TigerWorkspaceCatalogAvailableItemsFactory.prototype.forInsight = function (insight) {
        return this.withOptions({ insight: insight });
    };
    TigerWorkspaceCatalogAvailableItemsFactory.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, _b, items, insight, types, relevantRestrictingTypes, relevantItems, attributes, measures, filters, _c, afmFilters, auxMeasures, afmValidObjectsQuery, availableItemsResponse, availableObjRefs, availableItems;
            var _this = this;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        _a = this.options, _b = _a.items, items = _b === void 0 ? [] : _b, insight = _a.insight, types = _a.types;
                        if (items.length === 0 && !insight) {
                            throw new InvariantError("No items or insight was specified!");
                        }
                        relevantRestrictingTypes = getRestrictingTypes(types);
                        relevantItems = insight
                            ? __spreadArrays(insightMeasures(insight), insightAttributes(insight), insightFilters(insight)) : items;
                        attributes = relevantItems.filter(isAttribute);
                        measures = relevantItems.filter(isMeasure);
                        filters = relevantItems.filter(isFilter);
                        _c = convertAfmFilters(attributes, measures, filters), afmFilters = _c.filters, auxMeasures = _c.auxMeasures;
                        afmValidObjectsQuery = {
                            types: relevantRestrictingTypes.map(mapToTigerType),
                            afm: {
                                attributes: attributes.map(convertAttribute),
                                measures: measures.map(convertMeasure),
                                filters: afmFilters,
                                auxMeasures: auxMeasures,
                            },
                        };
                        return [4 /*yield*/, this.authCall(function (client) {
                                return client.validObjects.computeValidObjects({
                                    workspaceId: _this.workspace,
                                    afmValidObjectsQuery: afmValidObjectsQuery,
                                });
                            })];
                    case 1:
                        availableItemsResponse = _d.sent();
                        availableObjRefs = availableItemsResponse.data.items.map(jsonApiIdToObjRef);
                        availableItems = filterAvailableItems(availableObjRefs, this.items);
                        return [2 /*return*/, new TigerWorkspaceCatalogWithAvailableItems(this.groups, this.items, availableItems)];
                }
            });
        });
    };
    return TigerWorkspaceCatalogAvailableItemsFactory;
}());
export { TigerWorkspaceCatalogAvailableItemsFactory };
/**
 * @internal
 */
export function filterAvailableItems(refs, items) {
    return items.filter(function (item) {
        var itemRefs = catalogItemRefs(item);
        return intersectionWith(refs, itemRefs, areObjRefsEqual).length > 0;
    });
}
//# sourceMappingURL=availableItemsFactory.js.map