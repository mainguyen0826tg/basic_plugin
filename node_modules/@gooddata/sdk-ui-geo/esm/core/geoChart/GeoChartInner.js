import { __assign, __extends, __spreadArrays } from "tslib";
// (C) 2020 GoodData Corporation
import React from "react";
import cx from "classnames";
import throttle from "lodash/throttle";
import noop from "lodash/noop";
import invariant from "ts-invariant";
import Measure from "react-measure";
import { v4 } from "uuid";
import GeoChartRenderer from "./GeoChartRenderer";
import GeoChartLegendRenderer from "./GeoChartLegendRenderer";
import { getAvailableLegends } from "./helpers/geoChart/data";
import { IntlWrapper, IntlTranslationsProvider, convertDrillableItemsToPredicates, } from "@gooddata/sdk-ui";
import { getLegendDetails as getCommonVisLegendDetails, LegendPosition, shouldShowFluid, SupportedLegendPositions, } from "@gooddata/sdk-ui-vis-commons";
import { isColorAssignmentItemChanged, isFluidLegendEnabled } from "./helpers/geoChart/common";
import { getResponsiveInfo, isAutoPositionWithPopup } from "./helpers/geoChart/responsive";
function renderChart(props) {
    return React.createElement(GeoChartRenderer, __assign({}, props));
}
function renderLegend(props) {
    return (React.createElement(IntlWrapper, { locale: props.locale },
        React.createElement(IntlTranslationsProvider, null, function (translationProps) { return (React.createElement(GeoChartLegendRenderer, __assign({}, props, { numericSymbols: translationProps.numericSymbols }))); })));
}
var DefaultGeoConfig = {
    mapboxToken: ""
};
/**
 * Geo Chart react component
 */
var GeoChartInner = /** @class */ (function (_super) {
    __extends(GeoChartInner, _super);
    function GeoChartInner(props) {
        var _this = _super.call(this, props) || this;
        _this.containerId = "geo-" + v4();
        _this.onLegendItemClick = function (item) {
            var enabledLegendItems = _this.state.enabledLegendItems.map(function (legendItem, index) {
                if (index === item.legendIndex) {
                    return !legendItem;
                }
                return legendItem;
            });
            _this.setState({ enabledLegendItems: enabledLegendItems });
        };
        _this.renderChart = function (geoChartOptions) {
            var _a = _this.props.chartRenderer, chartRenderer = _a === void 0 ? renderChart : _a;
            var chartProps = _this.getChartProps(geoChartOptions);
            return chartRenderer(chartProps);
        };
        _this.renderLegend = function (height, position, geoChartOptions, contentRect) {
            var _a, _b, _c;
            var enabled = (_c = (_b = (_a = _this.props.config) === null || _a === void 0 ? void 0 : _a.legend) === null || _b === void 0 ? void 0 : _b.enabled) !== null && _c !== void 0 ? _c : true;
            var _d = _this.props.legendRenderer, legendRenderer = _d === void 0 ? renderLegend : _d;
            if (!enabled) {
                return null;
            }
            var legendProps = _this.getLegendProps(height, position, geoChartOptions, contentRect);
            return legendRenderer(legendProps);
        };
        _this.onWindowResize = function () {
            var _a = _this.props.documentObj, documentObj = _a === void 0 ? document : _a;
            _this.setState({
                showFluidLegend: shouldShowFluid(documentObj)
            });
        };
        var _a = _this.props.documentObj, documentObj = _a === void 0 ? document : _a;
        _this.state = {
            enabledLegendItems: [],
            showFluidLegend: shouldShowFluid(documentObj),
            colorAssignmentItem: []
        };
        _this.throttledOnWindowResize = throttle(_this.onWindowResize, 100);
        return _this;
    }
    GeoChartInner.getDerivedStateFromProps = function (nextProps, prevState) {
        var geoChartOptions = nextProps.geoChartOptions;
        if (!geoChartOptions) {
            return null;
        }
        var categoryItems = geoChartOptions.categoryItems, colorStrategy = geoChartOptions.colorStrategy;
        var colorAssignmentItem = colorStrategy.getColorAssignment();
        if (!isColorAssignmentItemChanged(prevState.colorAssignmentItem, colorAssignmentItem)) {
            return null;
        }
        return {
            enabledLegendItems: new Array(categoryItems.length).fill(true),
            colorAssignmentItem: colorAssignmentItem
        };
    };
    GeoChartInner.prototype.componentDidMount = function () {
        this.updateConfigurationPanel(this.props.geoChartOptions);
        window.addEventListener("resize", this.throttledOnWindowResize);
    };
    GeoChartInner.prototype.componentDidUpdate = function () {
        this.updateConfigurationPanel(this.props.geoChartOptions);
    };
    GeoChartInner.prototype.componentWillUnmount = function () {
        this.throttledOnWindowResize.cancel();
        window.removeEventListener("resize", this.throttledOnWindowResize);
    };
    GeoChartInner.prototype.render = function () {
        var _this = this;
        var _a;
        var _b = this.props, height = _b.height, config = _b.config;
        if (height !== undefined && !isAutoPositionWithPopup((_a = config === null || config === void 0 ? void 0 : config.legend) === null || _a === void 0 ? void 0 : _a.responsive)) {
            return this.renderVisualizationContent(undefined, height);
        }
        return (React.createElement(Measure, { client: true }, function (_a) {
            var _b;
            var measureRef = _a.measureRef, contentRect = _a.contentRect;
            var contentRectClient = contentRect.client;
            return _this.renderVisualizationContent(measureRef, (_b = (contentRectClient && contentRectClient.height)) !== null && _b !== void 0 ? _b : 0, contentRect);
        }));
    };
    GeoChartInner.prototype.renderVisualizationContent = function (measureRef, height, contentRect) {
        var geoChartOptionsProp = this.props.geoChartOptions;
        var geoChartOptions = this.syncWithLegendItemStates(geoChartOptionsProp);
        var legendDetails = this.getLegendDetails(this.getLegendPosition(), contentRect);
        var position = legendDetails ? legendDetails.position : LegendPosition.TOP;
        var classes = this.getContainerClassName(position);
        var isLegendRenderedFirst = position === LegendPosition.TOP ||
            (position === LegendPosition.LEFT && !this.state.showFluidLegend);
        var legendComponent = this.renderLegend(height, position, geoChartOptions, contentRect);
        return (React.createElement("div", { className: classes, ref: measureRef },
            isLegendRenderedFirst && legendComponent,
            this.renderChart(geoChartOptions),
            !isLegendRenderedFirst && legendComponent));
    };
    GeoChartInner.prototype.syncWithLegendItemStates = function (geoChartOptions) {
        invariant(geoChartOptions, "illegal state - trying to sync legend with no geo options");
        var categoryItems = geoChartOptions.categoryItems;
        var enabledLegendItems = this.state.enabledLegendItems;
        var withLegendItemStates = categoryItems.map(function (item, index) { return (__assign(__assign({}, item), { isVisible: enabledLegendItems[index] })); });
        return __assign(__assign({}, geoChartOptions), { categoryItems: withLegendItemStates });
    };
    GeoChartInner.prototype.getContainerClassName = function (position) {
        var _a;
        var _b, _c, _d;
        var responsive = getResponsiveInfo((_d = (_c = (_b = this.props) === null || _b === void 0 ? void 0 : _b.config) === null || _c === void 0 ? void 0 : _c.legend) === null || _d === void 0 ? void 0 : _d.responsive) === true;
        var flexDirection = this.getFlexDirection(position);
        return cx("viz-line-family-chart-wrap", "gd-geo-component", "s-gd-geo-component", (_a = {
                "responsive-legend": responsive,
                "non-responsive-legend": !responsive
            },
            _a["flex-direction-" + flexDirection] = true,
            _a["legend-position-bottom"] = position === LegendPosition.BOTTOM,
            _a), this.containerId);
    };
    GeoChartInner.prototype.getFlexDirection = function (position) {
        var isFluidLegend = this.isFluidLegend();
        if (position === LegendPosition.TOP || position === LegendPosition.BOTTOM || isFluidLegend) {
            return "column";
        }
        return "row";
    };
    GeoChartInner.prototype.isFluidLegend = function () {
        var _a, _b, _c;
        var showFluidLegend = this.state.showFluidLegend;
        var responsive = getResponsiveInfo((_c = (_b = (_a = this.props) === null || _a === void 0 ? void 0 : _a.config) === null || _b === void 0 ? void 0 : _b.legend) === null || _c === void 0 ? void 0 : _c.responsive);
        return isAutoPositionWithPopup(responsive)
            ? false
            : isFluidLegendEnabled(responsive, showFluidLegend);
    };
    GeoChartInner.prototype.getLegendPosition = function () {
        var _a, _b, _c;
        var position = (_c = (_b = (_a = this.props.config) === null || _a === void 0 ? void 0 : _a.legend) === null || _b === void 0 ? void 0 : _b.position) !== null && _c !== void 0 ? _c : LegendPosition.TOP;
        var isSupportedLegend = SupportedLegendPositions.indexOf(position) > -1;
        return isSupportedLegend ? position : LegendPosition.TOP;
    };
    GeoChartInner.prototype.getLegendDetails = function (position, contentRect) {
        var _a, _b;
        var _c = this.props, geoChartOptionsProp = _c.geoChartOptions, config = _c.config;
        var geoChartOptions = this.syncWithLegendItemStates(geoChartOptionsProp);
        var geoData = geoChartOptions.geoData;
        var legendLabel = (_a = geoData === null || geoData === void 0 ? void 0 : geoData.segment) === null || _a === void 0 ? void 0 : _a.name;
        var isFluidLegend = this.isFluidLegend();
        var legendDetailOptions = {
            showFluidLegend: isFluidLegend,
            contentRect: contentRect,
            legendLabel: legendLabel
        };
        return getCommonVisLegendDetails(position, getResponsiveInfo((_b = config === null || config === void 0 ? void 0 : config.legend) === null || _b === void 0 ? void 0 : _b.responsive), legendDetailOptions);
    };
    GeoChartInner.prototype.getLegendProps = function (height, position, geoChartOptions, contentRect) {
        var _a, _b, _c, _d;
        var responsive = (_b = (_a = this.props.config) === null || _a === void 0 ? void 0 : _a.legend) === null || _b === void 0 ? void 0 : _b.responsive;
        var locale = this.props.locale;
        var enabledLegendItems = this.state.enabledLegendItems;
        var isFluidLegend = this.isFluidLegend();
        var geoData = geoChartOptions.geoData, colorStrategy = geoChartOptions.colorStrategy, categoryItems = geoChartOptions.categoryItems;
        var segment = geoData.segment;
        var colorFormat = (_c = geoData.color) === null || _c === void 0 ? void 0 : _c.format;
        var sizeFormat = (_d = geoData.size) === null || _d === void 0 ? void 0 : _d.format;
        var propsFromData = {
            format: colorFormat || sizeFormat,
            geoData: geoData
        };
        var colorLegendValue = colorStrategy.getColorByIndex(0);
        var legendDetails = this.getLegendDetails(position, contentRect);
        var legendProps = {
            height: height,
            locale: locale,
            position: position,
            responsive: responsive,
            isFluidLegend: isFluidLegend,
            onItemClick: this.onLegendItemClick,
            contentRect: contentRect,
            containerId: this.containerId
        };
        if (legendDetails) {
            legendProps = __assign(__assign({}, legendProps), { maxRows: legendDetails.maxRows, name: legendDetails.name, renderPopUp: legendDetails.renderPopUp });
        }
        if (segment && enabledLegendItems.length) {
            return __assign(__assign(__assign({}, legendProps), propsFromData), { categoryItems: categoryItems,
                colorLegendValue: colorLegendValue });
        }
        return __assign(__assign(__assign({}, legendProps), propsFromData), { colorLegendValue: colorLegendValue });
    };
    GeoChartInner.prototype.getChartProps = function (geoChartOptions) {
        var _a;
        var _b = this.props, _c = _b.config, config = _c === void 0 ? DefaultGeoConfig : _c, dataView = _b.dataView, _d = _b.drillableItems, drillableItems = _d === void 0 ? [] : _d, _e = _b.afterRender, afterRender = _e === void 0 ? noop : _e, _f = _b.onCenterPositionChanged, onCenterPositionChanged = _f === void 0 ? noop : _f, _g = _b.onDrill, onDrill = _g === void 0 ? noop : _g, _h = _b.onZoomChanged, onZoomChanged = _h === void 0 ? noop : _h, intl = _b.intl;
        invariant(dataView, "invalid state - trying to render geo chart but there is no data to visualize");
        var geoData = geoChartOptions.geoData, colorStrategy = geoChartOptions.colorStrategy, categoryItems = geoChartOptions.categoryItems;
        var segmentIndex = (_a = geoChartOptions.geoData.segment) === null || _a === void 0 ? void 0 : _a.index;
        var drillablePredicates = convertDrillableItemsToPredicates(drillableItems);
        var drillConfig = { dataView: dataView, onDrill: onDrill };
        var chartProps = {
            colorStrategy: colorStrategy,
            config: config,
            dataView: dataView,
            drillableItems: drillablePredicates,
            drillConfig: drillConfig,
            afterRender: afterRender,
            geoData: geoData,
            onCenterPositionChanged: onCenterPositionChanged,
            onZoomChanged: onZoomChanged,
            intl: intl
        };
        if (segmentIndex) {
            var selectedSegmentItems = categoryItems.reduce(function (result, item) {
                if (item.isVisible) {
                    return __spreadArrays(result, [item.uri]);
                }
                return result;
            }, []);
            return __assign(__assign({}, chartProps), { config: __assign(__assign({}, config), { selectedSegmentItems: selectedSegmentItems }) });
        }
        return chartProps;
    };
    GeoChartInner.prototype.updateConfigurationPanel = function (geoChartOptions) {
        invariant(geoChartOptions, "illegal state - updating config with no geo options");
        var pushData = this.props.pushData;
        var _a = geoChartOptions, categoryItems = _a.categoryItems, geoData = _a.geoData, colorStrategy = _a.colorStrategy, colorPalette = _a.colorPalette;
        var _b = getAvailableLegends(categoryItems, geoData), hasCategoryLegend = _b.hasCategoryLegend, hasColorLegend = _b.hasColorLegend, hasSizeLegend = _b.hasSizeLegend;
        var isLegendVisible = hasCategoryLegend || hasColorLegend || hasSizeLegend;
        pushData === null || pushData === void 0 ? void 0 : pushData({
            propertiesMeta: {
                // toggle legend section
                legend_enabled: isLegendVisible
            },
            colors: {
                colorAssignments: colorStrategy.getColorAssignment(),
                colorPalette: colorPalette
            }
        });
    };
    return GeoChartInner;
}(React.PureComponent));
export { GeoChartInner };
//# sourceMappingURL=GeoChartInner.js.map