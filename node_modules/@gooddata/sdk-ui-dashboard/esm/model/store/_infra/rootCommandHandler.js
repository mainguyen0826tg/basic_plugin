import { __generator } from "tslib";
import { actionChannel, call, take } from "redux-saga/effects";
import noop from "lodash/noop";
import { dispatchDashboardEvent } from "./eventDispatcher";
import { commandRejected, dashboardCommandStarted, internalErrorOccurred, isDashboardCommandFailed, } from "../../events/general";
import { isDashboardEvent } from "../../events/base";
import { DefaultCommandHandlers } from "../../commandHandlers";
import { getDashboardContext } from "./contexts";
function unhandledCommand(ctx, cmd) {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, dispatchDashboardEvent(commandRejected(ctx, cmd.correlationId))];
            case 1:
                _a.sent();
                return [2 /*return*/];
        }
    });
}
/**
 * @internal
 */
export var CommandEnvelopeActionPrefix = "__C";
export function commandEnvelope(command, eventHandlers) {
    var _a, _b, _c;
    return {
        type: CommandEnvelopeActionPrefix + "(" + command.type + ")",
        command: command,
        onError: (_a = eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.onError) !== null && _a !== void 0 ? _a : noop,
        onStart: (_b = eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.onStart) !== null && _b !== void 0 ? _b : noop,
        onSuccess: (_c = eventHandlers === null || eventHandlers === void 0 ? void 0 : eventHandlers.onSuccess) !== null && _c !== void 0 ? _c : noop,
    };
}
/**
 * @internal
 */
export function commandEnvelopeWithPromise(command) {
    var commandEnvelopeEventHandlers = {};
    var promise = new Promise(function (resolve, reject) {
        commandEnvelopeEventHandlers.onSuccess = resolve;
        commandEnvelopeEventHandlers.onError = reject;
    });
    var envelope = commandEnvelope(command, commandEnvelopeEventHandlers);
    return {
        promise: promise,
        envelope: envelope,
    };
}
function isCommandEnvelope(obj) {
    return !!obj && obj.type.startsWith(CommandEnvelopeActionPrefix);
}
function ensureCommandWrappedInEnvelope(action) {
    return isCommandEnvelope(action) ? action : commandEnvelope(action);
}
function processCommand(ctx, envelope) {
    var command, _a, type, correlationId, correlationIdForLog, commandHandler, result, e_1;
    var _b;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0:
                command = envelope.command, _a = envelope.command, type = _a.type, correlationId = _a.correlationId;
                correlationIdForLog = correlationId !== null && correlationId !== void 0 ? correlationId : "(no correlationId provided)";
                commandHandler = (_b = DefaultCommandHandlers[envelope.command.type]) !== null && _b !== void 0 ? _b : unhandledCommand;
                _c.label = 1;
            case 1:
                _c.trys.push([1, 6, , 11]);
                return [4 /*yield*/, dispatchDashboardEvent(dashboardCommandStarted(ctx, envelope.command))];
            case 2:
                _c.sent();
                try {
                    envelope.onStart(command);
                }
                catch (e) {
                    // eslint-disable-next-line no-console
                    console.warn("An error has occurred while calling onStart function provided for " + type + "@" + correlationIdForLog + " processing:", e);
                }
                return [4 /*yield*/, call(commandHandler, ctx, command)];
            case 3:
                result = _c.sent();
                if (!isDashboardEvent(result)) return [3 /*break*/, 5];
                return [4 /*yield*/, dispatchDashboardEvent(result)];
            case 4:
                _c.sent();
                _c.label = 5;
            case 5:
                try {
                    envelope.onSuccess(result);
                }
                catch (e) {
                    // eslint-disable-next-line no-console
                    console.warn("An error has occurred while calling onSuccess function provided for " + type + "@" + correlationIdForLog + " processing", e);
                }
                return [3 /*break*/, 11];
            case 6:
                e_1 = _c.sent();
                try {
                    envelope.onError(e_1);
                }
                catch (ne) {
                    // eslint-disable-next-line no-console
                    console.warn("An error has occurred while calling onError function provided for " + type + "@" + correlationIdForLog + " processing:", ne);
                }
                if (!isDashboardCommandFailed(e_1)) return [3 /*break*/, 8];
                return [4 /*yield*/, dispatchDashboardEvent(e_1)];
            case 7:
                _c.sent();
                return [3 /*break*/, 10];
            case 8: 
            // Errors during command handling should be caught and addressed in the handler, possibly with a
            // more meaningful error message. If the error bubbles up to here then there are holes in error
            // handling or something is seriously messed up.
            return [4 /*yield*/, dispatchDashboardEvent(internalErrorOccurred(ctx, command, "Internal error has occurred while handling " + type, e_1))];
            case 9:
                // Errors during command handling should be caught and addressed in the handler, possibly with a
                // more meaningful error message. If the error bubbles up to here then there are holes in error
                // handling or something is seriously messed up.
                _c.sent();
                _c.label = 10;
            case 10: return [3 /*break*/, 11];
            case 11: return [2 /*return*/];
        }
    });
}
/**
 * Root command handler is the central point through which all command processing is done. The handler registers
 * for all actions starting with `GDC.DASH/CMD` === all dashboard commands.
 *
 * The commands are intended for serial processing, without any forking. A buffering action channel is in place to
 * prevent loss of commands.
 *
 * TODO: refactor this so that root command handler is created dynamically similar to query processor. the handlers
 *  should be providable by the caller
 */
export function rootCommandHandler() {
    var commandChannel, command, envelope, ctx;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, actionChannel(function (action) {
                    return action.type &&
                        (action.type.startsWith(CommandEnvelopeActionPrefix) || action.type.startsWith("GDC.DASH/CMD"));
                })];
            case 1:
                commandChannel = _a.sent();
                _a.label = 2;
            case 2:
                if (!true) return [3 /*break*/, 6];
                return [4 /*yield*/, take(commandChannel)];
            case 3:
                command = _a.sent();
                envelope = ensureCommandWrappedInEnvelope(command);
                return [4 /*yield*/, call(getDashboardContext)];
            case 4:
                ctx = _a.sent();
                return [4 /*yield*/, call(processCommand, ctx, envelope)];
            case 5:
                _a.sent();
                return [3 /*break*/, 2];
            case 6: return [2 /*return*/];
        }
    });
}
//# sourceMappingURL=rootCommandHandler.js.map