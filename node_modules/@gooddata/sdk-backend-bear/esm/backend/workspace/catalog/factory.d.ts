import { CatalogItemType, IWorkspaceCatalogFactory, IWorkspaceCatalogFactoryOptions } from "@gooddata/sdk-backend-spi";
import { ObjRef } from "@gooddata/sdk-model";
import { BearAuthenticatedCallGuard } from "../../../types/auth";
import { BearWorkspaceCatalog } from "./catalog";
export declare class BearWorkspaceCatalogFactory implements IWorkspaceCatalogFactory {
    private readonly authCall;
    readonly workspace: string;
    readonly options: IWorkspaceCatalogFactoryOptions;
    private tagsAndDatasetIdsPromise;
    constructor(authCall: BearAuthenticatedCallGuard, workspace: string, options?: IWorkspaceCatalogFactoryOptions);
    withOptions(options: Partial<IWorkspaceCatalogFactoryOptions>): IWorkspaceCatalogFactory;
    forDataset(dataset: ObjRef): IWorkspaceCatalogFactory;
    forTypes(types: CatalogItemType[]): IWorkspaceCatalogFactory;
    includeTags(tags: ObjRef[]): IWorkspaceCatalogFactory;
    excludeTags(tags: ObjRef[]): IWorkspaceCatalogFactory;
    load(): Promise<BearWorkspaceCatalog>;
    private loadAllCatalogItemsAndMappings;
    private loadDateDatasets;
    private loadBearCatalogItems;
    /**
     * Loads unlisted metrics using /query resource. This is a shortcoming of the current
     * catalog items implementation. The unlisted items do not come back in /items resource - however,
     * they are needed to augment existing insights with metadata measures that MAY be unlisted.
     *
     * Previously, AD used to ignore catalog items when augmenting insights with bucket item metadata - instead
     * it was fetching the items as it found them. Now we try to position catalog as a single source of truth
     * and use just the catalog items for everything.
     */
    private loadBearUnlistedMetrics;
    private loadBearDisplayFormsAndAttributes;
    private loadCatalogGroups;
    private getTagsAndDatasetIds;
    private withUpdatedUnlistedFlag;
}
//# sourceMappingURL=factory.d.ts.map