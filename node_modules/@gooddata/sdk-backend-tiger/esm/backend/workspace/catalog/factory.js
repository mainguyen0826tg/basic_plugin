import { __assign, __awaiter, __generator } from "tslib";
// (C) 2019-2021 GoodData Corporation
import { isCatalogAttribute, isCatalogFact, isCatalogMeasure, } from "@gooddata/sdk-backend-spi";
import { isUriRef } from "@gooddata/sdk-model";
import { convertFact, convertMeasure } from "../../../convertors/fromBackend/CatalogConverter";
import { TigerWorkspaceCatalog } from "./catalog";
import { loadAttributesAndDateDatasets } from "./datasetLoader";
import flatten from "lodash/flatten";
import flatMap from "lodash/flatMap";
import uniqBy from "lodash/uniqBy";
import sortBy from "lodash/sortBy";
import { MetadataUtilities, ValidateRelationsHeader } from "@gooddata/api-client-tiger";
import invariant from "ts-invariant";
var TigerWorkspaceCatalogFactory = /** @class */ (function () {
    function TigerWorkspaceCatalogFactory(authCall, workspace, options) {
        var _this = this;
        if (options === void 0) { options = {
            types: ["attribute", "measure", "fact", "dateDataset"],
            excludeTags: [],
            includeTags: [],
        }; }
        this.authCall = authCall;
        this.workspace = workspace;
        this.options = options;
        this.withOptions = function (options) {
            var newOptions = __assign(__assign({}, _this.options), options);
            return new TigerWorkspaceCatalogFactory(_this.authCall, _this.workspace, newOptions);
        };
        this.forDataset = function (dataset) {
            return _this.withOptions({
                dataset: dataset,
            });
        };
        this.forTypes = function (types) {
            return _this.withOptions({
                types: types,
            });
        };
        this.includeTags = function (tags) {
            return _this.withOptions({
                includeTags: tags,
            });
        };
        this.excludeTags = function (tags) {
            return _this.withOptions({
                excludeTags: tags,
            });
        };
        this.load = function () { return __awaiter(_this, void 0, void 0, function () {
            var promises, includeAttributes, includeDateDatasets, loadersResults, catalogItems, groups;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = [];
                        if (this.options.types.includes("measure")) {
                            promises.push(this.loadMeasures());
                        }
                        if (this.options.types.includes("fact")) {
                            promises.push(this.loadFacts());
                        }
                        includeAttributes = this.options.types.includes("attribute");
                        includeDateDatasets = this.options.types.includes("dateDataset");
                        if (includeAttributes || includeDateDatasets) {
                            promises.push(this.loadAttributesAndDates(includeAttributes, includeDateDatasets));
                        }
                        return [4 /*yield*/, Promise.all(promises)];
                    case 1:
                        loadersResults = _a.sent();
                        catalogItems = sortBy(flatten(loadersResults), function (item) { var _a; return (_a = _this.getCatalogItemSortingKey(item)) === null || _a === void 0 ? void 0 : _a.toUpperCase(); });
                        groups = this.extractGroups(catalogItems);
                        return [2 /*return*/, new TigerWorkspaceCatalog(this.authCall, this.workspace, groups, catalogItems, this.options)];
                }
            });
        }); };
        this.getCatalogItemSortingKey = function (item) {
            if (isCatalogAttribute(item)) {
                return item.attribute.title;
            }
            if (isCatalogFact(item)) {
                return item.fact.title;
            }
            if (isCatalogMeasure(item)) {
                return item.measure.title;
            }
            return undefined;
        };
        this.tagsToIdentifiers = function (tags) {
            return tags.map(function (ref) {
                // Tags cannot be accessed by any separate endpoint, so it doesn't make sense to reference them by uri.
                // We will likely change the tag type signature from ObjRef to plain string in the future.
                invariant(!isUriRef(ref), "Tags cannot be referenced by uri!");
                return ref.identifier;
            });
        };
        this.loadAttributesAndDates = function (loadAttributes, loadDateDataSets) { return __awaiter(_this, void 0, void 0, function () {
            var tags;
            var _this = this;
            return __generator(this, function (_a) {
                tags = this.tagsToIdentifiers(this.options.includeTags);
                return [2 /*return*/, this.authCall(function (client) {
                        return loadAttributesAndDateDatasets(client, _this.workspace, tags, loadAttributes, loadDateDataSets);
                    })];
            });
        }); };
        this.loadMeasures = function () { return __awaiter(_this, void 0, void 0, function () {
            var tags, measures;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tags = this.tagsToIdentifiers(this.options.includeTags);
                        return [4 /*yield*/, this.authCall(function (client) {
                                return MetadataUtilities.getAllPagesOf(client, client.workspaceObjects.getAllEntitiesMetrics, {
                                    workspaceId: _this.workspace,
                                }, { query: { tags: tags.join(",") }, headers: ValidateRelationsHeader })
                                    .then(MetadataUtilities.mergeEntitiesResults)
                                    .then(MetadataUtilities.filterValidEntities);
                            })];
                    case 1:
                        measures = _a.sent();
                        return [2 /*return*/, measures.data.map(convertMeasure)];
                }
            });
        }); };
        this.loadFacts = function () { return __awaiter(_this, void 0, void 0, function () {
            var tags, facts;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        tags = this.tagsToIdentifiers(this.options.includeTags);
                        return [4 /*yield*/, this.authCall(function (client) {
                                return MetadataUtilities.getAllPagesOf(client, client.workspaceObjects.getAllEntitiesFacts, { workspaceId: _this.workspace }, { query: { tags: tags.join(",") } }).then(MetadataUtilities.mergeEntitiesResults);
                            })];
                    case 1:
                        facts = _a.sent();
                        return [2 /*return*/, facts.data.map(convertFact)];
                }
            });
        }); };
    }
    // Groups are collected from all catalog entities.
    // There is no separate endpoint for the tags anymore.
    TigerWorkspaceCatalogFactory.prototype.extractGroups = function (catalogItems) {
        var groupableItems = catalogItems.filter(function (item) { return item.type !== "dateDataset"; });
        var allTags = flatMap(groupableItems, function (item) {
            return item.groups.map(function (tag) { return ({
                title: tag.identifier,
                tag: tag,
            }); });
        });
        return uniqBy(allTags, function (tag) { return tag.title; });
    };
    return TigerWorkspaceCatalogFactory;
}());
export { TigerWorkspaceCatalogFactory };
//# sourceMappingURL=factory.js.map