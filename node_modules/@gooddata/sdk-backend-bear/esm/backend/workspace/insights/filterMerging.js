import { __awaiter, __generator, __spreadArrays } from "tslib";
// (C) 2020 GoodData Corporation
import { filterObjRef, isRelativeDateFilter, relativeDateFilterValues, isIdentifierRef, isUriRef, isAbsoluteDateFilter, absoluteDateFilterValues, newAbsoluteDateFilter, uriRef, newRelativeDateFilter, isPositiveAttributeFilter, filterAttributeElements, newPositiveAttributeFilter, newNegativeAttributeFilter, isNegativeAttributeFilter, isMeasureValueFilter, isRankingFilter, mergeFilters, } from "@gooddata/sdk-model";
import partition from "lodash/fp/partition";
import zip from "lodash/fp/zip";
/**
 * Appends a set of filters to an existing set making sure that all the filters compared regardless of their ObjRef types.
 * Uses {@link mergeFilters} internally, see its docs for details on the merging logic.
 *
 * @param originalFilters - original filter set
 * @param addedFilters - filters to append
 * @param objRefNormalizer - function that converts any ObjRef type to uri
 */
export function appendFilters(originalFilters, addedFilters, objRefNormalizer) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, normalizedOriginalFilters, normalizedAddedFilters, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!allUseSameRefType(__spreadArrays(originalFilters, addedFilters))) return [3 /*break*/, 1];
                    _b = [originalFilters, addedFilters];
                    return [3 /*break*/, 3];
                case 1: return [4 /*yield*/, Promise.all([
                        normalizeFilterRefs(originalFilters, objRefNormalizer),
                        normalizeFilterRefs(addedFilters, objRefNormalizer),
                    ])];
                case 2:
                    _b = _c.sent();
                    _c.label = 3;
                case 3:
                    _a = _b, normalizedOriginalFilters = _a[0], normalizedAddedFilters = _a[1];
                    return [2 /*return*/, mergeFilters(normalizedOriginalFilters, normalizedAddedFilters)];
            }
        });
    });
}
var isFilterWithoutRefs = function (filter) {
    return isMeasureValueFilter(filter) || isRankingFilter(filter);
};
/**
 * Detects if all the filters with refs use the same ObjRef type.
 *
 * @param filters - the filters to check
 */
function allUseSameRefType(filters) {
    var filtersWithRefs = filters.filter(function (f) { return !isFilterWithoutRefs(f); });
    return (filtersWithRefs.every(function (f) { return isIdentifierRef(filterObjRef(f)); }) ||
        filtersWithRefs.every(function (f) { return isUriRef(filterObjRef(f)); }));
}
/**
 * Makes sure that all the filters use the same ObjRef type so that they can be compared trivially.
 *
 * @param filters - filters to normalize
 * @param objRefNormalizer - function that converts any ObjRef type to uri
 */
function normalizeFilterRefs(filters, objRefNormalizer) {
    return __awaiter(this, void 0, void 0, function () {
        var _a, filtersWithoutRefs, filtersWithRefs, refs, uris, normalized;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _a = partition(isFilterWithoutRefs, filters), filtersWithoutRefs = _a[0], filtersWithRefs = _a[1];
                    refs = filtersWithRefs.map(filterObjRef);
                    return [4 /*yield*/, objRefNormalizer(refs)];
                case 1:
                    uris = _b.sent();
                    normalized = zip(filtersWithRefs, uris).map(function (_a) {
                        var filter = _a[0], uri = _a[1];
                        if (isAbsoluteDateFilter(filter)) {
                            var _b = absoluteDateFilterValues(filter), from = _b.from, to = _b.to;
                            return newAbsoluteDateFilter(uriRef(uri), from, to);
                        }
                        else if (isRelativeDateFilter(filter)) {
                            var _c = relativeDateFilterValues(filter), granularity = _c.granularity, from = _c.from, to = _c.to;
                            return newRelativeDateFilter(uriRef(uri), granularity, from, to);
                        }
                        else if (isPositiveAttributeFilter(filter)) {
                            var elements = filterAttributeElements(filter);
                            return newPositiveAttributeFilter(uriRef(uri), elements);
                        }
                        else if (isNegativeAttributeFilter(filter)) {
                            var elements = filterAttributeElements(filter);
                            return newNegativeAttributeFilter(uriRef(uri), elements);
                        }
                        else {
                            return filter;
                        }
                    });
                    return [2 /*return*/, __spreadArrays(filtersWithoutRefs, normalized)];
            }
        });
    });
}
//# sourceMappingURL=filterMerging.js.map