import { __generator, __read, __spread } from "tslib";
import { call, put, select } from "redux-saga/effects";
import compact from "lodash/compact";
import isEmpty from "lodash/isEmpty";
import invariant from "ts-invariant";
import { drillToDashboardRequested, drillToDashboardResolved, } from "../../events/drill";
import { selectFilterContextAttributeFilters, selectFilterContextDateFilter, } from "../../store/filterContext/filterContextSelectors";
import { selectWidgetByRef } from "../../store/layout/layoutSelectors";
import { filterContextDateFilterToDateFilter, filterContextAttributeFilterToAttributeFilter, } from "../../../converters";
import { isDrillIntersectionAttributeItem, } from "@gooddata/sdk-ui";
import { areObjRefsEqual, newAllTimeFilter, newPositiveAttributeFilter, insightMeasures, isSimpleMeasure, measureFilters, isDateFilter, } from "@gooddata/sdk-model";
import { selectCatalogDateAttributes } from "../../store/catalog/catalogSelectors";
import { selectInsightByRef } from "../../store/insights/insightsSelectors";
export function drillToDashboardHandler(ctx, cmd) {
    var widget, insight, shouldUseDateFilter, dateFilter, _a, isDrillingToSelf, dashboardFilters, _b, dateAttributes, drillIntersectionFilters, resultingFilters;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: 
            // put start event
            return [4 /*yield*/, put(drillToDashboardRequested(ctx, cmd.payload.drillDefinition, cmd.payload.drillEvent, cmd.correlationId))];
            case 1:
                // put start event
                _c.sent();
                return [4 /*yield*/, select(selectWidgetByRef(cmd.payload.drillEvent.widgetRef))];
            case 2:
                widget = _c.sent();
                return [4 /*yield*/, select(selectInsightByRef(widget.insight))];
            case 3:
                insight = _c.sent();
                // if this bombs, widget is not an insight widget and something is seriously wrong
                invariant(insight);
                shouldUseDateFilter = !!widget.dateDataSet && !isDateFilterDisabled(insight);
                if (!shouldUseDateFilter) return [3 /*break*/, 5];
                return [4 /*yield*/, select(selectDrillingDateFilter, widget)];
            case 4:
                _a = _c.sent();
                return [3 /*break*/, 6];
            case 5:
                _a = undefined;
                _c.label = 6;
            case 6:
                dateFilter = _a;
                isDrillingToSelf = areObjRefsEqual(ctx.dashboardRef, cmd.payload.drillDefinition.target);
                if (!isDrillingToSelf) return [3 /*break*/, 8];
                return [4 /*yield*/, select(selectAllAttributeFilters)];
            case 7:
                _b = _c.sent();
                return [3 /*break*/, 10];
            case 8: // if drilling to other, resolve widget filter ignores
            return [4 /*yield*/, call(getWidgetAwareAttributeFilters, ctx, widget)];
            case 9:
                _b = _c.sent();
                _c.label = 10;
            case 10:
                dashboardFilters = _b;
                return [4 /*yield*/, select(selectCatalogDateAttributes)];
            case 11:
                dateAttributes = _c.sent();
                drillIntersectionFilters = convertIntersectionToAttributeFilters(cmd.payload.drillEvent.drillContext.intersection, dateAttributes.map(function (dA) { return dA.attribute.ref; }));
                resultingFilters = compact(__spread([dateFilter], drillIntersectionFilters, dashboardFilters));
                // put end event
                return [2 /*return*/, drillToDashboardResolved(ctx, resultingFilters, cmd.payload.drillDefinition, cmd.payload.drillEvent, cmd.correlationId)];
        }
    });
}
function selectDrillingDateFilter(state, widget) {
    var globalDateFilter = selectFilterContextDateFilter(state);
    return globalDateFilter
        ? filterContextDateFilterToDateFilter(globalDateFilter, widget)
        : newAllTimeFilter(widget.dateDataSet);
}
function selectAllAttributeFilters(state) {
    var filterContextItems = selectFilterContextAttributeFilters(state);
    return filterContextItems.map(filterContextAttributeFilterToAttributeFilter);
}
function getWidgetAwareAttributeFilters(ctx, widget) {
    var filterContextItems, filters;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, select(selectFilterContextAttributeFilters)];
            case 1:
                filterContextItems = _a.sent();
                filters = filterContextItems.map(filterContextAttributeFilterToAttributeFilter);
                return [4 /*yield*/, call(getResolvedFiltersForWidget, ctx, widget, filters)];
            case 2: return [2 /*return*/, _a.sent()];
        }
    });
}
function isDateFilterDisabled(insight) {
    var measures = insightMeasures(insight);
    return isEmpty(measures)
        ? false
        : measures.every(function (measure) {
            if (isSimpleMeasure(measure)) {
                var filters = measureFilters(measure);
                return !!(filters === null || filters === void 0 ? void 0 : filters.some(isDateFilter));
            }
            return true;
        });
}
function getResolvedFiltersForWidget(ctx, widget, filters) {
    return ctx.backend.workspace(ctx.workspace).dashboards().getResolvedFiltersForWidget(widget, filters);
}
/**
 *  For correct drill intersection that should be converted into AttributeFilters must be drill intersection:
 *  1. AttributeItem
 *  2. Not a date attribute
 */
function filterIntersection(intersection, dateDataSetsAttributesRefs) {
    var _a, _b;
    var attributeItem = isDrillIntersectionAttributeItem(intersection) ? intersection : undefined;
    var ref = (_b = (_a = attributeItem === null || attributeItem === void 0 ? void 0 : attributeItem.attributeHeader) === null || _a === void 0 ? void 0 : _a.formOf) === null || _b === void 0 ? void 0 : _b.ref;
    return ref ? !dateDataSetsAttributesRefs.some(function (ddsRef) { return areObjRefsEqual(ddsRef, ref); }) : false;
}
export function convertIntersectionToAttributeFilters(intersection, dateDataSetsAttributesRefs) {
    return intersection
        .map(function (i) { return i.header; })
        .filter(function (i) { return filterIntersection(i, dateDataSetsAttributesRefs); })
        .filter(isDrillIntersectionAttributeItem)
        .map(function (h) {
        return newPositiveAttributeFilter(h.attributeHeader.ref, { uris: [h.attributeHeaderItem.uri] });
    });
}
//# sourceMappingURL=drillToDashboardHandler.js.map