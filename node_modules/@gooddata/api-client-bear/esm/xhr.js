import { __assign, __awaiter, __extends, __generator, __rest } from "tslib";
// (C) 2007-2021 GoodData Corporation
import isPlainObject from "lodash/isPlainObject";
import isFunction from "lodash/isFunction";
import set from "lodash/set";
import defaults from "lodash/defaults";
import merge from "lodash/merge";
import result from "lodash/result";
import pkgInfo from "../package.json";
import { stringify } from "./utils/queryString";
var pkgName = pkgInfo.name, pkgVersion = pkgInfo.version;
/**
 * Ajax wrapper around GDC authentication mechanisms, SST and TT token handling and polling.
 * Interface is the same as original jQuery.ajax.
 *
 * If token is expired, current request is "paused", token is refreshed and request is retried and result
 * is transparently returned to the original call.
 *
 * Additionally polling is handled. Only final result of polling returned.
 * @module xhr
 * @class xhr
 */
var DEFAULT_POLL_DELAY = 1000;
var REST_API_VERSION_HEADER = "X-GDC-VERSION";
var REST_API_DEPRECATED_VERSION_HEADER = "X-GDC-DEPRECATED";
// The version used in X-GDC-VERSION header (see https://confluence.intgdc.com/display/Development/REST+API+versioning)
var LATEST_REST_API_VERSION = 5;
/**
 * Gooddata-js package signature
 * @private
 */
export var thisPackage = { name: pkgName, version: pkgVersion };
function simulateBeforeSend(url, settings) {
    var xhrMockInBeforeSend = {
        setRequestHeader: function (key, value) {
            set(settings, ["headers", key], value);
        },
    };
    if (isFunction(settings.beforeSend)) {
        settings.beforeSend(xhrMockInBeforeSend, url);
    }
}
function enrichSettingWithCustomDomain(originalUrl, originalSettings, domain) {
    var url = originalUrl;
    var settings = originalSettings;
    if (domain) {
        // protect url to be prepended with domain on retry
        if (originalUrl.indexOf(domain) === -1) {
            url = domain + originalUrl;
        }
        settings.mode = "cors";
        settings.credentials = "include";
    }
    return { url: url, settings: settings };
}
export function handlePolling(url, 
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
settings, sendRequest) {
    var pollingDelay = result(settings, "pollDelay");
    return new Promise(function (resolve, reject) {
        setTimeout(function () {
            sendRequest(url, settings).then(resolve, reject);
        }, pollingDelay);
    });
}
export function originPackageHeaders(_a) {
    var name = _a.name, version = _a.version;
    return {
        "X-GDC-JS-PKG": name,
        "X-GDC-JS-PKG-VERSION": version,
    };
}
var ApiError = /** @class */ (function (_super) {
    __extends(ApiError, _super);
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function ApiError(message, cause) {
        var _newTarget = this.constructor;
        var _this = _super.call(this, message) || this;
        _this.cause = cause;
        Object.setPrototypeOf(_this, _newTarget.prototype);
        return _this;
    }
    return ApiError;
}(Error));
export { ApiError };
var ApiResponseError = /** @class */ (function (_super) {
    __extends(ApiResponseError, _super);
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function ApiResponseError(message, response, responseBody) {
        var _this = _super.call(this, message, null) || this;
        _this.response = response;
        _this.responseBody = responseBody;
        return _this;
    }
    return ApiResponseError;
}(ApiError));
export { ApiResponseError };
var ApiNetworkError = /** @class */ (function (_super) {
    __extends(ApiNetworkError, _super);
    function ApiNetworkError() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return ApiNetworkError;
}(ApiError));
export { ApiNetworkError };
var ApiResponse = /** @class */ (function () {
    function ApiResponse(response, responseBody) {
        this.response = response;
        this.responseBody = responseBody;
    }
    Object.defineProperty(ApiResponse.prototype, "data", {
        get: function () {
            return this.getDataInner();
        },
        enumerable: false,
        configurable: true
    });
    ApiResponse.prototype.getData = function () {
        return this.getDataInner();
    };
    ApiResponse.prototype.getHeaders = function () {
        return this.response;
    };
    ApiResponse.prototype.getDataInner = function () {
        try {
            return JSON.parse(this.responseBody);
        }
        catch (error) {
            throw new Error("Cannot parse responseBody.");
        }
    };
    return ApiResponse;
}());
export { ApiResponse };
// the variable must be outside of the scope of the XhrModule to not log the message multiple times in SDK and KD
var shouldLogDeprecatedRestApiCall = true;
var XhrModule = /** @class */ (function () {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    function XhrModule(fetch, configStorage) {
        this.fetch = fetch;
        this.configStorage = configStorage;
        defaults(configStorage, { xhrSettings: {} });
    }
    /**
     * Clears the indicator that is making the XHR module to perform token requests before making
     * the actual call. The module may get into this state typically during the application initialization
     * when the session is not yet authenticated.
     *
     * Calling this method will clear that indicator, ensuring that the next call will be called without
     * the leading call to token (which will typically fail).
     */
    XhrModule.prototype.ensureNoLeadingTokenRequest = function () {
        this.tokenRequest = null;
    };
    /**
     * Back compatible method for setting common XHR settings
     *
     * Usually in our apps we used beforeSend ajax callback to set the X-GDC-REQUEST header with unique ID.
     *
     * @param settings object XHR settings as
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    XhrModule.prototype.ajaxSetup = function (settings) {
        Object.assign(this.configStorage.xhrSettings, settings);
    };
    XhrModule.prototype.ajax = function (originalUrl, customSettings) {
        var _a, _b;
        if (customSettings === void 0) { customSettings = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var firstSettings, _c, url, settings, response, e_1, responseBody, isLoginRequest, isTokenRequest, shouldSkipUnauthorizedHandling, responseJson, finalUrl, finalSettings;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        firstSettings = this.createRequestSettings(customSettings);
                        _c = enrichSettingWithCustomDomain(originalUrl, firstSettings, this.configStorage.domain), url = _c.url, settings = _c.settings;
                        simulateBeforeSend(url, settings); // mutates `settings` param
                        if (this.tokenRequest) {
                            return [2 /*return*/, this.continueAfterTokenRequest(url, settings)];
                        }
                        _d.label = 1;
                    case 1:
                        _d.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.fetch(url, settings)];
                    case 2:
                        // TODO: We should clean up the settings at this point to be pure `RequestInit` object
                        response = _d.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_1 = _d.sent();
                        throw new ApiNetworkError(e_1.message, e_1); // TODO is it really necessary? couldn't we throw just Error?
                    case 4: return [4 /*yield*/, response.text()];
                    case 5:
                        responseBody = _d.sent();
                        if (response.status === 401) {
                            isLoginRequest = url.indexOf("/gdc/account/login") !== -1;
                            isTokenRequest = url.indexOf("/gdc/account/token") !== -1;
                            shouldSkipUnauthorizedHandling = isLoginRequest || isTokenRequest;
                            if (shouldSkipUnauthorizedHandling) {
                                throw new ApiResponseError("Unauthorized", response, responseBody);
                            }
                            return [2 /*return*/, this.handleUnauthorized(url, settings)];
                        }
                        // Note: Fetch does redirects automagically for 301 (and maybe more .. TODO when?)
                        // see https://fetch.spec.whatwg.org/#ref-for-concept-request%E2%91%A3%E2%91%A2
                        if (response.status === 202 && !settings.dontPollOnResult) {
                            responseJson = void 0;
                            try {
                                responseJson = JSON.parse(responseBody);
                            }
                            catch (err) {
                                responseJson = {};
                            }
                            finalUrl = (_b = (_a = responseJson.uri) !== null && _a !== void 0 ? _a : response.url) !== null && _b !== void 0 ? _b : url;
                            finalSettings = settings;
                            // if the response is 202 and Location header is not empty, let's poll on the new Location
                            if (response.headers.has("Location")) {
                                finalUrl = response.headers.get("Location");
                            }
                            finalSettings.method = "GET";
                            delete finalSettings.data;
                            delete finalSettings.body;
                            return [2 /*return*/, handlePolling(finalUrl, finalSettings, this.ajax.bind(this))];
                        }
                        this.verifyRestApiDeprecationStatus(response.headers);
                        if (response.status >= 200 && response.status <= 399) {
                            return [2 /*return*/, new ApiResponse(response, responseBody)];
                        }
                        // throws on 400, 500, etc.
                        throw new ApiResponseError(response.statusText, response, responseBody);
                }
            });
        });
    };
    /**
     * Wrapper for xhr.ajax method GET
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    XhrModule.prototype.get = function (url, settings) {
        return this.ajax(url, merge({ method: "GET" }, settings));
    };
    /**
     * Wrapper for xhr.ajax method GET, returns parsed JSON response body
     */
    XhrModule.prototype.getParsed = function (url, settings) {
        if (settings === void 0) { settings = {}; }
        var data = settings.data, restSettings = __rest(settings, ["data"]);
        var urlWithParams = url;
        if (data) {
            urlWithParams = url + "?" + stringify(data);
        }
        return this.ajax(urlWithParams, merge({ method: "GET" }, restSettings)).then(function (response) {
            return response.getData();
        });
    };
    /**
     * Wrapper for xhr.ajax method HEAD
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    XhrModule.prototype.head = function (url, settings) {
        return this.ajax(url, merge({ method: "HEAD" }, settings));
    };
    /**
     * Wrapper for xhr.ajax method POST
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    XhrModule.prototype.post = function (url, settings) {
        return this.ajax(url, merge({ method: "POST" }, settings));
    };
    /**
     * Wrapper for xhr.ajax method POST, returns parsed JSON response body
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    XhrModule.prototype.postParsed = function (url, settings) {
        return this.ajax(url, merge({ method: "POST" }, settings)).then(function (response) { return response.getData(); });
    };
    /**
     * Wrapper for xhr.ajax method PUT
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    XhrModule.prototype.put = function (url, settings) {
        return this.ajax(url, merge({ method: "PUT" }, settings));
    };
    /**
     * Wrapper for xhr.ajax method DELETE
     */
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    XhrModule.prototype.del = function (url, settings) {
        return this.ajax(url, merge({ method: "DELETE" }, settings));
    };
    XhrModule.prototype.createRequestSettings = function (customSettings) {
        var _a;
        var settings = merge({
            headers: __assign((_a = { Accept: "application/json; charset=utf-8", "Content-Type": "application/json" }, _a[REST_API_VERSION_HEADER] = LATEST_REST_API_VERSION, _a), originPackageHeaders(this.configStorage.originPackage || thisPackage)),
        }, this.configStorage.xhrSettings, customSettings);
        settings.pollDelay = settings.pollDelay !== undefined ? settings.pollDelay : DEFAULT_POLL_DELAY;
        // TODO jquery compat - add to warnings
        settings.body = settings.data ? settings.data : settings.body;
        settings.mode = "same-origin";
        settings.credentials = "same-origin";
        if (isPlainObject(settings.body)) {
            settings.body = JSON.stringify(settings.body);
        }
        return settings;
    };
    XhrModule.prototype.continueAfterTokenRequest = function (url, settings) {
        var _this = this;
        return this.tokenRequest.then(function (response) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!response.ok) {
                    throw new ApiResponseError("Unauthorized", response, null);
                }
                this.tokenRequest = null;
                return [2 /*return*/, this.ajax(url, settings)];
            });
        }); }, function (reason) {
            _this.tokenRequest = null;
            return reason;
        });
    };
    XhrModule.prototype.handleUnauthorized = function (originalUrl, originalSettings) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, url, settings, response, responseBody;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        // Create only single token request for any number of waiting request.
                        // If token request exist, just listen for it's end.
                        if (this.tokenRequest) {
                            return [2 /*return*/, this.continueAfterTokenRequest(originalUrl, originalSettings)];
                        }
                        _a = enrichSettingWithCustomDomain("/gdc/account/token", this.createRequestSettings({}), this.configStorage.domain), url = _a.url, settings = _a.settings;
                        this.tokenRequest = this.fetch(url, settings);
                        return [4 /*yield*/, this.tokenRequest];
                    case 1:
                        response = _b.sent();
                        return [4 /*yield*/, response.text()];
                    case 2:
                        responseBody = _b.sent();
                        this.tokenRequest = null;
                        // TODO jquery compat - allow to attach unauthorized callback and call it if attached
                        // if ((xhrObj.status === 401) && (isFunction(req.unauthorized))) {
                        //     req.unauthorized(xhrObj, textStatus, err, deferred);
                        //     return;
                        // }
                        // unauthorized handler is not defined or not http 401
                        // unauthorized when retrieving token -> not logged
                        if (response.status === 401) {
                            throw new ApiResponseError("Unauthorized", response, responseBody);
                        }
                        return [2 /*return*/, this.ajax(originalUrl, originalSettings)];
                }
            });
        });
    };
    XhrModule.prototype.logDeprecatedRestApiCall = function (deprecatedVersionDetails) {
        // eslint-disable-next-line no-console
        console.warn("The REST API version " + LATEST_REST_API_VERSION + " is deprecated (" + deprecatedVersionDetails + "). " +
            "Please migrate your application to use GoodData.UI SDK or @gooddata/api-client-bear package that " +
            "supports newer version of the API.");
    };
    XhrModule.prototype.isRestApiDeprecated = function (responseHeaders) {
        return responseHeaders.has(REST_API_DEPRECATED_VERSION_HEADER);
    };
    XhrModule.prototype.verifyRestApiDeprecationStatus = function (responseHeaders) {
        if (shouldLogDeprecatedRestApiCall && this.isRestApiDeprecated(responseHeaders)) {
            var deprecatedVersionDetails = responseHeaders.get(REST_API_DEPRECATED_VERSION_HEADER);
            this.logDeprecatedRestApiCall(deprecatedVersionDetails);
            shouldLogDeprecatedRestApiCall = false;
        }
    };
    return XhrModule;
}());
export { XhrModule };
//# sourceMappingURL=xhr.js.map