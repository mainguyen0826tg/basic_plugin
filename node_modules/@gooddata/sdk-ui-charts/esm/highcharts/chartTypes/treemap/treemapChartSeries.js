import { __assign, __spreadArrays } from "tslib";
import { getLighterColor } from "@gooddata/sdk-ui-vis-commons";
import { parseValue, unwrap } from "../_util/common";
import isEqual from "lodash/isEqual";
function getColorStep(valuesCount) {
    var MAX_COLOR_BRIGHTNESS = 0.8;
    return MAX_COLOR_BRIGHTNESS / valuesCount;
}
function gradientPreviousGroup(solidColorLeafs) {
    var colorChange = getColorStep(solidColorLeafs.length);
    return solidColorLeafs.map(function (leaf, index) { return (__assign(__assign({}, leaf), { color: getLighterColor(leaf.color, colorChange * index) })); });
}
function getRootPoint(rootName, index, format, colorStrategy) {
    return {
        id: "" + index,
        name: rootName,
        color: colorStrategy.getColorByIndex(index),
        showInLegend: true,
        legendIndex: index,
        format: format,
    };
}
function getLeafPoint(stackByAttribute, parentIndex, seriesIndex, data, format, colorStrategy) {
    return {
        name: stackByAttribute.items[seriesIndex].attributeHeaderItem.name,
        parent: "" + parentIndex,
        value: parseValue(data),
        x: seriesIndex,
        y: seriesIndex,
        showInLegend: false,
        color: colorStrategy.getColorByIndex(parentIndex),
        format: format,
    };
}
function isLastSerie(seriesIndex, dataLength) {
    return seriesIndex === dataLength - 1;
}
export function getTreemapStackedSeriesDataWithViewBy(dv, measureGroup, viewByAttribute, stackByAttribute, colorStrategy) {
    var roots = [];
    var leafs = [];
    var rootId = -1;
    var uncoloredLeafs = [];
    var lastRoot = null;
    var executionResultData = dv.rawData().twoDimData();
    var dataLength = executionResultData.length;
    var format = unwrap(measureGroup.items[0]).format; // this configuration has only one measure
    executionResultData.forEach(function (seriesItems, seriesIndex) {
        var currentRoot = viewByAttribute.items[seriesIndex].attributeHeaderItem;
        if (!isEqual(currentRoot, lastRoot)) {
            // store previous group leafs
            leafs.push.apply(leafs, gradientPreviousGroup(uncoloredLeafs));
            rootId++;
            lastRoot = currentRoot;
            uncoloredLeafs = [];
            // create parent for pasted leafs
            var lastRootName = lastRoot === null || lastRoot === void 0 ? void 0 : lastRoot.name;
            roots.push(getRootPoint(lastRootName, rootId, format, colorStrategy));
        }
        // create leafs which will be colored at the end of group
        uncoloredLeafs.push(getLeafPoint(stackByAttribute, rootId, seriesIndex, seriesItems[0], format, colorStrategy));
        if (isLastSerie(seriesIndex, dataLength)) {
            // store last group leafs
            leafs.push.apply(leafs, gradientPreviousGroup(uncoloredLeafs));
        }
    });
    return __spreadArrays(roots, leafs); // roots need to be first items in data to keep legend working
}
export function getTreemapStackedSeriesDataWithMeasures(dv, measureGroup, 
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
stackByAttribute, colorStrategy) {
    var data = measureGroup.items.map(function (measureGroupItem, index) {
        return {
            id: "" + index,
            name: measureGroupItem.measureHeaderItem.name,
            format: measureGroupItem.measureHeaderItem.format,
            color: colorStrategy.getColorByIndex(index),
            showInLegend: true,
            legendIndex: index,
        };
    });
    dv.rawData()
        .twoDimData()
        .forEach(function (seriesItems, seriesIndex) {
        var colorChange = getColorStep(seriesItems.length);
        var unsortedLeafs = seriesItems.map(function (seriesItem, seriesItemIndex) {
            return {
                name: stackByAttribute.items[seriesItemIndex].attributeHeaderItem.name,
                parent: "" + seriesIndex,
                format: unwrap(measureGroup.items[seriesIndex]).format,
                value: parseValue(seriesItem),
                x: seriesIndex,
                y: seriesItemIndex,
                showInLegend: false,
            };
        });
        var sortedLeafs = unsortedLeafs.sort(function (a, b) { return b.value - a.value; });
        data = __spreadArrays(data, sortedLeafs.map(function (leaf, seriesItemIndex) { return (__assign(__assign({}, leaf), { color: getLighterColor(colorStrategy.getColorByIndex(seriesIndex), colorChange * seriesItemIndex) })); }));
    });
    return data;
}
export function getTreemapStackedSeries(dv, measureGroup, viewByAttribute, stackByAttribute, colorStrategy) {
    var data = [];
    if (viewByAttribute) {
        data = getTreemapStackedSeriesDataWithViewBy(dv, measureGroup, viewByAttribute, stackByAttribute, colorStrategy);
    }
    else {
        data = getTreemapStackedSeriesDataWithMeasures(dv, measureGroup, stackByAttribute, colorStrategy);
    }
    var seriesName = measureGroup.items
        .map(function (wrappedMeasure) {
        return unwrap(wrappedMeasure).name;
    })
        .join(", ");
    return [
        {
            name: seriesName,
            legendType: "point",
            showInLegend: true,
            data: data,
            turboThreshold: 0,
            seriesIndex: 0,
        },
    ];
}
//# sourceMappingURL=treemapChartSeries.js.map