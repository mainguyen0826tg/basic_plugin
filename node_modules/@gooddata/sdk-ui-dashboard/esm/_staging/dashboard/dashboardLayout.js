// (C) 2021 GoodData Corporation
import { __assign, __read, __spread } from "tslib";
import { isDashboardLayout, isInsightWidget, isKpiWidget, } from "@gooddata/sdk-backend-spi";
import { insightRef, serializeObjRef } from "@gooddata/sdk-model";
import compact from "lodash/compact";
import keyBy from "lodash/keyBy";
import invariant, { InvariantError } from "ts-invariant";
import { validateDashboardLayoutWidgetSize, } from "../../presentation/layout/DefaultDashboardLayoutRenderer";
import { ObjRefMap } from "../metadata/objRefMap";
function extractContentFromWidget(widget, insightsById) {
    if (isInsightWidget(widget)) {
        var insightRef_1 = widget.insight;
        return {
            type: "insight",
            content: insightsById[serializeObjRef(insightRef_1)],
        };
    }
    else if (isKpiWidget(widget)) {
        return {
            type: "kpi",
            content: widget.kpi,
        };
    }
    throw new InvariantError("trying to extract content from unknown widget type " + widget.type);
}
/**
 * Sanitizes item. At this moment this function will ensure that Insight and KPI widgets conform to the sizing prescriptions.
 *
 * @param item - item in layout section
 * @param insightsById - list of insights available; insight widgets will be resolved using this
 * @param settings - settings that may impact the sizing
 */
function dashboardLayoutItemSanitize(item, insightsById, settings) {
    var widget = item.widget, xl = item.size.xl;
    // ignore items that point to no widget; this is model-level version of the fix to RAIL-3669
    if (!widget) {
        // eslint-disable-next-line no-console
        console.log("Found item " + item + " that does not contain any widget. Removing from layout.");
        return undefined;
    }
    // only sanitize known widget types
    if (!isInsightWidget(widget) || !isKpiWidget(widget)) {
        return item;
    }
    var _a = extractContentFromWidget(widget, insightsById), type = _a.type, content = _a.content;
    // if the dashboard is inconsistent (can ultimately happen on tiger), then return no item => it will be removed
    if (!content) {
        return;
    }
    var _b = validateDashboardLayoutWidgetSize(xl.gridWidth, xl.gridHeight, type, content, settings), validWidth = _b.validWidth, validHeight = _b.validHeight;
    return __assign(__assign({}, item), { size: {
            xl: __assign(__assign({}, xl), { gridWidth: validWidth, gridHeight: validHeight }),
        } });
}
/**
 * This function sanitizes dashboard layout. It will:
 *
 * 1.  Ensure insight widgets have correct sizes - matching what the visualization used by the insight needs
 *     (this is essential as the insight visualization may change since the last time dashboard was created)
 * 2.  Ensure insight widgets reference existing insights.
 *
 * @param layout - layout
 * @param insights - existing insights that are referenced by the layout's widgets
 * @param settings - current settings; these may influence sizing of the widgets
 */
export function dashboardLayoutSanitize(layout, insights, settings) {
    var insightsById = keyBy(insights, function (insight) {
        return serializeObjRef(insightRef(insight));
    });
    var sanitizedSections = layout.sections.map(function (section) {
        var sanitizedItems = compact(section.items.map(function (item) { return dashboardLayoutItemSanitize(item, insightsById, settings); }));
        return __assign(__assign({}, section), { items: sanitizedItems });
    });
    return __assign(__assign({}, layout), { sections: sanitizedSections });
}
/**
 * Creates {@link ObjRefMap} containing identity mapping..
 */
function newIdentityMapping(items) {
    var map = new ObjRefMap({
        type: "insight",
        strictTypeCheck: false,
        idExtract: function (e) { return e.original.identifier; },
        uriExtract: function (e) { return e.original.uri; },
        refExtract: function (e) { return e.original.ref; },
    });
    return map.fromItems(items);
}
function getWidgetIdentity(widget) {
    var _a = widget !== null && widget !== void 0 ? widget : {}, ref = _a.ref, uri = _a.uri, identifier = _a.identifier;
    if (!ref || !uri || !identifier) {
        return;
    }
    return {
        ref: ref,
        uri: uri,
        identifier: identifier,
    };
}
function getIdentityMapping(original, updated) {
    var result = [];
    original.sections.forEach(function (section, sectionIdx) {
        var updatedSection = updated.sections[sectionIdx];
        invariant(updatedSection);
        section.items.forEach(function (item, itemIdx) {
            var updatedItem = updatedSection.items[itemIdx];
            invariant(updatedItem);
            if (isDashboardLayout(item.widget)) {
                invariant(isDashboardLayout(updatedItem.widget));
                result.push.apply(result, __spread(getIdentityMapping(item.widget, updatedItem.widget)));
            }
            else {
                var originalIdentity = getWidgetIdentity(item.widget);
                var updatedIdentity = getWidgetIdentity(updatedItem.widget);
                invariant(originalIdentity && updatedIdentity);
                result.push({
                    original: originalIdentity,
                    updated: updatedIdentity,
                });
            }
        });
    });
    return result;
}
/**
 * Given two layouts, this function construct mapping between widget identities between the original and the
 * updated layout.
 *
 * Note that this function does not really verify that the layouts are effectively the same and differ just
 * in the widget identities. It checks that for each item in the original layout, there is item at the same
 * position in the updated layout. It can happen that two different layouts will be processed by this
 * function without errors.
 *
 * @param original - original layout, the original widget identities will be picked from here
 * @param updated - updated layout, the updated widget identities will be picked from here
 * @returns map between original widget identity and updated widget identity
 */
export function dashboardLayoutWidgetIdentityMap(original, updated) {
    var result = getIdentityMapping(original, updated);
    return newIdentityMapping(result);
}
/**
 * Given a layout, this function will go through all of it's item's widgets and remove widget's identity if
 * the provided predicate function evaluates true for the identity.
 *
 * A new layout with updated widgets will be returned.
 *
 * @param layout - layout to process
 * @param identityPredicate - function to evaluate for each widget identity; if this function returns true, the
 *  widget's identity will be removed
 */
export function dashboardLayoutRemoveIdentity(layout, identityPredicate) {
    var updatedSections = layout.sections.map(function (section) {
        var updatedItems = section.items.map(function (item) {
            if (isDashboardLayout(item.widget)) {
                return __assign(__assign({}, item), { widget: dashboardLayoutRemoveIdentity(layout, identityPredicate) });
            }
            else {
                var identity = getWidgetIdentity(item.widget);
                if (!identity || !identityPredicate(identity)) {
                    return item;
                }
                return __assign(__assign({}, item), { widget: __assign(__assign({}, item.widget), { ref: undefined, uri: undefined, identifier: undefined }) });
            }
        });
        return __assign(__assign({}, section), { items: updatedItems });
    });
    return __assign(__assign({}, layout), { sections: updatedSections });
}
//# sourceMappingURL=dashboardLayout.js.map