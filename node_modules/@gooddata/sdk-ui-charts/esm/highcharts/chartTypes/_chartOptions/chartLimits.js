import { __assign } from "tslib";
import { VisualizationTypes } from "@gooddata/sdk-ui";
import { DEFAULT_CATEGORIES_LIMIT, DEFAULT_DATA_POINTS_LIMIT, DEFAULT_SERIES_LIMIT, } from "../_chartCreators/commonConfiguration";
import { HEATMAP_DATA_POINTS_LIMIT, PIE_CHART_LIMIT } from "../../constants/limits";
import { isOneOfTypes, isTreemap } from "../_util/common";
import { unsupportedNegativeValuesTypes } from "./chartCapabilities";
import { isDataOfReasonableSize } from "../_chartCreators/highChartsCreators";
export function isNegativeValueIncluded(series) {
    return series.some(function (seriesItem) {
        return (seriesItem.data || []).some(function (_a) {
            var y = _a.y, value = _a.value;
            return y < 0 || value < 0;
        });
    });
}
function getChartLimits(type) {
    switch (type) {
        case VisualizationTypes.SCATTER:
            return {
                series: DEFAULT_SERIES_LIMIT,
                categories: DEFAULT_SERIES_LIMIT,
            };
        case VisualizationTypes.PIE:
        case VisualizationTypes.DONUT:
        case VisualizationTypes.FUNNEL:
            return {
                series: 1,
                categories: PIE_CHART_LIMIT,
            };
        case VisualizationTypes.TREEMAP:
            return {
                series: DEFAULT_SERIES_LIMIT,
                categories: DEFAULT_DATA_POINTS_LIMIT,
                dataPoints: DEFAULT_DATA_POINTS_LIMIT,
            };
        case VisualizationTypes.HEATMAP:
            return {
                series: DEFAULT_SERIES_LIMIT,
                categories: DEFAULT_CATEGORIES_LIMIT,
                dataPoints: HEATMAP_DATA_POINTS_LIMIT,
            };
        default:
            return {
                series: DEFAULT_SERIES_LIMIT,
                categories: DEFAULT_CATEGORIES_LIMIT,
            };
    }
}
export function cannotShowNegativeValues(type) {
    return isOneOfTypes(type, unsupportedNegativeValuesTypes);
}
function getTreemapDataForValidation(data) {
    // filter out root nodes
    return __assign(__assign({}, data), { series: data.series.map(function (serie) { return (__assign(__assign({}, serie), { data: serie.data.filter(function (dataItem) { return dataItem.id === undefined; }) })); }) });
}
export function validateData(limits, chartOptions) {
    var type = chartOptions.type, isViewByTwoAttributes = chartOptions.isViewByTwoAttributes;
    var finalLimits = limits || getChartLimits(type);
    var dataToValidate = chartOptions.data;
    if (isTreemap(type)) {
        dataToValidate = getTreemapDataForValidation(chartOptions.data);
    }
    return {
        dataTooLarge: !isDataOfReasonableSize(dataToValidate, finalLimits, isViewByTwoAttributes),
        hasNegativeValue: cannotShowNegativeValues(type) && isNegativeValueIncluded(chartOptions.data.series),
    };
}
//# sourceMappingURL=chartLimits.js.map