import { __generator, __read } from "tslib";
import { put, delay, take, join, race, call, all, spawn, cancel, actionChannel } from "redux-saga/effects";
import { v4 as uuidv4 } from "uuid";
import { newDashboardEventPredicate } from "../../events";
import { renderRequested, renderResolved } from "../../events/render";
function wait(ms) {
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, delay(ms)];
            case 1:
                _a.sent();
                return [2 /*return*/, true];
        }
    });
}
var isAsyncRenderResolvedEvent = function (id) {
    return newDashboardEventPredicate("GDC.DASH/EVT.RENDER.ASYNC.RESOLVED", id ? function (e) { return e.payload.id === id; } : function () { return true; });
};
var isAsyncRenderRequestedEvent = function (id) {
    return newDashboardEventPredicate("GDC.DASH/EVT.RENDER.ASYNC.REQUESTED", id ? function (e) { return e.payload.id === id; } : function () { return true; });
};
export function newRenderingWorker(config) {
    if (config === void 0) { config = {
        asyncRenderRequestedTimeout: 2000,
        asyncRenderResolvedTimeout: 2000,
        maxTimeout: 60000,
        correlationIdGenerator: uuidv4,
    }; }
    return function renderingWorker(ctx) {
        var correlationId, asyncRenderTasks, err_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 6, , 7]);
                    correlationId = config.correlationIdGenerator();
                    // First, notify that the rendering of the whole dashboard started.
                    return [4 /*yield*/, put(renderRequested(ctx, correlationId))];
                case 1:
                    // First, notify that the rendering of the whole dashboard started.
                    _a.sent();
                    // Wait for the dashboard initialization.
                    return [4 /*yield*/, take("GDC.DASH/EVT.INITIALIZED")];
                case 2:
                    // Wait for the dashboard initialization.
                    _a.sent();
                    return [4 /*yield*/, call(collectAsyncRenderTasks, config)];
                case 3:
                    asyncRenderTasks = _a.sent();
                    // Wait for the resolution of all async rendering tasks.
                    return [4 /*yield*/, call(waitForAsyncRenderTasksResolution, asyncRenderTasks, config)];
                case 4:
                    // Wait for the resolution of all async rendering tasks.
                    _a.sent();
                    // Notify that the dashboard is fully rendered.
                    return [4 /*yield*/, put(renderResolved(ctx, correlationId))];
                case 5:
                    // Notify that the dashboard is fully rendered.
                    _a.sent();
                    return [3 /*break*/, 7];
                case 6:
                    err_1 = _a.sent();
                    // eslint-disable-next-line no-console
                    console.error("Rendering worker failed", err_1);
                    return [3 /*break*/, 7];
                case 7: return [2 /*return*/];
            }
        });
    };
}
function collectAsyncRenderTasks(config) {
    var asyncRenderTasks, timeout, renderRequestedChannel, _a, asyncRenderRequested, timeoutResolved, asyncRenderId, asyncRenderTask;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                asyncRenderTasks = new Map();
                return [4 /*yield*/, spawn(wait, config.asyncRenderRequestedTimeout)];
            case 1:
                timeout = _b.sent();
                return [4 /*yield*/, actionChannel(isAsyncRenderRequestedEvent())];
            case 2:
                renderRequestedChannel = _b.sent();
                _b.label = 3;
            case 3:
                if (!true) return [3 /*break*/, 6];
                return [4 /*yield*/, race({
                        asyncRenderRequested: take(renderRequestedChannel),
                        timeoutResolved: join(timeout),
                    })];
            case 4:
                _a = _b.sent(), asyncRenderRequested = _a.asyncRenderRequested, timeoutResolved = _a.timeoutResolved;
                if (timeoutResolved) {
                    return [3 /*break*/, 6];
                }
                asyncRenderId = asyncRenderRequested.payload.id;
                // Check whether async render is already registered.
                // If so, skip it, because possible re-executions are covered in the async render task itself.
                if (asyncRenderTasks.has(asyncRenderId)) {
                    return [3 /*break*/, 3];
                }
                return [4 /*yield*/, spawn(waitForAsyncRenderResolution, asyncRenderId, config)];
            case 5:
                asyncRenderTask = _b.sent();
                asyncRenderTasks.set(asyncRenderId, asyncRenderTask);
                return [3 /*break*/, 3];
            case 6: return [2 /*return*/, asyncRenderTasks];
        }
    });
}
function waitForAsyncRenderTasksResolution(asyncRenderTasks, config) {
    var timeout, renderRequestedChannel, asyncRenderTasksList, _a, asyncTasksResolved, asyncRenderRequested, timeoutResolved, asyncRenderId, asyncRenderTask;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, spawn(wait, config.maxTimeout - config.asyncRenderRequestedTimeout)];
            case 1:
                timeout = _b.sent();
                return [4 /*yield*/, actionChannel(isAsyncRenderRequestedEvent())];
            case 2:
                renderRequestedChannel = _b.sent();
                _b.label = 3;
            case 3:
                if (!true) return [3 /*break*/, 9];
                asyncRenderTasksList = Array.from(asyncRenderTasks, function (_a) {
                    var _b = __read(_a, 2), task = _b[1];
                    return task;
                });
                return [4 /*yield*/, race({
                        asyncRenderRequested: take(renderRequestedChannel),
                        asyncTasksResolved: all(asyncRenderTasksList.map(function (task) { return join(task); })),
                        timeoutResolved: join(timeout),
                    })];
            case 4:
                _a = _b.sent(), asyncTasksResolved = _a.asyncTasksResolved, asyncRenderRequested = _a.asyncRenderRequested, timeoutResolved = _a.timeoutResolved;
                if (!(timeoutResolved || asyncTasksResolved)) return [3 /*break*/, 6];
                asyncRenderTasksList.forEach(function (task) { return task.cancel(); });
                return [4 /*yield*/, cancel(timeout)];
            case 5:
                _b.sent();
                return [2 /*return*/];
            case 6:
                if (!asyncRenderRequested) return [3 /*break*/, 8];
                asyncRenderId = asyncRenderRequested.payload.id;
                // Check whether async render is already registered.
                // If so, skip it, because possible re-executions are covered in the async render task itself.
                if (asyncRenderTasks.has(asyncRenderId)) {
                    return [3 /*break*/, 3];
                }
                return [4 /*yield*/, spawn(waitForAsyncRenderResolution, asyncRenderId, config)];
            case 7:
                asyncRenderTask = _b.sent();
                asyncRenderTasks.set(asyncRenderId, asyncRenderTask);
                _b.label = 8;
            case 8: return [3 /*break*/, 3];
            case 9: return [2 /*return*/];
        }
    });
}
function waitForAsyncRenderResolution(id, config) {
    var maxRetries, retries, renderResolvedChannel, timeout;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                maxRetries = 3;
                retries = 0;
                return [4 /*yield*/, actionChannel(isAsyncRenderResolvedEvent(id))];
            case 1:
                renderResolvedChannel = _a.sent();
                _a.label = 2;
            case 2:
                if (!true) return [3 /*break*/, 5];
                return [4 /*yield*/, take(renderResolvedChannel)];
            case 3:
                _a.sent();
                return [4 /*yield*/, race({
                        timeout: call(wait, config.asyncRenderResolvedTimeout),
                        anotherExecution: take(isAsyncRenderRequestedEvent(id)),
                    })];
            case 4:
                timeout = (_a.sent()).timeout;
                retries += 1;
                // No re-execution, or max retry limit reached - leave the loop
                if (timeout || retries === maxRetries) {
                    return [2 /*return*/];
                }
                return [3 /*break*/, 2];
            case 5: return [2 /*return*/];
        }
    });
}
//# sourceMappingURL=renderingWorker.js.map