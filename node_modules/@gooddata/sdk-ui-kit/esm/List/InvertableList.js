import { __extends, __read, __spread } from "tslib";
// (C) 2007-2020 GoodData Corporation
import React, { Component } from "react";
import { FormattedMessage, injectIntl } from "react-intl";
import cx from "classnames";
import keyBy from "lodash/keyBy";
import values from "lodash/values";
import take from "lodash/take";
import has from "lodash/has";
import { Message } from "../Messages";
import { Input } from "../Form";
import { MultiSelectList } from "./MultiSelectList";
import { guidFor } from "./guid";
var NoItemsFound = function () {
    return (React.createElement("div", { className: "gd-list-noResults" },
        React.createElement(FormattedMessage, { id: "gs.list.noItemsFound" })));
};
var LoadingMessage = function () {
    return React.createElement("div", null, "...");
};
var LimitHitWarning = function (_a) {
    var limit = _a.limit, bounce = _a.bounce;
    var classes = cx("gd-list-limitExceeded", {
        "animation-fadeIn": bounce,
    });
    return (React.createElement(Message, { type: "warning", className: classes },
        React.createElement(FormattedMessage, { id: "gs.list.limitExceeded", values: { limit: limit } })));
};
/**
 * @internal
 */
var InvertableList = /** @class */ (function (_super) {
    __extends(InvertableList, _super);
    function InvertableList(props) {
        var _this = _super.call(this, props) || this;
        _this.onSelect = function (item) {
            var newSelection = _this.toggleItemInSelection(item);
            if (newSelection.length <= _this.props.maxSelectionSize) {
                _this.notifyUpstreamOfSelectionChange(newSelection);
            }
            if (newSelection.length >= _this.props.maxSelectionSize) {
                // Flash the limit exceeded info
                _this.setState({
                    notifyLimitHit: true,
                });
                // remove the class that causes flashing animation
                setTimeout(function () {
                    _this.setState({
                        notifyLimitHit: false,
                    });
                }, 1000);
            }
        };
        _this.onSelectAll = function () {
            if (_this.props.searchString) {
                if (_this.props.isInverted) {
                    _this.shrinkSelection();
                }
                else {
                    _this.growSelection();
                }
            }
            else {
                _this.props.onSelect([], true);
            }
        };
        _this.onSelectNone = function () {
            if (_this.props.searchString) {
                if (_this.props.isInverted) {
                    _this.growSelection();
                }
                else {
                    _this.shrinkSelection();
                }
            }
            else {
                _this.props.onSelect([], false);
            }
        };
        _this.onSelectOnly = function (item) {
            _this.props.onSelect([item], false);
        };
        /**
         * Remove selected visible items from selection.
         */
        _this.shrinkSelection = function () {
            var _a = _this.props, items = _a.items, selectedItems = _a.selectedItems;
            var visibleSelection = _this.intersectItems(items, selectedItems);
            var newSelection = _this.subtractItems(selectedItems, visibleSelection);
            _this.notifyUpstreamOfSelectionChange(newSelection);
        };
        _this.intersectItems = function (items, otherItems) {
            var otherItemsMap = _this.indexByKey(otherItems);
            return items.filter(function (item) {
                var itemKey = _this.props.getItemKey(item);
                return !!otherItemsMap[itemKey];
            });
        };
        _this.subtractItems = function (items, otherItems) {
            var otherItemsMap = _this.indexByKey(otherItems);
            return items.filter(function (item) {
                var itemKey = _this.props.getItemKey(item);
                return !otherItemsMap[itemKey];
            });
        };
        _this.indexByKey = function (items) {
            if (items === void 0) { items = []; }
            return keyBy(items, _this.props.getItemKey);
        };
        _this.toggleItemInSelection = function (item) {
            var selectionMap = _this.indexByKey(_this.props.selectedItems);
            var itemKey = _this.props.getItemKey(item);
            if (selectionMap[itemKey]) {
                delete selectionMap[itemKey];
            }
            else {
                selectionMap[itemKey] = item;
            }
            return values(selectionMap);
        };
        /**
         * Add unselected visible items to the selection until selection size limit is reached.
         */
        _this.growSelection = function () {
            var _a = _this.props, maxSelectionSize = _a.maxSelectionSize, items = _a.items, selectedItems = _a.selectedItems;
            var selectionSizeLeft = maxSelectionSize - selectedItems.length;
            var selectableItems = _this.subtractItems(items, selectedItems);
            var itemsToSelect = take(selectableItems, selectionSizeLeft);
            var newSelection = __spread(selectedItems, itemsToSelect);
            _this.notifyUpstreamOfSelectionChange(newSelection);
        };
        /**
         * If change in selection happens to select all or unselect all items it is converted
         * to the respective empty selectionj.
         */
        _this.notifyUpstreamOfSelectionChange = function (newSelection) {
            var itemsCount = _this.props.itemsCount;
            var isInverted = _this.props.isInverted;
            var selection;
            var lastItemSelected = !isInverted && newSelection.length === itemsCount;
            if (lastItemSelected) {
                selection = [];
                isInverted = !isInverted;
            }
            else {
                selection = newSelection;
            }
            _this.props.onSelect(selection, isInverted);
        };
        _this.isItemChecked = function (selectionMap, item) {
            var key = _this.props.getItemKey(item);
            var itemInSelection = has(selectionMap, key);
            // in inverted mode selection lists unchecked items
            // in normal mode selection contains checked items
            return _this.props.isInverted ? !itemInSelection : itemInSelection;
        };
        _this.renderLimitHitWarning = function () {
            var _a = _this.props, maxSelectionSize = _a.maxSelectionSize, selectedItems = _a.selectedItems, renderLimitHit = _a.renderLimitHit;
            var limitHit = selectedItems.length >= maxSelectionSize;
            if (limitHit) {
                return renderLimitHit({
                    limit: maxSelectionSize,
                    bounce: _this.state.notifyLimitHit,
                });
            }
            return null;
        };
        _this.renderSearchField = function () {
            return _this.props.showSearchField ? (React.createElement(Input, { autofocus: true, className: "gd-list-searchfield gd-flex-item-mobile", clearOnEsc: true, isSearch: true, isSmall: _this.props.smallSearch, onChange: _this.props.onSearch, placeholder: _this.props.searchPlaceholder, value: _this.props.searchString })) : null;
        };
        _this.renderList = function () {
            return _this.props.isLoading ? (_this.renderLoading()) : (React.createElement("div", { className: "gd-flex-item-stretch-mobile gd-flex-row-container-mobile" },
                _this.renderListOrNoItems(),
                _this.renderLimitHitWarning()));
        };
        _this.renderListOrNoItems = function () {
            var _a = _this.props, items = _a.items, searchString = _a.searchString, filteredItemsCount = _a.filteredItemsCount, height = _a.height, selectedItems = _a.selectedItems, onScrollEnd = _a.onScrollEnd, tagName = _a.tagName, renderItem = _a.renderItem, renderNoItems = _a.renderNoItems;
            if (searchString && filteredItemsCount === 0) {
                return renderNoItems({ height: height });
            }
            var selectionMap = _this.indexByKey(selectedItems);
            var isChecked = _this.isItemChecked.bind(_this, selectionMap);
            return (React.createElement(MultiSelectList, { items: items, itemsCount: filteredItemsCount, renderItem: function (_a) {
                    var isSelected = _a.isSelected, item = _a.item;
                    return renderItem({
                        isSelected: isSelected,
                        item: item,
                        onSelect: _this.onSelect,
                        onSelectOnly: _this.onSelectOnly,
                    });
                }, isSelected: isChecked, isSearching: !!searchString.length, onSelectAll: _this.onSelectAll, onSelectNone: _this.onSelectNone, onScrollEnd: onScrollEnd, tagName: tagName }));
        };
        _this.renderLoading = function () {
            var _a = _this.props, height = _a.height, renderLoading = _a.renderLoading;
            return renderLoading({ height: height });
        };
        _this.state = {
            notifyLimitHit: false,
        };
        return _this;
    }
    InvertableList.prototype.render = function () {
        var _a = this.props, isMobile = _a.isMobile, className = _a.className;
        var classNames = cx(className, {
            "gd-flex-item-stretch-mobile": isMobile,
            "gd-flex-row-container-mobile": isMobile,
        });
        return (React.createElement("div", { className: classNames },
            this.renderSearchField(),
            this.renderList()));
    };
    InvertableList.defaultProps = {
        getItemKey: guidFor,
        isInverted: true,
        showSearchField: true,
        renderLimitHit: function (_a) {
            var limit = _a.limit, bounce = _a.bounce;
            return React.createElement(LimitHitWarning, { limit: limit, bounce: bounce });
        },
        renderNoItems: function () { return React.createElement(NoItemsFound, null); },
        renderLoading: function () { return React.createElement(LoadingMessage, null); },
    };
    return InvertableList;
}(Component));
export { InvertableList };
/**
 * @internal
 */
var InvertableListWithIntl = injectIntl(InvertableList);
export default InvertableListWithIntl;
//# sourceMappingURL=InvertableList.js.map