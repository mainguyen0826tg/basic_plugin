import { __assign, __spreadArrays } from "tslib";
import { isBubbleChart, isHeatmap, isOneOfTypes, isScatterPlot, isTreemap, unwrap } from "../_util/common";
import omit from "lodash/omit";
import { getDrillIntersection, isSomeHeaderPredicateMatched, } from "@gooddata/sdk-ui";
import { multiMeasuresAlternatingTypes } from "./chartCapabilities";
import { findMeasureGroupInDimensions } from "../_util/executionResultHelper";
import without from "lodash/without";
function getViewBy(viewByAttribute, viewByIndex) {
    var viewByHeader = null;
    var viewByItem = null;
    var viewByAttributeDescriptor = null;
    if (viewByAttribute) {
        viewByHeader = viewByAttribute.items[viewByIndex];
        viewByItem = __assign(__assign({}, unwrap(viewByHeader)), { attribute: viewByAttribute });
        viewByAttributeDescriptor = { attributeHeader: omit(viewByAttribute, "items") };
    }
    return {
        viewByHeader: viewByHeader,
        viewByItem: viewByItem,
        viewByAttributeDescriptor: viewByAttributeDescriptor,
    };
}
function getStackBy(stackByAttribute, stackByIndex) {
    var stackByHeader = null;
    var stackByItem = null;
    var stackByAttributeDescriptor = null;
    if (stackByAttribute) {
        // stackBy item index is always equal to seriesIndex
        stackByHeader = stackByAttribute.items[stackByIndex];
        stackByItem = __assign(__assign({}, unwrap(stackByHeader)), { attribute: stackByAttribute });
        stackByAttributeDescriptor = { attributeHeader: omit(stackByAttribute, "items") };
    }
    return {
        stackByHeader: stackByHeader,
        stackByItem: stackByItem,
        stackByAttributeDescriptor: stackByAttributeDescriptor,
    };
}
export function getDrillableSeries(dv, series, drillableItems, viewByAttributes, stackByAttribute, type) {
    var viewByChildAttribute = viewByAttributes[0], viewByParentAttribute = viewByAttributes[1];
    var isMultiMeasureWithOnlyMeasures = isOneOfTypes(type, multiMeasuresAlternatingTypes) && !viewByChildAttribute;
    var measureGroup = findMeasureGroupInDimensions(dv.meta().dimensions());
    return series.map(function (seriesItem) {
        var seriesIndex = seriesItem.seriesIndex;
        var isSeriesDrillable = false;
        var data = seriesItem.data &&
            seriesItem.data.map(function (pointData, pointIndex) {
                var _a, _b;
                var measureHeaders = [];
                var isStackedTreemap = isTreemap(type) && !!stackByAttribute;
                if (isScatterPlot(type)) {
                    measureHeaders = ((_a = measureGroup.items) !== null && _a !== void 0 ? _a : []).slice(0, 2);
                }
                else if (isBubbleChart(type)) {
                    measureHeaders = ((_b = measureGroup.items) !== null && _b !== void 0 ? _b : []).slice(0, 3);
                }
                else if (isStackedTreemap) {
                    if (pointData.id !== undefined) {
                        // not leaf -> can't be drillable
                        return pointData;
                    }
                    var measureIndex = viewByChildAttribute ? 0 : parseInt(pointData.parent, 10);
                    measureHeaders = [measureGroup.items[measureIndex]];
                }
                else {
                    // measureIndex is usually seriesIndex,
                    // except for stack by attribute and metricOnly pie or donut chart
                    // it is looped-around pointIndex instead
                    // Looping around the end of items array only works when
                    // measureGroup is the last header on it's dimension
                    // We do not support setups with measureGroup before attributeHeaders
                    var measureIndex = !stackByAttribute && !isMultiMeasureWithOnlyMeasures
                        ? seriesIndex
                        : pointIndex % measureGroup.items.length;
                    measureHeaders = [measureGroup.items[measureIndex]];
                }
                var viewByIndex = isHeatmap(type) || isStackedTreemap ? pointData.x : pointIndex;
                var stackByIndex = isHeatmap(type) || isStackedTreemap ? pointData.y : seriesIndex;
                if (isScatterPlot(type)) {
                    stackByIndex = viewByIndex; // scatter plot uses stack by attribute but has only one serie
                }
                var _c = getStackBy(stackByAttribute, stackByIndex), stackByHeader = _c.stackByHeader, stackByAttributeDescriptor = _c.stackByAttributeDescriptor;
                var _d = getViewBy(viewByChildAttribute, viewByIndex), viewByChildHeader = _d.viewByHeader, viewByChildAttributeDescriptor = _d.viewByAttributeDescriptor;
                var _e = getViewBy(viewByParentAttribute, viewByIndex), viewByParentHeader = _e.viewByHeader, viewByParentdAttributeDescriptor = _e.viewByAttributeDescriptor;
                // point is drillable if a drillableItem matches:
                //   point's measure,
                //   point's viewBy attribute,
                //   point's viewBy attribute item,
                //   point's stackBy attribute,
                //   point's stackBy attribute item,
                var drillableHooks = without(__spreadArrays(measureHeaders, [
                    viewByChildAttributeDescriptor,
                    viewByChildHeader,
                    viewByParentdAttributeDescriptor,
                    viewByParentHeader,
                    stackByAttributeDescriptor,
                    stackByHeader,
                ]), null);
                var drilldown = drillableHooks.some(function (drillableHook) {
                    return isSomeHeaderPredicateMatched(drillableItems, drillableHook, dv);
                });
                var drillableProps = {
                    drilldown: drilldown,
                };
                if (drilldown) {
                    var headers = __spreadArrays(measureHeaders, [
                        viewByChildHeader,
                        viewByChildAttributeDescriptor,
                        viewByParentHeader,
                        viewByParentdAttributeDescriptor,
                        stackByHeader,
                        stackByAttributeDescriptor,
                    ]);
                    var sanitizedHeaders = without(__spreadArrays(headers), null);
                    drillableProps.drillIntersection = getDrillIntersection(sanitizedHeaders);
                    isSeriesDrillable = true;
                }
                return __assign(__assign({}, pointData), drillableProps);
            });
        if (isScatterPlot(type)) {
            data = data.filter(function (dataItem) {
                return dataItem.x !== null && dataItem.y !== null;
            });
        }
        return __assign(__assign({}, seriesItem), { data: data, isDrillable: isSeriesDrillable });
    });
}
//# sourceMappingURL=chartDrilling.js.map