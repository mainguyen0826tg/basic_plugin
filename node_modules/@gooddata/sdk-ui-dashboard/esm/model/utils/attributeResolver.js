import { __awaiter, __generator } from "tslib";
import { selectAllCatalogAttributesMap } from "../store/catalog/catalogSelectors";
import { call, select } from "redux-saga/effects";
import { newAttributeMap } from "../../_staging/metadata/objRefMap";
function loadAttributesMetadata(ctx, refs) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (!refs.length) {
                return [2 /*return*/, []];
            }
            return [2 /*return*/, ctx.backend.workspace(ctx.workspace).attributes().getAttributes(refs)];
        });
    });
}
/**
 * Given a set of attribute refs (which may be of any type.. uri or id), this function returns a list of
 * attribute metadata objects.
 *
 * @param ctx dashboard context in which the resolution is done
 * @param refs ObjRefs of display forms; the type of ObjRef can be either uri or id ref, the function will resolve it regardless
 * @param attributes optionally specify mapping of attributes to use for in-memory resolution of refs to metadata objects; if
 *  not specified, the generator will retrieve all catalog attributes from state
 */
export function resolveAttributeMetadata(ctx, refs, attributes) {
    var catalogAttributes, _a, resolvedAttributes, tryLoadAttributes, loadedAttributes, loadedAttributesMap, missing;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                if (!attributes) return [3 /*break*/, 1];
                _a = attributes;
                return [3 /*break*/, 3];
            case 1: return [4 /*yield*/, select(selectAllCatalogAttributesMap)];
            case 2:
                _a = _b.sent();
                _b.label = 3;
            case 3:
                catalogAttributes = _a;
                resolvedAttributes = [];
                tryLoadAttributes = [];
                refs.forEach(function (ref) {
                    var catalogAttribute = catalogAttributes.get(ref);
                    if (catalogAttribute) {
                        resolvedAttributes.push(catalogAttribute.attribute);
                    }
                    else {
                        tryLoadAttributes.push(ref);
                    }
                });
                return [4 /*yield*/, call(loadAttributesMetadata, ctx, tryLoadAttributes)];
            case 4:
                loadedAttributes = _b.sent();
                loadedAttributesMap = newAttributeMap(loadedAttributes);
                missing = [];
                tryLoadAttributes.forEach(function (ref) {
                    var loadedAttribute = loadedAttributesMap.get(ref);
                    if (loadedAttribute) {
                        resolvedAttributes.push(loadedAttribute);
                    }
                    else {
                        missing.push(ref);
                    }
                });
                return [2 /*return*/, {
                        resolved: newAttributeMap(resolvedAttributes),
                        missing: missing,
                    }];
        }
    });
}
//# sourceMappingURL=attributeResolver.js.map