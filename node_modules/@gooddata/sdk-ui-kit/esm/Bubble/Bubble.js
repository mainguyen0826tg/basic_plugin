import { __assign, __extends } from "tslib";
// (C) 2020 GoodData Corporation
import React from "react";
import keys from "lodash/keys";
import cloneDeep from "lodash/cloneDeep";
import isEqual from "lodash/isEqual";
import result from "lodash/result";
import noop from "lodash/noop";
import cx from "classnames";
import { Overlay } from "../Overlay";
var ARROW_DIRECTIONS = {
    ".. cc": "none",
    ".r .l|.. cl": "left",
    ".l .r|.. cr": "right",
    ".. t.": "top",
    ".. b.": "bottom",
    ".. .l": "left",
    ".. .r": "right",
};
// FIXME: hardcoded offsets for Indigo style
export var X_SHIFT = 7;
export var Y_SHIFT = 11;
// FIXME: constants are bad, we know :(
var ARROW_OFFSETS = {
    ".. cc": [0, 0],
    ".. tc": [0, X_SHIFT],
    ".. bc": [0, -X_SHIFT],
    ".. cl": [X_SHIFT, 0],
    ".. cr": [-X_SHIFT, 0],
    ".r tl": [X_SHIFT, -Y_SHIFT],
    ".l tr": [-X_SHIFT, -Y_SHIFT],
    ".r bl": [X_SHIFT, Y_SHIFT],
    ".l br": [-X_SHIFT, Y_SHIFT],
    ".. tl": [-Y_SHIFT, X_SHIFT],
    ".. tr": [Y_SHIFT, X_SHIFT],
    ".. bl": [-Y_SHIFT, -X_SHIFT],
    ".. br": [Y_SHIFT, -X_SHIFT],
};
/**
 * @internal
 */
var Bubble = /** @class */ (function (_super) {
    __extends(Bubble, _super);
    function Bubble(props) {
        var _this = _super.call(this, props) || this;
        _this.onAlign = function (alignment) {
            _this.setState({ optimalAlignPoints: alignment.align });
        };
        _this.arrowOffsets = __assign(__assign({}, props.arrowOffsets), ARROW_OFFSETS);
        _this.arrowDirections = __assign(__assign({}, props.arrowDirections), ARROW_DIRECTIONS);
        var alignPoints = _this.addOffsetToAlignPoints(cloneDeep(props.alignPoints));
        _this.state = {
            alignPoints: alignPoints,
            optimalAlignPoints: props.alignPoints[0].align,
        };
        return _this;
    }
    Bubble.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var propsChanged = !isEqual(this.props, nextProps);
        var alignmentChanged = !isEqual(this.state.optimalAlignPoints, nextState.optimalAlignPoints);
        return propsChanged || alignmentChanged;
    };
    Bubble.prototype.getClassnames = function () {
        var _a;
        return cx((_a = {},
            _a[this.props.className] = !!this.props.className,
            _a[this.getArrowsClassname(this.state.optimalAlignPoints)] = true,
            _a["gd-bubble"] = true,
            _a.bubble = true,
            _a));
    };
    Bubble.prototype.getArrowsClassname = function (alignPoints) {
        var myAlignPoint = alignPoints.split(" ")[1];
        var direction = this.getArrowDirection(alignPoints);
        return "arrow-" + direction + "-direction arrow-" + myAlignPoint;
    };
    Bubble.prototype.getArrowDirection = function (alignPoints) {
        var key = keys(this.arrowDirections).find(function (arrowDirection) { return alignPoints.match(arrowDirection); });
        return this.arrowDirections[key] || "none";
    };
    Bubble.prototype.addOffsetToAlignPoints = function (alignPoints) {
        var _this = this;
        var arrowOffsets = this.arrowOffsets;
        var arrowOffsetsKeys = keys(arrowOffsets);
        var getKey = function (align, re) {
            return align.match(re) !== null;
        };
        return alignPoints.map(function (item) {
            var key = arrowOffsetsKeys.find(getKey.bind(_this, item.align));
            item.offset = item.offset || { x: 0, y: 0 };
            item.offset.x += arrowOffsets[key][0];
            item.offset.y += arrowOffsets[key][1];
            return item;
        }, this);
    };
    Bubble.prototype.render = function () {
        var arrowStyle = result(this.props, "arrowStyle", {});
        return (React.createElement(Overlay, { className: this.props.overlayClassName, alignTo: this.props.alignTo, onAlign: this.onAlign, alignPoints: this.state.alignPoints, closeOnParentScroll: true, closeOnMouseDrag: true, closeOnOutsideClick: this.props.closeOnOutsideClick, ignoreClicksOn: this.props.ignoreClicksOn, ignoreClicksOnByClass: this.props.ignoreClicksOnByClass, onClose: this.props.onClose },
            React.createElement("div", { onMouseEnter: this.props.onMouseEnter, onMouseLeave: this.props.onMouseLeave, className: this.getClassnames() },
                React.createElement("div", { className: "bubble-content" },
                    React.createElement("div", { className: "helper" }),
                    React.createElement("div", { className: "arrow-position", style: arrowStyle },
                        React.createElement("div", { className: "arrow-border" }),
                        React.createElement("div", { className: "arrow" })),
                    React.createElement("div", { className: "content" }, this.props.children)))));
    };
    Bubble.defaultProps = {
        alignPoints: [
            {
                align: "bl tl",
            },
        ],
        alignTo: "body",
        arrowOffsets: {},
        arrowDirections: {},
        arrowStyle: {},
        className: "bubble-primary",
        closeOnOutsideClick: false,
        onClose: noop,
        onMouseEnter: noop,
        onMouseLeave: noop,
        overlayClassName: "",
    };
    // identifier for BubbleTrigger
    Bubble.identifier = "Bubble";
    return Bubble;
}(React.Component));
export { Bubble };
//# sourceMappingURL=Bubble.js.map