import { __extends, __spreadArrays } from "tslib";
// (C) 2019 GoodData Corporation
import set from "lodash/set";
import cloneDeep from "lodash/cloneDeep";
import { bucketIsEmpty, bucketsItems, insightBucket, insightBuckets, } from "@gooddata/sdk-model";
import { arrayUtils } from "@gooddata/util";
import { BucketNames, getIntersectionPartAfter, } from "@gooddata/sdk-ui";
import { AXIS } from "../../constants/axis";
import { ATTRIBUTE, BUCKETS, DATE } from "../../constants/bucket";
import { COLUMN_BAR_CHART_UICONFIG, COLUMN_BAR_CHART_UICONFIG_WITH_MULTIPLE_DATES, MAX_CATEGORIES_COUNT, MAX_STACKS_COUNT, } from "../../constants/uiConfig";
import { drillDownFromAttributeLocalId } from "../../utils/ImplicitDrillDownHelper";
import { getAllCategoriesAttributeItems, getDateItems, getFilteredMeasuresForStackedCharts, getMainDateItem, getStackItems, removeDivergentDateItems, isDateBucketItem, isNotDateBucketItem, hasSameDateDimension, } from "../../utils/bucketHelper";
import { getReferencePointWithSupportedProperties, isStackingMeasure, isStackingToPercent, removeImmutableOptionalStackingProperties, setSecondaryMeasures, } from "../../utils/propertiesHelper";
import { setColumnBarChartUiConfig } from "../../utils/uiConfigHelpers/columnBarChartUiConfigHelper";
import { PluggableBaseChart } from "./baseChart/PluggableBaseChart";
import { addIntersectionFiltersToInsight, modifyBucketsAttributesForDrillDown } from "./drillDownUtil";
var PluggableColumnBarCharts = /** @class */ (function (_super) {
    __extends(PluggableColumnBarCharts, _super);
    function PluggableColumnBarCharts(props) {
        var _this = _super.call(this, props) || this;
        // set default to DUAL to get the full supported props list
        // and will be updated in getExtendedReferencePoint
        _this.axis = AXIS.DUAL;
        _this.supportedPropertiesList = _this.getSupportedPropertiesList();
        return _this;
    }
    PluggableColumnBarCharts.prototype.getUiConfig = function () {
        var config = this.isMultipleDatesEnabled()
            ? COLUMN_BAR_CHART_UICONFIG_WITH_MULTIPLE_DATES
            : COLUMN_BAR_CHART_UICONFIG;
        return cloneDeep(config);
    };
    PluggableColumnBarCharts.prototype.getExtendedReferencePoint = function (referencePoint) {
        var _this = this;
        // reset the list to retrieve full 'referencePoint.properties.controls'
        this.supportedPropertiesList = this.getSupportedPropertiesList();
        return _super.prototype.getExtendedReferencePoint.call(this, referencePoint).then(function (ext) {
            var _a, _b;
            var newExt = setSecondaryMeasures(ext, _this.secondaryAxis);
            _this.axis = (_b = (_a = newExt === null || newExt === void 0 ? void 0 : newExt.uiConfig) === null || _a === void 0 ? void 0 : _a.axis) !== null && _b !== void 0 ? _b : AXIS.PRIMARY;
            // filter out unnecessary stacking props for some specific cases such as one measure or empty stackBy
            _this.supportedPropertiesList = removeImmutableOptionalStackingProperties(newExt, _this.getSupportedPropertiesList());
            newExt = getReferencePointWithSupportedProperties(newExt, _this.supportedPropertiesList);
            return setColumnBarChartUiConfig(newExt, _this.intl);
        });
    };
    PluggableColumnBarCharts.prototype.isOpenAsReportSupported = function () {
        return (_super.prototype.isOpenAsReportSupported.call(this) &&
            !haveManyViewItems(this.currentInsight) &&
            !isStackingMeasure(this.visualizationProperties) &&
            !isStackingToPercent(this.visualizationProperties));
    };
    PluggableColumnBarCharts.prototype.adjustIntersectionForColumnBar = function (source, event) {
        var stackBucket = insightBucket(source, BucketNames.STACK);
        var hasStackByAttributes = stackBucket && !bucketIsEmpty(stackBucket);
        var intersection = event.drillContext.intersection;
        return hasStackByAttributes ? arrayUtils.shiftArrayRight(intersection) : intersection;
    };
    PluggableColumnBarCharts.prototype.addFiltersForColumnBar = function (source, drillConfig, event) {
        var clicked = drillDownFromAttributeLocalId(drillConfig);
        var reorderedIntersection = this.adjustIntersectionForColumnBar(source, event);
        var cutIntersection = getIntersectionPartAfter(reorderedIntersection, clicked);
        return addIntersectionFiltersToInsight(source, cutIntersection);
    };
    PluggableColumnBarCharts.prototype.getInsightWithDrillDownApplied = function (source, drillDownContext) {
        var withFilters = this.addFiltersForColumnBar(source, drillDownContext.drillDefinition, drillDownContext.event);
        return modifyBucketsAttributesForDrillDown(withFilters, drillDownContext.drillDefinition);
    };
    PluggableColumnBarCharts.prototype.configureBuckets = function (extendedReferencePoint) {
        var _a, _b, _c, _d, _e;
        if (this.isMultipleDatesEnabled()) {
            this.configureBucketsWithMultipleDates(extendedReferencePoint);
            return;
        }
        var buckets = (_a = extendedReferencePoint === null || extendedReferencePoint === void 0 ? void 0 : extendedReferencePoint.buckets) !== null && _a !== void 0 ? _a : [];
        var measures = getFilteredMeasuresForStackedCharts(buckets);
        var dateItems = getDateItems(buckets);
        var mainDateItem = getMainDateItem(dateItems);
        var categoriesCount = (_e = (_d = (_c = (_b = extendedReferencePoint.uiConfig) === null || _b === void 0 ? void 0 : _b.buckets) === null || _c === void 0 ? void 0 : _c[BucketNames.VIEW]) === null || _d === void 0 ? void 0 : _d.itemsLimit) !== null && _e !== void 0 ? _e : MAX_CATEGORIES_COUNT;
        var allAttributesWithoutStacks = getAllCategoriesAttributeItems(buckets);
        var allAttributesWithoutStacksWithDatesHandled = removeDivergentDateItems(allAttributesWithoutStacks, mainDateItem);
        var views = allAttributesWithoutStacksWithDatesHandled.slice(0, categoriesCount);
        var hasDateItemInViewByBucket = views.some(isDateBucketItem);
        var stackItemIndex = categoriesCount;
        var stacks = getStackItems(buckets);
        if (dateItems.length && !hasDateItemInViewByBucket) {
            var extraViewItems = allAttributesWithoutStacksWithDatesHandled.slice(0, categoriesCount - 1);
            views = __spreadArrays([mainDateItem], extraViewItems);
            stackItemIndex = categoriesCount - 1;
        }
        var hasSomeRemainingAttributes = allAttributesWithoutStacksWithDatesHandled.length > stackItemIndex;
        if (!stacks.length && measures.length <= 1 && hasSomeRemainingAttributes) {
            stacks = allAttributesWithoutStacksWithDatesHandled
                .slice(stackItemIndex, allAttributesWithoutStacksWithDatesHandled.length)
                .filter(isNotDateBucketItem)
                .slice(0, MAX_STACKS_COUNT);
        }
        set(extendedReferencePoint, BUCKETS, [
            {
                localIdentifier: BucketNames.MEASURES,
                items: measures,
            },
            {
                localIdentifier: BucketNames.VIEW,
                items: views,
            },
            {
                localIdentifier: BucketNames.STACK,
                items: stacks,
            },
        ]);
    };
    PluggableColumnBarCharts.prototype.configureBucketsWithMultipleDates = function (extendedReferencePoint) {
        var _a = this.getMeasuresViewStackBucketItems(extendedReferencePoint), measures = _a.measures, views = _a.views, stacks = _a.stacks;
        set(extendedReferencePoint, BUCKETS, [
            {
                localIdentifier: BucketNames.MEASURES,
                items: measures,
            },
            {
                localIdentifier: BucketNames.VIEW,
                items: views,
            },
            {
                localIdentifier: BucketNames.STACK,
                items: stacks,
            },
        ]);
    };
    PluggableColumnBarCharts.prototype.canPutAttributeToViewBy = function (currentAttribute, firstAttribute, viewByCount, viewByMaxItemCount) {
        var isFirstAttributeDate = isDateBucketItem(firstAttribute);
        var isCurrentAttributeDate = isDateBucketItem(currentAttribute);
        var sameDateDimension = hasSameDateDimension(firstAttribute, currentAttribute);
        return ((!isFirstAttributeDate || !isCurrentAttributeDate || sameDateDimension) &&
            viewByCount < viewByMaxItemCount);
    };
    PluggableColumnBarCharts.prototype.getMeasuresViewStackBucketItems = function (extendedReferencePoint) {
        var _a;
        var buckets = (_a = extendedReferencePoint === null || extendedReferencePoint === void 0 ? void 0 : extendedReferencePoint.buckets) !== null && _a !== void 0 ? _a : [];
        var measures = getFilteredMeasuresForStackedCharts(buckets);
        var viewByMaxItemCount = this.getViewByMaxItemCount(extendedReferencePoint);
        var stackByMaxItemCount = this.getStackByMaxItemCount(extendedReferencePoint);
        var allAttributesWithoutStacks = getAllCategoriesAttributeItems(buckets);
        var stacks = getStackItems(buckets, [ATTRIBUTE, DATE]);
        var firstAttribute = allAttributesWithoutStacks[0], remainingAttributes = allAttributesWithoutStacks.slice(1);
        var views = firstAttribute ? [firstAttribute] : [];
        var possibleStacks = [];
        for (var _i = 0, remainingAttributes_1 = remainingAttributes; _i < remainingAttributes_1.length; _i++) {
            var currentAttribute = remainingAttributes_1[_i];
            var canPutToViewBy = this.canPutAttributeToViewBy(currentAttribute, firstAttribute, views.length, viewByMaxItemCount);
            if (canPutToViewBy) {
                views.push(currentAttribute);
            }
            else {
                possibleStacks.push(currentAttribute);
            }
        }
        if (!stacks.length && measures.length <= 1) {
            var finalStacks = __spreadArrays(stacks, possibleStacks).slice(0, stackByMaxItemCount);
            return { measures: measures, views: views, stacks: finalStacks };
        }
        return { measures: measures, views: views, stacks: stacks };
    };
    PluggableColumnBarCharts.prototype.getViewByMaxItemCount = function (extendedReferencePoint) {
        var _a, _b, _c, _d;
        return ((_d = (_c = (_b = (_a = extendedReferencePoint.uiConfig) === null || _a === void 0 ? void 0 : _a.buckets) === null || _b === void 0 ? void 0 : _b[BucketNames.VIEW]) === null || _c === void 0 ? void 0 : _c.itemsLimit) !== null && _d !== void 0 ? _d : MAX_CATEGORIES_COUNT);
    };
    PluggableColumnBarCharts.prototype.getStackByMaxItemCount = function (extendedReferencePoint) {
        var _a, _b, _c, _d;
        return (_d = (_c = (_b = (_a = extendedReferencePoint.uiConfig) === null || _a === void 0 ? void 0 : _a.buckets) === null || _b === void 0 ? void 0 : _b[BucketNames.STACK]) === null || _c === void 0 ? void 0 : _c.itemsLimit) !== null && _d !== void 0 ? _d : MAX_STACKS_COUNT;
    };
    return PluggableColumnBarCharts;
}(PluggableBaseChart));
export { PluggableColumnBarCharts };
function haveManyViewItems(insight) {
    return bucketsItems(insightBuckets(insight, BucketNames.VIEW)).length > 1;
}
//# sourceMappingURL=PluggableColumnBarCharts.js.map