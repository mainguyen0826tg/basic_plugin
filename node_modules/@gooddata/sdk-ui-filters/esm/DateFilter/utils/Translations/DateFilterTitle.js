// (C) 2019-2021 GoodData Corporation
import format from "date-fns/format";
import capitalize from "lodash/capitalize";
import isEqual from "lodash/isEqual";
import { getIntl } from "@gooddata/sdk-ui";
import { granularityIntlCodes } from "../../constants/i18n";
import { convertPlatformDateStringToDate } from "../DateConversions";
import { isAbsoluteDateFilterForm, isRelativeDateFilterForm, isAllTimeDateFilterOption, isAbsoluteDateFilterPreset, isRelativeDateFilterPreset, } from "@gooddata/sdk-backend-spi";
import { DEFAULT_DATE_FORMAT } from "../../constants/Platform";
export var formatAbsoluteDate = function (date, dateFormat) { return format(date, dateFormat); };
export var formatAbsoluteDateRange = function (from, to, dateFormat) {
    var fromDate = convertPlatformDateStringToDate(from);
    var toDate = convertPlatformDateStringToDate(to);
    var fromTitle = formatAbsoluteDate(fromDate, dateFormat);
    var toTitle = formatAbsoluteDate(toDate, dateFormat);
    if (isEqual(fromTitle, toTitle)) {
        return fromTitle;
    }
    return fromTitle + "\u2013" + toTitle;
};
var relativeDateRangeFormatters = [
    {
        // Today, This month
        predicate: function (from, to) { return from === 0 && to === 0; },
        formatter: function (_from, _to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.this" + capitalize(intlGranularity) + ".title" });
        },
    },
    {
        // Tomorrow, Next month
        predicate: function (from, to) { return from === 1 && to === 1; },
        formatter: function (_from, _to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.next" + capitalize(intlGranularity) + ".title" });
        },
    },
    {
        // Yesterday, Last month
        predicate: function (from, to) { return from === -1 && to === -1; },
        formatter: function (_from, _to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.last" + capitalize(intlGranularity) + ".title" });
        },
    },
    {
        // Next N days (months)
        predicate: function (from) { return from === 0; },
        formatter: function (_from, to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.nextN" + capitalize(intlGranularity) + "s" }, { n: Math.abs(to) + 1 });
        },
    },
    {
        // Last N days (months)
        predicate: function (_from, to) { return to === 0; },
        formatter: function (from, _to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.lastN" + capitalize(intlGranularity) + "s" }, { n: Math.abs(from) + 1 });
        },
    },
    {
        // From N days ago to N days ago
        predicate: function (from, to) { return from < 0 && from === to; },
        formatter: function (from, _to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.interval." + intlGranularity + "s.past.sameValue" }, { value: Math.abs(from) });
        },
    },
    {
        // From N days ago to N days ahead
        predicate: function (from, to) { return from > 0 && from === to; },
        formatter: function (from, _to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.interval." + intlGranularity + "s.future.sameValue" }, { value: Math.abs(from) });
        },
    },
    {
        // From N days ago to M days ago
        predicate: function (from, to) { return from < 0 && to < 0; },
        formatter: function (from, to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.interval." + intlGranularity + "s.past" }, {
                from: Math.abs(from),
                to: Math.abs(to),
            });
        },
    },
    {
        // From N days ahead to M days ahead
        predicate: function (from, to) { return from > 0 && to > 0; },
        formatter: function (from, to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.interval." + intlGranularity + "s.future" }, {
                from: Math.abs(from),
                to: Math.abs(to),
            });
        },
    },
    {
        // From N days ago to M days ahead
        predicate: function () { return true; },
        formatter: function (from, to, intlGranularity, translator) {
            return translator.formatMessage({ id: "filters.interval." + intlGranularity + "s.mixed" }, {
                from: Math.abs(from),
                to: Math.abs(to),
            });
        },
    },
];
export var formatRelativeDateRange = function (from, to, granularity, translator) {
    var intlGranularity = granularityIntlCodes[granularity];
    var formatter = relativeDateRangeFormatters.find(function (f) { return f.predicate(from, to); }).formatter;
    return formatter(from, to, intlGranularity, translator);
};
var getAllTimeFilterRepresentation = function (translator) {
    return translator.formatMessage({ id: "filters.allTime.title" });
};
var getAbsoluteFormFilterRepresentation = function (filter, dateFormat) {
    return filter.from && filter.to ? formatAbsoluteDateRange(filter.from, filter.to, dateFormat) : "";
};
var getAbsolutePresetFilterRepresentation = function (filter, dateFormat) { return formatAbsoluteDateRange(filter.from, filter.to, dateFormat); };
var getRelativeFormFilterRepresentation = function (filter, translator) {
    return typeof filter.from === "number" && typeof filter.to === "number"
        ? formatRelativeDateRange(filter.from, filter.to, filter.granularity, translator)
        : "";
};
var getRelativePresetFilterRepresentation = function (filter, translator) { return formatRelativeDateRange(filter.from, filter.to, filter.granularity, translator); };
var getDateFilterRepresentationByFilterType = function (filter, translator, dateFormat) {
    if (isAbsoluteDateFilterForm(filter) || isRelativeDateFilterForm(filter)) {
        return getDateFilterRepresentationUsingTranslator(filter, translator, dateFormat);
    }
    else if (isAllTimeDateFilterOption(filter) ||
        isAbsoluteDateFilterPreset(filter) ||
        isRelativeDateFilterPreset(filter)) {
        return filter.name || getDateFilterRepresentationUsingTranslator(filter, translator, dateFormat);
    }
    else {
        throw new Error("Unknown DateFilterOption type");
    }
};
// excludeCurrentPeriod is extra metadata that is needed by translation, but it is only used by relative filters
// so the data structure is little inconsistent - for example when we translate absoluteForm we need to pass
// excludeCurrentPeriod that is completely unrelated to absolute filter and is not used in absolute translations.
// So in the future, if there will be need for more metadata, consider adding wrapper union type that would wrap
// DateFilterOption along with additional metadata related to given filter. eg.:
// | { filter: IRelativeDateFilterPreset, excludeCurrentPeriod: boolean } |
// | { filter: IAbsoluteFilterForm } |
// ...
/**
 * Gets the filter title favoring custom name if specified.
 * @returns {string} Representation of the filter (e.g. "My preset", "From 2 weeks ago to 1 week ahead")
 */
export var getDateFilterTitle = function (filter, locale, dateFormat) {
    if (dateFormat === void 0) { dateFormat = DEFAULT_DATE_FORMAT; }
    var translator = getIntl(locale);
    return getDateFilterRepresentationByFilterType(filter, translator, dateFormat);
};
/**
 * Gets the filter title favoring custom name if specified. This function is only for mock purpose.
 * @returns {string} Representation of the filter (e.g. "My preset", "From 2 weeks ago to 1 week ahead")
 */
export var getDateFilterTitleUsingTranslator = function (filter, translator, dateFormat) {
    if (dateFormat === void 0) { dateFormat = DEFAULT_DATE_FORMAT; }
    return getDateFilterRepresentationByFilterType(filter, translator, dateFormat);
};
/**
 * Gets the filter representation regardless of custom name.
 * @returns {string} Representation of the filter (e.g. "From 2 weeks ago to 1 week ahead")
 */
var getDateFilterRepresentationUsingTranslator = function (filter, translator, dateFormat) {
    if (isAbsoluteDateFilterForm(filter)) {
        return getAbsoluteFormFilterRepresentation(filter, dateFormat);
    }
    else if (isAbsoluteDateFilterPreset(filter)) {
        return getAbsolutePresetFilterRepresentation(filter, dateFormat);
    }
    else if (isAllTimeDateFilterOption(filter)) {
        return getAllTimeFilterRepresentation(translator);
    }
    else if (isRelativeDateFilterForm(filter)) {
        return getRelativeFormFilterRepresentation(filter, translator);
    }
    else if (isRelativeDateFilterPreset(filter)) {
        return getRelativePresetFilterRepresentation(filter, translator);
    }
    else {
        throw new Error("Unknown DateFilterOption type");
    }
};
export var getDateFilterRepresentation = function (filter, locale, dateFormat) {
    if (dateFormat === void 0) { dateFormat = DEFAULT_DATE_FORMAT; }
    var translator = getIntl(locale);
    return getDateFilterRepresentationUsingTranslator(filter, translator, dateFormat);
};
//# sourceMappingURL=DateFilterTitle.js.map