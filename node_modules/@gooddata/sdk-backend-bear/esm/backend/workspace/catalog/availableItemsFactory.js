import { __assign, __awaiter, __generator, __spreadArrays } from "tslib";
// (C) 2019-2021 GoodData Corporation
import { isCatalogAttribute, isCatalogMeasure, isCatalogFact, } from "@gooddata/sdk-backend-spi";
import { insightItems, isAttribute, isArithmeticMeasure, isSimpleMeasure, attributeDisplayFormRef, isIdentifierRef, modifyAttribute, uriRef, modifySimpleMeasure, measureItem, attributeLocalId, measureLocalId, measureMasterIdentifier, isPoPMeasure, isPreviousPeriodMeasure, isMeasure, measurePopAttribute, modifyPopMeasure, } from "@gooddata/sdk-model";
import { convertItemType, convertDateDataset, isCompatibleCatalogItemType, } from "../../../convertors/fromBackend/CatalogConverter";
import { convertInsightDefinition } from "../../../convertors/toBackend/InsightConverter";
import { BearWorkspaceCatalogWithAvailableItems } from "./catalogWithAvailableItems";
import { objRefToIdentifier, objRefsToIdentifiers } from "../../../utils/api";
import { InvariantError } from "ts-invariant";
var catalogItemUri = function (catalogItem) {
    if (isCatalogAttribute(catalogItem)) {
        return catalogItem.attribute.uri;
    }
    else if (isCatalogMeasure(catalogItem)) {
        return catalogItem.measure.uri;
    }
    else if (isCatalogFact(catalogItem)) {
        return catalogItem.fact.uri;
    }
    return catalogItem.dataSet.uri;
};
var BearWorkspaceCatalogAvailableItemsFactory = /** @class */ (function () {
    function BearWorkspaceCatalogAvailableItemsFactory(authCall, workspace, groups, items, options, mappings) {
        var _this = this;
        if (options === void 0) { options = {
            types: ["attribute", "measure", "fact", "dateDataset"],
            excludeTags: [],
            includeTags: [],
        }; }
        this.authCall = authCall;
        this.workspace = workspace;
        this.groups = groups;
        this.items = items;
        this.options = options;
        this.mappings = mappings;
        this.loadAvailableCatalogItems = function (sanitizedVisualizationObject) { return __awaiter(_this, void 0, void 0, function () {
            var types, compatibleBearItemTypes, bearTypes, itemDescriptions, availableItemUris;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        types = this.options.types;
                        compatibleBearItemTypes = types.filter(isCompatibleCatalogItemType);
                        if (compatibleBearItemTypes.length === 0) {
                            return [2 /*return*/, []];
                        }
                        bearTypes = compatibleBearItemTypes.map(convertItemType);
                        return [4 /*yield*/, this.authCall(function (sdk) {
                                return sdk.catalogue.loadItemDescriptionObjects(_this.workspace, sanitizedVisualizationObject.content, _this.mappings.attributeByDisplayFormUri);
                            })];
                    case 1:
                        itemDescriptions = _a.sent();
                        return [4 /*yield*/, this.authCall(function (sdk) {
                                return sdk.catalogue.loadAvailableItemUris(_this.workspace, {
                                    catalogQueryRequest: {
                                        bucketItems: itemDescriptions,
                                        types: bearTypes,
                                    },
                                });
                            })];
                    case 2:
                        availableItemUris = _a.sent();
                        return [2 /*return*/, this.items.filter(function (item) { return availableItemUris.includes(catalogItemUri(item)); })];
                }
            });
        }); };
        this.loadAvailableDateDatasets = function (sanitizedVisualizationObject) { return __awaiter(_this, void 0, void 0, function () {
            var _a, types, includeTags, excludeTags, dataset, production, includeDateGranularities, includeDateDatasets, _b, includeTagsIds, excludeTagsIds, dataSetIdentifier, shouldReturnAllDateDataSets, result;
            var _this = this;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        _a = this.options, types = _a.types, includeTags = _a.includeTags, excludeTags = _a.excludeTags, dataset = _a.dataset, production = _a.production, includeDateGranularities = _a.includeDateGranularities;
                        includeDateDatasets = types.includes("dateDataset");
                        if (!includeDateDatasets) {
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, Promise.all([
                                objRefsToIdentifiers(includeTags, this.authCall),
                                objRefsToIdentifiers(excludeTags, this.authCall),
                                dataset ? objRefToIdentifier(dataset, this.authCall) : Promise.resolve(""),
                            ])];
                    case 1:
                        _b = _c.sent(), includeTagsIds = _b[0], excludeTagsIds = _b[1], dataSetIdentifier = _b[2];
                        shouldReturnAllDateDataSets = !production && !dataSetIdentifier;
                        return [4 /*yield*/, this.authCall(function (sdk) {
                                return sdk.catalogue.loadDateDataSets(_this.workspace, {
                                    bucketItems: sanitizedVisualizationObject.content,
                                    includeAvailableDateAttributes: true,
                                    dataSetIdentifier: dataSetIdentifier,
                                    attributesMap: _this.mappings.attributeByDisplayFormUri,
                                    includeObjectsWithTags: includeTagsIds.length ? includeTagsIds : undefined,
                                    excludeObjectsWithTags: excludeTagsIds.length ? excludeTagsIds : undefined,
                                    returnAllDateDataSets: shouldReturnAllDateDataSets,
                                    includeDateGranularities: includeDateGranularities,
                                });
                            })];
                    case 2:
                        result = _c.sent();
                        return [2 /*return*/, result.dateDataSets.map(function (dateDataSet) {
                                return convertDateDataset(dateDataSet, _this.mappings.attributeById);
                            })];
                }
            });
        }); };
    }
    BearWorkspaceCatalogAvailableItemsFactory.prototype.withOptions = function (options) {
        var newOptions = __assign(__assign({}, this.options), options);
        return new BearWorkspaceCatalogAvailableItemsFactory(this.authCall, this.workspace, this.groups, this.items, newOptions, this.mappings);
    };
    BearWorkspaceCatalogAvailableItemsFactory.prototype.forDataset = function (dataset) {
        return this.withOptions({ dataset: dataset });
    };
    BearWorkspaceCatalogAvailableItemsFactory.prototype.forTypes = function (types) {
        return this.withOptions({ types: types });
    };
    BearWorkspaceCatalogAvailableItemsFactory.prototype.includeTags = function (tags) {
        return this.withOptions({ includeTags: tags });
    };
    BearWorkspaceCatalogAvailableItemsFactory.prototype.excludeTags = function (tags) {
        return this.withOptions({ excludeTags: tags });
    };
    BearWorkspaceCatalogAvailableItemsFactory.prototype.forItems = function (items) {
        return this.withOptions({ items: items });
    };
    BearWorkspaceCatalogAvailableItemsFactory.prototype.forInsight = function (insight) {
        return this.withOptions({ insight: insight });
    };
    BearWorkspaceCatalogAvailableItemsFactory.prototype.load = function () {
        return __awaiter(this, void 0, void 0, function () {
            var tempVisualizationObj, _a, availableCatalogItems, availableDateDatasets, allAvailableCatalogItems;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        tempVisualizationObj = createVisObjectForAvailability(this.options, this.mappings);
                        return [4 /*yield*/, Promise.all([
                                this.loadAvailableCatalogItems(tempVisualizationObj),
                                this.loadAvailableDateDatasets(tempVisualizationObj),
                            ])];
                    case 1:
                        _a = _b.sent(), availableCatalogItems = _a[0], availableDateDatasets = _a[1];
                        allAvailableCatalogItems = __spreadArrays(availableCatalogItems, availableDateDatasets);
                        return [2 /*return*/, new BearWorkspaceCatalogWithAvailableItems(this.groups, this.items, allAvailableCatalogItems)];
                }
            });
        });
    };
    return BearWorkspaceCatalogAvailableItemsFactory;
}());
export { BearWorkspaceCatalogAvailableItemsFactory };
/**
 * Creates temporary visualization object, whose bucket items can then be used to construct the bucket items
 * used by the catalog resource. The construction of bucket items happens using some serious mojo in bear's api
 * client and requires these types of objects.
 *
 * This function will take all the items, strip arithmetic measures and measures derived from them,
 * transform all identifiers to URIs.
 */
function createVisObjectForAvailability(options, mappings) {
    var _a = options.items, items = _a === void 0 ? [] : _a, insight = options.insight;
    if (items.length === 0 && !insight) {
        throw new Error("No items or insight was specified.");
    }
    var itemsToUse = insight ? insightItems(insight) : items;
    var validItems = filterItemsForAvailabilityQuery(itemsToUse);
    var itemsWithUris = validItems.map(function (item) { return translateIdentifiersToUris(item, mappings); });
    var tempInsight = {
        insight: {
            title: "",
            filters: [],
            properties: {},
            sorts: [],
            visualizationUrl: "",
            buckets: [
                {
                    items: itemsWithUris,
                },
            ],
        },
    };
    return convertInsightDefinition(tempInsight);
}
/*
 * Availability query must not contain arithmetic measures and measures derived from them.
 */
function filterItemsForAvailabilityQuery(items) {
    var arithmeticMeasuresIds = new Set();
    var otherMeasureIds = new Set();
    items.forEach(function (measure) {
        if (isArithmeticMeasure(measure)) {
            arithmeticMeasuresIds.add(measureLocalId(measure));
        }
        else if (isMeasure(measure)) {
            otherMeasureIds.add(measureLocalId(measure));
        }
    });
    return items.filter(function (item) {
        if (isAttribute(item) || isSimpleMeasure(item)) {
            return true;
        }
        else if (isArithmeticMeasure(item)) {
            return false;
        }
        else if (isPoPMeasure(item) || isPreviousPeriodMeasure(item)) {
            var masterMeasure = measureMasterIdentifier(item);
            // remove derived measures which are either derived from arithmetic measure or which do
            // not have their master among the items to query
            return !arithmeticMeasuresIds.has(masterMeasure) && otherMeasureIds.has(masterMeasure);
        }
        throw new InvariantError("unexpected type of item encountered while constructing items for availability query");
    });
}
function translateIdentifiersToUris(item, mappings) {
    var _a, _b;
    if (isAttribute(item)) {
        var ref = attributeDisplayFormRef(item);
        if (isIdentifierRef(ref)) {
            var displayForm_1 = mappings.displayFormById[ref.identifier];
            return modifyAttribute(item, function (m) {
                return m.displayForm(uriRef(displayForm_1.meta.uri)).localId(attributeLocalId(item));
            });
        }
        return item;
    }
    else if (isSimpleMeasure(item)) {
        var ref = measureItem(item);
        if (isIdentifierRef(ref)) {
            var metric = mappings.measureById[ref.identifier];
            var fact = mappings.factById[ref.identifier];
            var uri_1 = (_a = metric === null || metric === void 0 ? void 0 : metric.uri) !== null && _a !== void 0 ? _a : fact.uri;
            return modifySimpleMeasure(item, function (m) { return m.measureItem(uriRef(uri_1)).localId(measureLocalId(item)); });
        }
        return item;
    }
    else if (isPoPMeasure(item)) {
        var ref = measurePopAttribute(item);
        if (isIdentifierRef(ref)) {
            var attribute = mappings.attributeById[ref.identifier];
            var dateAttribute = mappings.dateAttributeById[ref.identifier];
            var uri_2 = (_b = attribute === null || attribute === void 0 ? void 0 : attribute.attribute.meta.uri) !== null && _b !== void 0 ? _b : dateAttribute.attribute.uri;
            return modifyPopMeasure(item, function (m) { return m.popAttribute(uriRef(uri_2)).localId(measureLocalId(item)); });
        }
    }
    return item;
}
//# sourceMappingURL=availableItemsFactory.js.map