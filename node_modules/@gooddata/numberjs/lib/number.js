(function(window, factory) {
    if (typeof YUI !== 'undefined') {
        YUI.add('gdc-numberjs', function(Y) {
            Y.GDC.util = Y.GDC.util || {};
            Y.GDC.util.number = factory();
        },  '0.0.1', {requires: [ 'GDC' ]});
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
    } else if (typeof exports === 'object') {
       // CommonJS
        module.exports = factory();
    } else {
        window.numberjs = factory();
    }
}(this, function moduleFactory() {

/*
 * Copyright (C) 2006 Baron Schwartz <baron at sequent dot org>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 * Changes by GoodData are not covered by the above license (see LICENSE)
 * Copyright (C) 2007-2018, GoodData(R) Corporation. All rights reserved.
 */

// Abbreviations: LODP = Left Of Decimal Point, RODP = Right Of Decimal Point

// Hash {format => function}
var formattingFunctions = {};
var resolvingFunctions = {};

// Constants useful for controlling the format of numbers in special cases.
var NaNstring = 'NaN';
var posInfinity = 'Infinity';
var negInfinity = '-Infinity';
var toFixedMax = 1e21;
var toFixedMin = -1e21;
var nullRE = /null/i;
var nullConditionRE = /\[=null\]/i;
var conditionRE = /\[(>=|<=|=|>|<)(-?[0-9\.]+|null)\]/i;
var arithmeticTestRE = /\{\{\{([0-9]*\.?[0-9]*)\|([0-9]*)(\.)?\|(.*?)\}\}\}/;
var arithmeticRE = new RegExp(arithmeticTestRE.source, 'g');
var equalSign = '=';
var colorRE = /\[(black|blue|cyan|green|magenta|red|white|yellow|none)\]/i;
var colorsRE = /\[(black|blue|cyan|green|magenta|red|white|yellow|none)\]/gi;
var customColorRE = /\[color=([A-Fa-f0-9]+)\]/i;
var customBackgroundColorRE = /\[backgroundColor=([A-Fa-f0-9]+)\]/i;
var customColorsRE = /(\[(?:backgroundColor|color)=[A-Fa-f0-9]+\])+/gi;
var colorLookup = {
    'black': '#000000',
    'red': '#FF0000',
    'green': '#00AA00',
    'blue': '#0000FF',
    'white': '#FFFFFF',
    'cyan': '#0092D2',
    'magenta': '#CB006B',
    'yellow': '#FFF10D',
    'none': 'none'
};

var DEFAULT_FORMAT = '#,##0.00';
var DEFAULT_THOUSAND_SEPARATOR = ',';
var DEFAULT_DECIMAL_SEPARATOR  = '.';

// we cannot use ";" as a end delimiter, because ";" is use for spliting the whole format string.
var ESCAPING_REGEXP = new RegExp("&(.*?)&","g");


function log() {
    typeof window !== 'undefined' &&
    window.console &&
    window.console.log.apply(this, arguments);
}

// Worker objects responsible for generating appropriate formatting or resolving function
function Worker() {
}

/**
 * Returns newly created function
 *
 * @method createFunction
 * @public
 */
Worker.prototype.createFunction = function() {
    var formatCode;

    try {
        formatCode = this.getFormatCode();
    } catch (ex) {
        log('Exception during processing formatting string', ex);
        this.format = DEFAULT_FORMAT;
        formatCode = this.getFormatCode();
    }

    return eval("(function() { return function(number){" + formatCode + "}; })()");
};

/**
* Returns a javascript code (as a string to be evaluated) that formats numbers.
* Childs inheriting from Worker need to supply their own implementation of createTerminalFormat().
*
* @method getFormatCode
* @public
*/
Worker.prototype.getFormatCode = function() {
    if (containsArithmeticExpressionFormat(this.format)) {
        return this.arithmeticFormatterCode(this.format);
    }

    var code = '';
    var equalConditionsCode = '';               // pull out equal conditions in front of the rest
    var otherConditionsCode = '';               // overlapping conditions (>= 1000 and <= 2000 etc. are handled left to right)
    var rulesWithoutConditionCount = 0;         // up to 3 blocks can have no conditions defined, they will be treated as [>0], [<0] and [=0]
    var defaultRuleFormat = DEFAULT_FORMAT;  // use this if there are multiple components but none or only one is default (without a custom condition)
    var formats = this.format.split(";");            // identify format components

    if (formats.length < 2 && this.format.match(conditionRE) === null) {
        code += this.createTerminalFormat();
    } else {
        formats.forEach(function(fmt) {
            var result = fmt.match(conditionRE);
            if (result !== null) { // custom condition block
                if (result[1]==equalSign) {
                    equalConditionsCode += this.createConditionCode(result[1], result[2], fmt.replace(result[0],''));
                }
                else {
                    otherConditionsCode += this.createConditionCode(result[1], result[2], fmt.replace(result[0],''));
                }
            }
            else { // this block has no custom condition
                switch (rulesWithoutConditionCount) {
                    case 0: // positive condition
                        defaultRuleFormat = fmt; // see defaultRuleFormat
                        otherConditionsCode += this.createConditionCode('>=', 0, fmt);
                        break;
                    case 1: // negative condition
                        otherConditionsCode += this.createConditionCode('<', 0, fmt);
                        break;
                    case 2: // zero condition
                        equalConditionsCode += this.createConditionCode('=', 0, fmt);
                        break;
                    default:
                        throw 'Too many semicolons in format string';
                }
                rulesWithoutConditionCount++;
            }
        }, this);
        if (rulesWithoutConditionCount==1) { // we just have the default component, let's use it as a generic component instead of positive
            otherConditionsCode += this.createConditionCode('<', 0, defaultRuleFormat);
        } else if (rulesWithoutConditionCount === 0) {  // no default component is present, use the default ##0.00 format for "all else"
            otherConditionsCode += this.createConditionCode('all', 0, defaultRuleFormat);
        }
        code += equalConditionsCode + otherConditionsCode;
    }

    return code;
};

/*
* Create a code fragmet that serves as terminal formatting function
* Child of Worker needs to override this functionality.
* Throws AbstractMethodCallError exception if called.
*
* @method createTerminalFormat
* @public
* @abstract
*/
Worker.prototype.createTerminalFormat = function(){
    throw {
        name: 'AbstractMethodCallError',
        message: 'Can not call abstract method'
    };
};

/*
* Create a code fragmet for a single condition
* Childs inheriting this function need to supply their implementation of createConditionReturnCode
*
* @method createConditionCode
* @public
* @param {String} condition (>, = etc.)
* @param {Float|Integer} conditionNumber number used in the condition
* @param {String} format string
*/
Worker.prototype.createConditionCode = function(condition, conditionNumber, format) {
    var conditionStr = '';
    var returnCode = this.createConditionReturnCode(format);
    if (condition == 'all') {
        return "\n" + returnCode;
    } else {
        switch(condition) {
            case '=':
                conditionStr = '==';
                if (nullRE.test(conditionNumber)) {
                    if(this.separators && this.separators.thousand) {
                        format = translateFormat(
                                    format,
                                    { thousand: DEFAULT_THOUSAND_SEPARATOR, decimal: DEFAULT_DECIMAL_SEPARATOR },
                                    { thousand: this.separators.thousand, decimal: this.separators.decimal }
                                 );

                    }

                    return "\n" +
                        'if (number === "") return "' + format + '";';
                }

                // Zero is provided both as a string and as a number. And we have
                // to do strong checking, because empty string (which should be process
                // as a "null") is equal (==) to zero too. see GD-31687
                if(conditionNumber === 0 || conditionNumber === '0' ) {
                    return "\n" +
                        'if (number === "0" || number === 0) {'+
                            returnCode +
                        '}';
                }

                break;
            case '>':
            case '<':
            case '>=':
            case '<=':
                conditionStr = condition;
                break;
            default:
                throw 'Error\\! Unrecognized condition format\\!';
        }

        return "\n"+
            'if (number '+conditionStr+' '+parseFloat(conditionNumber,10)+') {'+
                returnCode +
            '}';
    }
};

/*
* Create a code fragment that serves as condition function return code
* Child of Worker needs to override this functionality. Throws AbstractMethodCallError
* exception if called.
*
* @method createConditionReturnCode
* @public
* @abstact
* @param {String} format format string
*/
Worker.prototype.createConditionReturnCode = function(format) {
    throw {
           name: 'AbstractMethodCallError',
           message: 'Can not call abstract method'
    };
};

// Object responsible for generating number resolving functions
function Resolver(number, format) {
    this.number = number;
    this.format = format;
}

Resolver.prototype = new Worker();

Resolver.prototype.arithmeticFormatterCode = function() {
    return "return undefined;";
}

/*
 * Create a code fragment that serves as terminal formatting function.
 * Resolver implementation.
 *
 * @method createTerminalFormat
 * @public
 */
Resolver.prototype.createTerminalFormat = function() {
    if (this.number === "") {
          return "return '';";
    }

    return "return '" + escape(this.format) + "';\n";
};

/*
 * Create a code fragment that serves as condition function return code.
 * Resolver implementation.
 *
 * @method createConditionReturnCode
 * @public
 * @param {String} format format string
 */
Resolver.prototype.createConditionReturnCode = function(format) {
    // The returned function returns conditional format.
    // Excel handles conditional formatting different way than normal
    // formatting.
    var excelFormat = escape(format);
    return "return '" + excelFormat + ';' + excelFormat + "';";
};

//Object responsible for generating number formatting functions
function Formatter(number, format, separators) {
    this.number = number;
    this.format = format;
    this.separators = separators;
    this.formattingFunction = undefined;
}

Formatter.prototype = new Worker();

/**
 * Creates a new string with optimized Javascript code specific for a format function
 * and evaluates it, thereby creating a new function. Object is then cached.
 *
 * @method createAndCache
 * @public
 */
Formatter.prototype.createFunction = function() {
    var formatCode;

    try {
        formatCode = this.getFormatCode();
    } catch (ex) {
        log('Exception during processing formatting string', ex);
        this.format = DEFAULT_FORMAT;
        formatCode = this.getFormatCode();
    }

    return eval("(function() { return function(number, context){" + formatCode + "}; })()");
};

/*
 * Generates and returns the code that splits arithmetic format expression into
 * independent formatting tasks, processes each of them and merges the result.
 *
 * @method arithmeticFormatterCode
 * @public
 */
Formatter.prototype.arithmeticFormatterCode = function() {
    var code = '';
    var subformat;
    var subformatCodeBlocks = [];

    while ((subformat = arithmeticRE.exec(this.format)) != null) {
        subformatCodeBlocks.push("return numberFormat((number" + (subformat[1] ? "/" + subformat[1] : "") +
            (subformat[2] ? "%" + subformat[2] : "") + ")" +
            (subformat[3] ? "" : ">>0") + // trim decimals if no "." at the end of modulo argument (using >>0 instead of Math.floor() for better efficiency)
            ",'" + subformat[4] + "', 1,"+ stringifySeparators(this.separators) +");");
    }

    if (subformatCodeBlocks.length > 0) {
        var index = 0;
        code = "var newFormat = numberFormat(number, '" + this.format.replace(arithmeticRE, function () {
            return "{{{" + indexToString(index++) + "}}}";
        }) + "', 1," + stringifySeparators(this.separators) +");\n";
        code += "var subformatFunctions = [\n";
        subformatCodeBlocks.forEach(function (fmt) {
            code += "    function() {" + fmt + "},\n";
        });
        code += "];\n";
        code += "return newFormat.replace(/\{\{\{([a-z]+)\}\}\}/g, function (match, index) {return subformatFunctions[indexFromString(index)]();});\n";
    }

    return code;
};

/*
 * Create a code fragment that serves as condition function return code
 * Formatter implementation.
 *
 * @method createConditionCode
 * @public
 * @param {String} format format string
 */
Formatter.prototype.createConditionReturnCode = function(format) {
    return "return numberFormat(number,'" + format + "', 1,"+ stringifySeparators(this.separators) +");";
};

/**
 * Create a code fragment for a final format (no multiple rules, no conditions)
 *
 * @method createTerminalFormat
 * @public
 */
Formatter.prototype.createTerminalFormat = function() {
    var re = customColorsRE, visualFormatting = '', matchResult = null;
    var format = this.format;

    if ((matchResult = format.match(re)) !== null) {
        visualFormatting += matchResult[0];
        format = format.replace(visualFormatting,'');
    }

    if (this.number === "") {
          return "return '';";
    }

    // If there is no work to do, just return the literal value
    if (format.length > 0 && format.search(/[0#?]/) == -1) {
        return "return '" + visualFormatting + format + "';\n";
    }

    // Negative values are always displayed without a minus sign when section separators are used.
    var code = "var val = (context == null) ? Number(number) : Math.abs(number);\n";
    var thousands = false;
    var lodp = format;
    var rodp = "";
    var ldigits = 0;
    var rdigits = 0;
    var scidigits = 0;
    var scishowsign = false;
    var sciletter = "";
    // Look for (and remove) scientific notation instructions, which can be anywhere
    var m = format.match(/\..*(e)([+\-]?)(0+)/i);
    if (m) {
        sciletter = m[1];
        scishowsign = (m[2] == "+");
        scidigits = m[3].length;
        format = format.replace(/(e)([+\-]?)(0+)/i, "");
    }
    // Split around the decimal point
    m = format.match(/^([^.]*)\.(.*)$/);
    if (m) {
        lodp = m[1].replace(/\./g, "");
        rodp = m[2].replace(/\./g, "");
    }
    // Look for %
    if (format.indexOf('%') >= 0) {
        code += "val *= 100;\n";
    }
    // Look for comma-scaling to the left of the decimal point
    m = lodp.match(/(,+)(?:$|[^0#?])/);
    if (m) {
        code += "val /= " + Math.pow(1000, m[1].length) + "\n;";
    }
    // Look for comma-separators
    if (lodp.search(/[0#?],[0#?]/) >= 0) {
        thousands = true;
    }
    // Nuke any extraneous commas
    if ((m) || thousands) {
        lodp = lodp.replace(/,/g, "");
    }
    // Look for comma-scaling to the right of the decimal point
    m = rodp.match(/[0#?](,+)(?:$|[^0#?])/);
    if (m) {
        code += "val /= " + Math.pow(1000, m[1].length) + "\n;";
    }
    // Look for comma-separators
    if (rodp.search(/[0#?],[0#?]/) >= 0) {
        thousands = true;
    }
    // Nuke any extraneous commas
    if ((m) || thousands) {
        rodp = rodp.replace(/,/g, "");
    }
    // Figure out how many digits to the l/r of the decimal place
    m = lodp.match(/0[0#?]*/);
    if (m) {
        ldigits = m[0].length;
    }
    m = rodp.match(/[0#?]*/);
    if (m) {
        rdigits = m[0].length;
    }
    // Scientific notation takes precedence over rounding etc
    if (scidigits > 0) {
        code += "var sci = toScientific(val," + ldigits + ", " + rdigits + ", " +
        scidigits + ", " + scishowsign + ");\n" + "var arr = [sci.l, sci.r];\n";
    }
    else {
        // If there is no decimal point, round to nearest integer
        // rounding half AWAY from zero, as in Excel (as opposed to Math.round())
        // Hint: if context is present, we're always working with absolute values, so no adjustments are necessary
        if (format.indexOf('.') < 0) {
            code += "var sign = (number < 0 && context == null) ? -1 : 1;\n";
            code += "val = Math.round(val*sign)*sign;\n";
        }
        // Numbers are rounded to the correct number of digits to the right of the decimal
        code += "var arr = round(val, Math.min(20," + rdigits + ")).toFixed(Math.min(20," + rdigits + ")).split('.');\n";
        // There are at least "ldigits" digits to the left of the decimal, so add zeros if needed.
        code += "arr[0] = (val < 0 ? '-' : '') + leftPad((val < 0 ? arr[0].substring(1) : arr[0]), " + ldigits + ", '0');\n";
    }
    if (ldigits == 0) {
        code += "arr[0] = (Math.abs(arr[0]) < 1) ? (val < 0 ? '-' : '') : arr[0];\n";
    }
    // Add thousands separators
    if (thousands && this.separators.thousand !== "") {
        code += "arr[0] = addSeparators(arr[0], \"" + this.separators.thousand + "\");\n";
    }
    // Insert the digits into the formatting string.  On the LHS, extra digits are copied
    // into the result.  On the RHS, rounding has chopped them off.
    code += "arr[0] = reverse(injectIntoFormat(reverse(arr[0]), '" + reverse(lodp) + "', true));\n";
    if (rdigits > 0) {
        code += "arr[1] = injectIntoFormat(arr[1], '" + rodp + "', false);\n";
        // there could be chars after formatting string, e.g. "## USD"
        var hashCount, endHashes = rodp.match(/^[0#?]*?(#+)[^0#?]*$/);
        if (endHashes) {
            hashCount = endHashes[1].length;
            // see "if" description - here we only remove zeroes
            code += "arr[1] = arr[1].replace(/^([0-9]*?)0{1," + hashCount + "}([^0-9]|$)/, '$1$2');\n";
        }
    }
    if (scidigits > 0) {
        code += "arr[1] = arr[1].replace(/(\\d{" + rdigits + "})/, '$1" + sciletter + "' + sci.s);\n";
    }

    // we need to avoid join with decimal separator when in arr[1] is not number, arr[1] could be after replace only e.g. " USD"
    code += "var ret = '" + visualFormatting
        + "' + (arr[1] ? (/\\d+.*/.test(arr[1]) ? arr.join('" + this.separators.decimal + "') :  arr.join('')) : arr[0]);\n";
    code += "ret = ret.replace(/(\\\\)(.{1})/g, '$2');\n";
    return code + "return ret;\n";
};


// Entry points

/**
* Default entry-point into GDC.util.number, returns a formatted numeric string.
* Note: does not do anything with color formatting, see colors2(Object|Html)
*
* @method numberFormat
* @static
* @param {Float|Integer|String} number to be formatted (empty string is null value)
* @param {String} format string
* @param {Bool} internal value, default is false
* @param {Object} separators object containing user defined thousand and decimal separators
* @returns {String} formatted number
*/
function numberFormat(number, format, context, separators) {
    if (isNaN(number)) {
        return NaNstring;
    } else if (number === +Infinity ) {
        return posInfinity;
    } else if (number === -Infinity) {
        return negInfinity;
    } else if (format === undefined) {
        return number.toString();
    }

    if (separators === undefined) {
        separators = { thousand: DEFAULT_THOUSAND_SEPARATOR, decimal: DEFAULT_DECIMAL_SEPARATOR };
    }

    if (number <= toFixedMin || number >= toFixedMax) {
        /*
         * Number.prototype.toFixed method which is by default used
         * for conversion numbers with exponent to string
         * by this lib supports max (+/-)e20 (ECMA limitation).
         * It's possible to overwrite toFixed with own method, inspiration
         * could be found e.g. here:
         * https://github.com/kriskowal/es5-shim/blob/master/es5-shim.js
         * It's not our case to format such massive numbers.
         * For big (negative) numbers we ignore advanced formatting, we only
         * replace decimal separator.
         */
        return number.toString().replace(".", separators.decimal, "g");
    }

    // escape quotes and backslashes in format string to prevent creation of invalid js code
    format = escape(format);
    // "remove" special chars which are escaped
    format = specialCharsEscape(format);


    var key = format + stringifySeparators(separators);
    if (number === "") {
        key = "NULL" + key;
    }

    var f = formattingFunctions[key];
    if (f === undefined) {
         var formatter = new Formatter(number, format, separators);
         f = formattingFunctions[key] = formatter.createFunction();
    }

    return specialCharsUnescape(f(number, context));
}

/**
* Resolves formatting string by removing excel-incompatible the conditional formats.
* Returns only the part of formatting string applicable for the current number.
* If the original format is conditional then the resulting format is also conditional.
*
* @method resolveFormat
* @static
* @param {Float|Integer} number to used for determining the format
* @param {String} format string
* @param {Boolean} internal value, default is false
*/
function resolveFormat(number, format) {
    if (isNaN(number)) {
        return '';
    }

    // escape quotes and backslashes in format string to prevent creation of invalid js code
    format = escape(format);
    format = specialCharsEscape(format);

    var key = format;
    if (number === "") {
        key = "NULL" + key;
    }

    var f = resolvingFunctions[key];

    if (f === undefined) {
        var resolver = new Resolver(number, format);
        f = resolvingFunctions[key] = resolver.createFunction();
    }

    return f(number);
}

/**
 * @method containsNullConditionalFormat
 * @static
 * @param {String} format to scan for null format condition
 * @returns {Boolean} true if given format contains NULL condition string, false otherwise
 */
function containsNullConditionalFormat(format) {
    return nullConditionRE.test(format);
}

/**
 * @method containsArithmeticExpressionFormat
 * @static
 * @param {String} format to scan for arithmetic blocks
 * @returns {Boolean} true if given format contains arithmetic blocks, false otherwise
 */
function containsArithmeticExpressionFormat(format) {
    return arithmeticTestRE.test(format);
}

// Helper functions
function stringifySeparators(separators) {
    return '{thousand:"' + separators.thousand +'",decimal:"'+separators.decimal+'"}';
}

function toScientific(val, ldigits, rdigits, scidigits, showsign) {
    var result = {l:"", r:"", s:""};
    var ex = "";
    // significantFigures is an ugly hack to limit toFixed() parameter to 20, which is ECMAScript maximum supported range
    var significantFigures = Math.min(ldigits + rdigits + 1, 20);
    // Make ldigits + rdigits significant figures
    var before = trim(Math.abs(val).toFixed(significantFigures),'0');
    // Move the decimal point to the right of all digits we want to keep,
    // and round the resulting value off
    var after = Math.round(Number(before.replace(".", "").replace(
        new RegExp("(\\d{" + (significantFigures-1) + "})(.*)"), "$1.$2"))).toFixed(0);
    // Place the decimal point in the new string
    if (after.length >= ldigits) {
        after = after.substring(0, ldigits) + "." + after.substring(ldigits);
    }
    else {
        after += '.';
    }
    // Find how much the decimal point moved.  This is #places to LODP in the original
    // number, minus the #places in the new number.  There are no left-padded zeroes in
    // the new number, so the calculation for it is simpler than for the old number.
    result.s = (before.indexOf(".") - before.search(/[1-9]/)) - after.indexOf(".");
    // The exponent is off by 1 when it gets moved to the left.
    if (result.s < 0) {
        result.s++;
    }
    // Split the value around the decimal point and pad the parts appropriately.
    result.l = (val < 0 ? '-' : '') + leftPad(after.substring(0, after.indexOf(".")), ldigits, "0");
    result.r = after.substring(after.indexOf(".") + 1);
    if (result.s < 0) {
        ex = "-";
    }
    else if (showsign) {
        ex = "+";
    }
    result.s = ex + leftPad(Math.abs(result.s).toFixed(0), scidigits, "0");

    return result;
}

function round(number, decimals) {
    if (decimals > 0) {
        // decimalPrecision variable is an ugly hack to limit toFixed() parameter to 20, which is ECMAScript maximum supported range
        // numbers like 0.54999999999999999, with 0.0 format, will still be rounded to 0.6, since there is simply not enough precision
        var decimalPrecision = Math.min(decimals + 10,20);
        var regexp = new RegExp("(-?\\d*)\\.(\\d{" + decimals + "})(\\d)\\d*$");
        var m = number.toFixed(decimalPrecision).match(regexp);

        if (m && m.length) {
            var carryover = (m[1].charAt(0) == '-') ? -1 : 1; // negative number carryovers need to be negative, too
            var s = leftPad(Math.round(m[2] + "." + m[3]), decimals, "0");
            return (s.length > decimals) ? Number(m[1]) + carryover : Number(m[1] + "." + s);
        }
    }
    return number;
}

function specialCharsEscape(format)
{

    // Escaping an amp char, which is internally use for substutions
    format = format.replace(/&/g,"&38&");

    // escape escaping strings
    format = format.replace(/(\\){4}/g,"&92&");

    return format.replace(/\\\\./g,function(match) {
        // A zero is also special char, so we replace it with non-special char "o"
        return ("&"+(match.charCodeAt(match.length-1))+"&").replace(/0/g,"O");
    });
}

function specialCharsUnescape(format)
{
    return format.replace(ESCAPING_REGEXP,function(match) {
        return String.fromCharCode(match.replace(/O/g,"0").replace(/&/g,""));
    });
}

function injectIntoFormat(val, format, stuffExtras) {
    format = escape(format);
    var i = 0;
    var j = 0;
    var result = "";
    var revneg = val.charAt(val.length - 1) == '-';

    if ( revneg ) {
       val = val.substring(0, val.length - 1);
    }

    while (i < format.length && j < val.length && format.substring(i).search(/[0#?]/) >= 0) {
        if (format.charAt(i).match(/[0#?]/)) {
            // It's a formatting character; copy the corresponding character
            // in the value to the result
            if (val.charAt(j) != '-') {
                result += val.charAt(j);
            }
            else {
                result += "0";
            }
            j++;
        }
        else {
            result += format.charAt(i);
        }
        ++i;
    }

    if ( revneg && j == val.length ) {
        result += '-';
    }

    if (j < val.length) {
        if (stuffExtras) {
            result += val.substring(j);
        }
        if ( revneg ) {
             result += '-';
        }
    }

    if (i < format.length) {
        result += format.substring(i);
    }

    return result.replace(/#/g, "").replace(/\?/g, " ");
}

// Got from YUI 3
function escape_regex(string) {
       return string.replace(/[\-#$\^*()+\[\]{}|\\,.?\s]/g, '\\$&');
}

function addSeparators(val, separator) {
    var patternString = "^(-)?" + escape_regex(separator);
    var extraSeparatorPattern = new RegExp(patternString);

    return reverse(reverse(val).replace(/(\d{3})/g, "$1" + separator)).replace(extraSeparatorPattern, "$1");
}

function reverse(string) {
    var res = "";

    // Need to unescape characters because of the reverse would make /" out of \"
    string = string.replace(/(\\)(.{1})/g, '$2');

    for (var i = string.length; i > 0; --i) {
        res += string.charAt(i - 1);
    }

    // Escape characters back
    res = escape(res);

    return res;
}

function trim(string, ch) {
    if (!ch) ch = ' ';

    return string.replace(new RegExp("^" + ch + "+|" + ch + "+$", "g"), "");
}

function leftPad(val, size, ch) {
    var result = String(val);

    while (result.length < size) {
        result = ch + result;
    }

    return result;
}

function escape(string) {
    var str = string.replace(/(['"\\])/g, "\\$1").replace(/[\r\n]/g, '');
    return str;
}


/*
* Take a string with a formatted number, search for a color code (for example [Red])
* and if found, wrap the string in <span style="color..."></span>
*
* @method colors2Html
* @static
* @param {String} formatted numeric string optionally containing a color code
* @deprecated Does not support background color replacement
*/
function colors2Html(str) {
    var result = str.match(colorRE);

    if (result) {
        var color = result[1].toLowerCase();
        return '<span style="color: '+colorLookup[color]+'">'+str.replace(colorRE,'')+'</span>';
    } else {
        return str;
    }
}

/*
* Make GoodData metric format into an excel one
* Basically, our special characters are subset of excel ones,
* so we pass ones that we treat specially as it is and quote
* everything else.
*
* @method excelEscape
* @param {String} string containing color formatting information
*/
function excelEscape(format) {
    if (format === undefined)
        return format;
    format = makeScalingExcelCompatible(format);
    // Escape slashes and quotes
    format = format.replace(/(["\\\\])/g, '\\$1');
    // Quote everything that's not special
    format = format.replace(/([^\.,;0#% \\"]+)/g, '"$1"');
    // Unescaping of escaped special chars
    format = specialCharsUnescape(format);

    return format;
}

// look for commas before first decimal point (not followed by a digit placeholder)
var SCALING_PATTERN = /^([^\.]*?)(,+)((?:[^0#?].*)?\..*)/;
function makeScalingExcelCompatible(format) {
    var formatComponents = format.split(';');
    var compatibleFormatComponents = formatComponents.map(function(component) {
        var m = component.match(SCALING_PATTERN);
        if (m) {
            var scalingCommas = m[2];
            component = component.replace(SCALING_PATTERN, '$1$3');
            // insert scaling commas just after last digit placeholder
            component = component.replace(/^(.*[0#?])(.*)$/, '$1' + scalingCommas + '$2');
        }
        return component;
    });
    return compatibleFormatComponents.join(';');
}

/*
* Remove color formatting information from a string
*
* @method stripColors
* @param {String} string containing color formatting information
*/
function stripColors(format) {
    return format.replace(customColorsRE, '').replace(colorsRE, '');
}

/*
* Take a string with a formatted number, search for a color code (for example [Red])
* and return a structure { label: ..., color: ..., backgroundColor: ... }
*
* @method colors2Object
* @static
* @param {String} formatted numeric string optionally containing a color code
*/
function colors2Object(str) {
    var result,result2,result3 = null;
    var returnObj = { label: str };

    if ((result = str.match(colorRE)) !== null) {
        var color = result[1].toLowerCase();
        returnObj.color = colorLookup[color];
        returnObj.label = returnObj.label.replace(colorRE,'');
    }

    if ((result2 = str.match(customColorRE)) !== null) {
        returnObj.color = '#'+result2[1];
        returnObj.label = returnObj.label.replace(customColorRE,'');
    }

    if ((result3 = str.match(customBackgroundColorRE)) !== null) {
        returnObj.backgroundColor = '#'+result3[1];
        returnObj.label = returnObj.label.replace(customBackgroundColorRE,'');
    }

    return returnObj;
}

/**
 * Converts a string representing an index into the actual number it represents.
 *
 * @param index
 * @returns {number}
 */
var indexFromString = function(index) {
    var result = 0;
    for (var i = 0; i < index.length; i++) {
        result *= 25;
        result += index.charCodeAt(i) - 97;
    }
    return result;
};

/**
 * Converts a numberic index into a string that does not clash with control characters (such as "0") in the format string.
 *
 * @param index
 * @returns {String}
 */
var indexToString = function(index) {
    var result = "";
    var temp = index;
    do {
        result = String.fromCharCode(97 + (temp % 25)) + result;
        temp = (temp / 25) >> 0;
    } while (temp > 0);
    return result;
};

/**
 * Takes string fragment with thousand part and replaces used separator with new separator
 * @param fragment metric format string - only thousand part
 * @param thousandOld old thousand separator character
 * @param thousandNew new thousand separator character
 * @param isDecimalPart indicates if we detected decimal part in metric format
 * @returns {String}
 * @private
 */
var _translateThousandPart = function(fragment, thousandOld, thousandNew, isDecimalPart) {
    // Look for thousand separators
    // Try to split "fragment" - part without decimal section to "left", "expression" and "right"
    // "expression" is the right-most group of "formatTokens"
    var left = '',
        expression = '',
        right = '',
        interrupted,
        formatTokens = ['#', '0', '+', 'e', 'E', thousandOld];

    fragment = fragment.replace(/^\s+(.*)$/, '$1'); // trim leading whitespaces

    for (var i=0, j=fragment.length; i<j; i++) {
        if (formatTokens.indexOf(fragment[i]) > -1) {
            if (!interrupted) {
                expression += fragment[i];
            } else {
                expression += right + fragment[i]; // save part which was looking like expression
                right = '';
                interrupted = false;
            }
        } else {
            if (!expression) {
                left = left + fragment[i];
            } else {
                right = right + fragment[i];
            }
            interrupted = true;
        }
    }

    // Special treatment when space (' ') is thousand separator:
    // * when is part in the beginning we take it as normal "space",
    // * when there is last char "space" and the char before is not space we have to add it to right or to decimal part (if exists)
    if (thousandOld === ' ') {
        if (expression[0] === ' ') {
            left = left + ' ';
            expression = expression.substring(1);
        }
        if (isDecimalPart || right !== '') {
            var l = expression.length;
            if (l > 1 && expression[l-2] !== ' ' && expression[l-1] === ' ') {
                expression = expression.substring(0, l-1);
                right = ' ' + right;
            }
        }
    }

    var pattern = new RegExp("\\" + thousandOld, "g");
    return left + expression.replace(pattern, thousandNew) + right;
};


/**
* Checks whether two separators objects contain same values
* @method sameSeparators
* @private
* @param {Object} firstSeparators separator object
* @param {Object} secondSeparators separator object
*/
var sameSeparators = function(firstSeparators, secondSeparators) {
    return firstSeparators.thousand === secondSeparators.thousand && firstSeparators.decimal === secondSeparators.decimal;
};

/**
* Translates given format to the format with custom separators
* @method translate2custom
* @private
* @param {String} formatString format string
* @param {Object} originalSeparators containing separators that currently exist in the format string
* @param {Object} newSeparators containing separators that will replace current separators in the format string
*/
var translateFormat = function(formatString, originalSeparators, newSeparators) {
    if (formatString === undefined) {
        return undefined;
    }

    if (sameSeparators(originalSeparators, newSeparators)) {
        return formatString;
    }

    var formatArray = formatString.split(";");

    var newFormats = formatArray.map(function(format) {
        var lodp = format,
            rodp = "";

        // "^([^,]*)\,(.*)$" for ","
        var pattern = new RegExp("^([^"+originalSeparators.decimal+"]*)\\" + originalSeparators.decimal + "(.*)$");
        // Split around the decimal point
        var decimalPart = format.match(pattern);
        if (decimalPart) {
            lodp = decimalPart[1];
            rodp = decimalPart[2];
        }

        lodp = _translateThousandPart(lodp, originalSeparators.thousand, newSeparators.thousand, !!decimalPart);

        if (decimalPart) {
            return lodp + newSeparators.decimal + rodp;
        }

        return lodp;
    });

    return newFormats.join(";");
};

/**
 * Abstract class specifying frame for group definitions instances
 * @namespace GDC.ui
 * @class FormatTranslator
 * @singleton
 */
var FormatTranslator = {
    /**
    * Translates given format to the format with custom separators
    * @method translate2custom
    * @public
    * @param {String} formatString format string
    * @param {Object} separators containing separators that will replace the defaults in the string
    */
    translate2custom: function(formatString, separators) {
        return translateFormat(formatString, {thousand: DEFAULT_THOUSAND_SEPARATOR, decimal: DEFAULT_DECIMAL_SEPARATOR}, separators);

    },
    /**
    * Translates given format to the format with custom separators
    * @method translate2custom
    * @public
    * @param {String} formatString format string
    * @param {Object} separators containing separators that will be replaced by the defaults
    */
    translate2default: function(formatString, separators) {
        return translateFormat(formatString, separators, {thousand: DEFAULT_THOUSAND_SEPARATOR, decimal: DEFAULT_DECIMAL_SEPARATOR});
    }
};


return {
    numberFormat: numberFormat,
    resolveFormat: resolveFormat,
    colors2Object: colors2Object,
    colors2Html: colors2Html,
    excelEscape: excelEscape,
    stripColors: stripColors,
    containsNullConditionalFormat: containsNullConditionalFormat,
    FormatTranslator: FormatTranslator
};

}));
