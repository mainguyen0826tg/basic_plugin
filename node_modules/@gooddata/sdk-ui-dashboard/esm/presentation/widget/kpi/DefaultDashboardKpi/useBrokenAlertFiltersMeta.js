import { __awaiter, __generator, __read } from "tslib";
// (C) 2021 GoodData Corporation
import { NotSupported, } from "@gooddata/sdk-backend-spi";
import { useBackendStrict, useCancelablePromise, useWorkspaceStrict, } from "@gooddata/sdk-ui";
import { isAttributeElementsByRef, objRefToString } from "@gooddata/sdk-model";
import { isBrokenAlertAttributeFilterInfo } from "../../../../model";
/**
 * the amount of elements to load, this should be small enough to be efficient,
 * and large enough to always be longer than the broken alert filters display
 */
var DEFAULT_ATTRIBUTE_ELEMENT_COUNT = 20;
/**
 * @internal
 */
export function useBrokenAlertFiltersMeta(_a) {
    var _this = this;
    var backend = _a.backend, brokenAlertFilters = _a.brokenAlertFilters, dateDatasets = _a.dateDatasets, workspace = _a.workspace, onCancel = _a.onCancel, onError = _a.onError, onLoading = _a.onLoading, onPending = _a.onPending, onSuccess = _a.onSuccess;
    var effectiveBackend = useBackendStrict(backend, "useBrokenAlertFiltersMeta");
    var effectiveWorkspace = useWorkspaceStrict(workspace, "useBrokenAlertFiltersMeta");
    var promise = brokenAlertFilters
        ? function () { return __awaiter(_this, void 0, void 0, function () {
            var filtersToLoad, filterDataPromise, filterData, attributeFiltersMeta;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        filtersToLoad = brokenAlertFilters.filter(isBrokenAlertAttributeFilterInfo);
                        filterDataPromise = Promise.all(filtersToLoad.map(function (filter) { return __awaiter(_this, void 0, void 0, function () {
                            var attributeFilter, displayForm, attributesService, _a, elements, displayFormData, attribute;
                            return __generator(this, function (_b) {
                                switch (_b.label) {
                                    case 0:
                                        attributeFilter = filter.alertFilter.attributeFilter;
                                        if (!isAttributeElementsByRef(attributeFilter.attributeElements)) {
                                            throw new NotSupported("Only URI attribute filters are supported in useBrokenAlertFiltersMeta");
                                        }
                                        displayForm = attributeFilter.displayForm;
                                        attributesService = effectiveBackend.workspace(effectiveWorkspace).attributes();
                                        return [4 /*yield*/, Promise.all([
                                                attributesService
                                                    .elements()
                                                    .forDisplayForm(displayForm)
                                                    .withLimit(DEFAULT_ATTRIBUTE_ELEMENT_COUNT)
                                                    .withOptions({
                                                    uris: attributeFilter.negativeSelection
                                                        ? undefined // for negative filters we need to load the items NOT selected, however there is no way of doing that, so we load everything
                                                        : attributeFilter.attributeElements.uris,
                                                    includeTotalCountWithoutFilters: true,
                                                })
                                                    .query(),
                                                attributesService.getAttributeDisplayForm(displayForm),
                                            ])];
                                    case 1:
                                        _a = __read.apply(void 0, [_b.sent(), 2]), elements = _a[0], displayFormData = _a[1];
                                        return [4 /*yield*/, attributesService.getAttribute(displayFormData.attribute)];
                                    case 2:
                                        attribute = _b.sent();
                                        return [2 /*return*/, {
                                                elements: elements,
                                                displayForm: displayForm,
                                                title: attribute.title,
                                            }];
                                }
                            });
                        }); }));
                        return [4 /*yield*/, filterDataPromise];
                    case 1:
                        filterData = _a.sent();
                        attributeFiltersMeta = filterData.reduce(function (acc, curr) {
                            acc[objRefToString(curr.displayForm)] = {
                                title: curr.title,
                                totalElementsCount: curr.elements.totalCount,
                                validElements: curr.elements.items,
                            };
                            return acc;
                        }, {});
                        return [2 /*return*/, {
                                attributeFiltersMeta: attributeFiltersMeta,
                                dateDatasets: dateDatasets.map(function (ds) { return ds.dataSet; }),
                            }];
                }
            });
        }); }
        : null;
    return useCancelablePromise({ promise: promise, onCancel: onCancel, onError: onError, onLoading: onLoading, onPending: onPending, onSuccess: onSuccess }, [
        effectiveBackend,
        effectiveWorkspace,
        brokenAlertFilters,
    ]);
}
//# sourceMappingURL=useBrokenAlertFiltersMeta.js.map