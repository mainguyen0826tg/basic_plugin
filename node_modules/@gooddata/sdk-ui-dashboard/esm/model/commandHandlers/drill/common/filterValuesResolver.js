// (C) 2021 GoodData Corporation
import { __awaiter, __generator, __read, __spread } from "tslib";
import invariant from "ts-invariant";
import isEmpty from "lodash/isEmpty";
import { attributeElementsCount, filterAttributeElements, filterObjRef, isAbsoluteDateFilter, isDateFilter, objRefToString, isAttributeFilter, isObjRef, } from "@gooddata/sdk-model";
var MAX_ELEMENTS_COUNT_PER_REQUEST = 500; // should cover all attribute filters created by UI where we have 500 elements limit
/**
 * Resolves filter values
 *
 * @param filters - Filters with resolvable values
 *  = all selected elements of attribute filter
 *  + from/to limits of relative date filter
 *  + from/to limits of absolute date filter
 * @returns Map of resolved filter values per filter's identifier (date dimension ref or attribute DF ref)
 * @alpha
 */
export function resolveFilterValues(filters, backend, workspace) {
    return __awaiter(this, void 0, void 0, function () {
        var promises;
        return __generator(this, function (_a) {
            promises = filters.map(function (filter) {
                if (isAbsoluteDateFilter(filter)) {
                    return new Promise(function (resolve) {
                        return resolve({
                            from: filter.absoluteDateFilter.from,
                            to: filter.absoluteDateFilter.to,
                        });
                    });
                }
                invariant(backend, "backend needs to be provided for this type of filter: " + filter);
                invariant(workspace, "workspace needs to be provided for this type of filter: " + filter);
                if (isAttributeFilter(filter)) {
                    return resolveAttributeFilterValues(filter, backend, workspace);
                }
                else {
                    return resolveRelativeDateFilterValues(filter, backend, workspace);
                }
            });
            return [2 /*return*/, Promise.all(promises).then(function (resolvedValues) {
                    var resolvedValuesMap = {
                        dateFilters: [],
                        attributeFilters: {},
                    };
                    return resolvedValues.reduce(function (result, _resolvedValue, index) {
                        var filter = filters[index];
                        var ref = filterObjRef(filter);
                        invariant(ref, "filter without reference not supported: " + filter);
                        if (isDateFilter(filter)) {
                            var value = getResolvedFilterValues(resolvedValues, filter, index);
                            value && result.dateFilters.push(value);
                        }
                        if (isAttributeFilter(filter)) {
                            var refString = objRefToString(ref);
                            var value = getResolvedFilterValues(resolvedValues, filter, index);
                            if (value) {
                                result.attributeFilters[refString] = value;
                            }
                        }
                        return result;
                    }, resolvedValuesMap);
                })];
        });
    });
}
function resolveRelativeDateFilterValues(filter, backend, workspace) {
    return __awaiter(this, void 0, void 0, function () {
        var foundDayDisplayForm, dataSet, dateDataSetAttributes, foundDayAttribute, attributesService, elementsQuery, elements, hasNextPage, result, _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (!isObjRef(filter.relativeDateFilter.dataSet)) return [3 /*break*/, 2];
                    return [4 /*yield*/, (backend === null || backend === void 0 ? void 0 : backend.workspace(workspace).catalog().forDataset(filter.relativeDateFilter.dataSet).load())];
                case 1:
                    dataSet = _b.sent();
                    if (dataSet.dateDatasets) {
                        dateDataSetAttributes = dataSet.dateDatasets()[0].dateAttributes;
                        foundDayAttribute = dateDataSetAttributes.find(function (dateDataSetAttr) { return dateDataSetAttr.granularity === "GDC.time.date"; });
                        foundDayDisplayForm = foundDayAttribute && foundDayAttribute.defaultDisplayForm;
                    }
                    _b.label = 2;
                case 2:
                    attributesService = backend.workspace(workspace).attributes();
                    elementsQuery = attributesService.elements().forFilter(filter, foundDayDisplayForm === null || foundDayDisplayForm === void 0 ? void 0 : foundDayDisplayForm.ref);
                    return [4 /*yield*/, elementsQuery.query()];
                case 3:
                    elements = _b.sent();
                    hasNextPage = elements.limit + elements.offset < elements.totalCount;
                    if (!hasNextPage) return [3 /*break*/, 5];
                    return [4 /*yield*/, elements.goTo(Math.ceil(elements.totalCount / elements.limit) - 1)];
                case 4:
                    _a = _b.sent();
                    return [3 /*break*/, 6];
                case 5:
                    _a = elements;
                    _b.label = 6;
                case 6:
                    result = _a;
                    return [2 /*return*/, {
                            from: elements.items[0].title,
                            to: getLastTitle(result.items),
                        }];
            }
        });
    });
}
function resolveAttributeFilterValues(filter, backend, workspace) {
    return __awaiter(this, void 0, void 0, function () {
        var result, attributesService, elementsQuery, selectedElements, selectedElementsCount, requestLimit, elementsPage, elements;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    result = {};
                    attributesService = backend.workspace(workspace).attributes();
                    elementsQuery = attributesService.elements().forFilter(filter);
                    selectedElements = filterAttributeElements(filter);
                    selectedElementsCount = attributeElementsCount(selectedElements);
                    // nothing to resolve at all (eg. ALL filter)
                    if (selectedElementsCount === 0) {
                        return [2 /*return*/, result];
                    }
                    requestLimit = Math.min(selectedElementsCount, MAX_ELEMENTS_COUNT_PER_REQUEST);
                    return [4 /*yield*/, elementsQuery.withLimit(requestLimit).query()];
                case 1:
                    elementsPage = _a.sent();
                    elements = [];
                    _a.label = 2;
                case 2:
                    if (!!isEmpty(elementsPage.items)) return [3 /*break*/, 4];
                    elements.push.apply(elements, __spread(elementsPage.items));
                    return [4 /*yield*/, elementsPage.next()];
                case 3:
                    elementsPage = _a.sent();
                    return [3 /*break*/, 2];
                case 4: return [2 /*return*/, elements.reduce(function (map, element) {
                        map[element.uri] = element.title;
                        return map;
                    }, result)];
            }
        });
    });
}
function getResolvedFilterValues(array, filter, index) {
    if (isDateFilter(filter)) {
        return array[index];
    }
    return array[index];
}
function getLastTitle(items) {
    return items[items.length - 1].title;
}
//# sourceMappingURL=filterValuesResolver.js.map