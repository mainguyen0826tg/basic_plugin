import { __assign } from "tslib";
// (C) 2019-2021 GoodData Corporation
import partial from "lodash/partial";
import { DEFAULT_CLUSTER_FILTER, DEFAULT_CLUSTER_LABELS_CONFIG, DEFAULT_CLUSTER_LAYER_NAME, DEFAULT_CLUSTER_POINT_BORDERS, DEFAULT_CLUSTER_POINT_COLORS, DEFAULT_CLUSTER_POINT_SIZES, DEFAULT_LAYER_NAME, DEFAULT_PUSHPIN_BORDER_COLOR_VALUE, DEFAULT_PUSHPIN_OPTIONS, PUSHPIN_STYLE_CIRCLE, PUSHPIN_STYLE_CIRCLE_COLOR, PUSHPIN_STYLE_CIRCLE_SIZE, PUSHPIN_STYLE_CIRCLE_STROKE_COLOR, EMPTY_SEGMENT_VALUE, PUSHPIN_SIZE_OPTIONS_MAP, } from "./constants/geoChart";
import { BucketNames } from "@gooddata/sdk-ui";
import { getMinMax } from "./helpers/geoChart/common";
function createPushpinSizeOptions(geoData, geoPointsConfig) {
    var size = geoData.size;
    var defaultRadius = PUSHPIN_SIZE_OPTIONS_MAP.min["default"] / 2;
    if (size === undefined || size.data.length === 0) {
        return defaultRadius;
    }
    var _a = getMinMax(size.data), minSizeFromData = _a.min, maxSizeFromData = _a.max;
    if (maxSizeFromData === minSizeFromData) {
        return defaultRadius;
    }
    var _b = geoPointsConfig || {}, _c = _b.minSize, minSizeFromConfig = _c === void 0 ? "default" : _c, _d = _b.maxSize, maxSizeFromConfig = _d === void 0 ? "default" : _d;
    var minSizeInPixel = PUSHPIN_SIZE_OPTIONS_MAP.min[minSizeFromConfig];
    var maxSizeInPixel = PUSHPIN_SIZE_OPTIONS_MAP.max[maxSizeFromConfig];
    var base = Math.pow(maxSizeInPixel / minSizeInPixel, 0.25);
    var getStopPointSize = partial(getPointSize, minSizeInPixel, base);
    // The mouseenter event uses queryRenderedFeatures to determine when the mouse is touching a feature
    // And queryRenderedFeatures is not supporting nested object in expression
    // https://github.com/mapbox/mapbox-gl-js/issues/7194
    return [
        "step",
        ["get", "pushpinSize"],
        Math.round(minSizeInPixel / 2),
        getStopPointSize(1),
        Math.round(getStopPointSize(1) / 2),
        getStopPointSize(2),
        Math.round(getStopPointSize(2) / 2),
        getStopPointSize(3),
        Math.round(getStopPointSize(3) / 2),
        maxSizeInPixel,
        Math.round(maxSizeInPixel / 2),
    ];
}
function getPointSize(minSizeInPixel, base, exponent) {
    var stepValue = minSizeInPixel * Math.pow(base, exponent);
    return parseFloat(stepValue.toFixed(2));
}
export function createPushpinFilter(selectedSegmentItems) {
    return [
        "match",
        ["get", "uri", ["object", ["get", BucketNames.SEGMENT]]],
        selectedSegmentItems.length ? selectedSegmentItems : [EMPTY_SEGMENT_VALUE],
        true,
        false,
    ]; // true/false are the output values, from the https://docs.mapbox.com/mapbox-gl-js/style-spec/expressions/#match
}
function createPushpinColorOptions() {
    return ["string", ["get", "background", ["object", ["get", "color"]]]];
}
function createPushpinBorderOptions() {
    return ["string", ["get", "border", ["object", ["get", "color"]]], DEFAULT_PUSHPIN_BORDER_COLOR_VALUE];
}
export function createPushpinDataLayer(dataSourceName, geoData, config) {
    var _a;
    var _b = config || {}, _c = _b.selectedSegmentItems, selectedSegmentItems = _c === void 0 ? [] : _c, _d = _b.points, geoPointsConfig = _d === void 0 ? {} : _d;
    var layer = {
        id: DEFAULT_LAYER_NAME,
        type: PUSHPIN_STYLE_CIRCLE,
        source: dataSourceName,
        paint: __assign(__assign({}, DEFAULT_PUSHPIN_OPTIONS), (_a = {}, _a[PUSHPIN_STYLE_CIRCLE_COLOR] = createPushpinColorOptions(), _a[PUSHPIN_STYLE_CIRCLE_STROKE_COLOR] = createPushpinBorderOptions(), _a[PUSHPIN_STYLE_CIRCLE_SIZE] = createPushpinSizeOptions(geoData, geoPointsConfig), _a))
    };
    if (selectedSegmentItems.length > 0) {
        layer.filter = createPushpinFilter(selectedSegmentItems);
    }
    return layer;
}
/**
 * Create layer for clustered points/pins which have 'properties.point_count' indicates number of same points is clustered together
 * @param dataSourceName
 */
export function createClusterPoints(dataSourceName) {
    var _a;
    return {
        id: DEFAULT_CLUSTER_LAYER_NAME,
        type: PUSHPIN_STYLE_CIRCLE,
        source: dataSourceName,
        filter: DEFAULT_CLUSTER_FILTER,
        paint: __assign(__assign({}, DEFAULT_CLUSTER_POINT_BORDERS), (_a = {}, _a[PUSHPIN_STYLE_CIRCLE_COLOR] = DEFAULT_CLUSTER_POINT_COLORS, _a[PUSHPIN_STYLE_CIRCLE_SIZE] = DEFAULT_CLUSTER_POINT_SIZES, _a))
    };
}
/**
 * Create layer for cluster labels which indicate number of points/pins is clustered
 * @param dataSourceName
 */
export function createClusterLabels(dataSourceName) {
    return __assign(__assign({}, DEFAULT_CLUSTER_LABELS_CONFIG), { source: dataSourceName, filter: DEFAULT_CLUSTER_FILTER });
}
/**
 * Create layer for un-clustered points which are not close to others
 * @param dataSourceName
 * @param selectedSegmentItems
 */
export function createUnclusterPoints(dataSourceName) {
    var _a;
    return {
        id: DEFAULT_LAYER_NAME,
        type: PUSHPIN_STYLE_CIRCLE,
        source: dataSourceName,
        filter: ["!", DEFAULT_CLUSTER_FILTER],
        paint: __assign(__assign({}, DEFAULT_PUSHPIN_OPTIONS), (_a = {}, _a[PUSHPIN_STYLE_CIRCLE_COLOR] = createPushpinColorOptions(), _a[PUSHPIN_STYLE_CIRCLE_STROKE_COLOR] = DEFAULT_PUSHPIN_BORDER_COLOR_VALUE, _a[PUSHPIN_STYLE_CIRCLE_SIZE] = PUSHPIN_SIZE_OPTIONS_MAP.min["default"] / 2, _a))
    };
}
//# sourceMappingURL=geoChartDataLayers.js.map