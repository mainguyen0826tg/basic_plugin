import { __spreadArrays } from "tslib";
// (C) 2019-2020 GoodData Corporation
import flow from "lodash/flow";
import identity from "lodash/identity";
import isArray from "lodash/isArray";
import isObject from "lodash/isObject";
import isString from "lodash/isString";
import stringifyObject from "stringify-object";
import { isUriRef } from "../../objRef";
import { isMeasureLocator, isAttributeSort, isMeasureSort, isAttributeAreaSort, } from "../base/sort";
import { isAbsoluteDateFilter, isRelativeDateFilter, isPositiveAttributeFilter, isNegativeAttributeFilter, isMeasureValueFilter, isComparisonCondition, isRangeCondition, isRankingFilter, } from "../filter";
import { isMeasureDefinition, isArithmeticMeasureDefinition, isPoPMeasureDefinition, isPreviousPeriodMeasureDefinition, isMeasure, } from "../measure";
import { isAttribute } from "../attribute";
var stringify = function (input) {
    return stringifyObject(input, {
        singleQuotes: false,
        inlineCharacterLimit: 50,
        indent: "    ",
    });
};
var ARRAY_JOINER = ", ";
var getObjQualifierValue = function (value) { return (isUriRef(value) ? value.uri : value.identifier); };
// dot suffix handling e. g. ".localIdentifier(...)"
// is curried explicitly to allow easier composition in cases where more than one dot suffix is supported
var addStringBuilderSegment = function (identifier, helperName) {
    if (helperName === void 0) { helperName = identifier; }
    return function (objToConvert) {
        return function (value) {
            return objToConvert[identifier] ? value + "." + helperName + "(\"" + objToConvert[identifier] + "\")" : value;
        };
    };
};
var addAggregation = addStringBuilderSegment("aggregation");
var addAlias = addStringBuilderSegment("alias");
var addFormat = addStringBuilderSegment("format");
var addLocalId = addStringBuilderSegment("localIdentifier", "localId");
var addTitle = addStringBuilderSegment("title");
var addFilters = function (_a) {
    var filters = _a.filters;
    return function (value) {
        return filters ? value + ".filters(" + filters.map(factoryNotationFor).join(ARRAY_JOINER) + ")" : value;
    };
};
var addRatio = function (_a) {
    var computeRatio = _a.computeRatio;
    return function (value) {
        return computeRatio ? value + ".ratio()" : value;
    };
};
var getBuilder = function (defaultBuilder, builderSegmentHandlers) {
    var builder = flow(builderSegmentHandlers)(defaultBuilder);
    return builder === defaultBuilder ? "undefined" : builder;
};
// converters for each supported object to Model notation string
var convertAttribute = function (_a) {
    var attribute = _a.attribute;
    var builder = getBuilder("a => a", [addAlias(attribute), addLocalId(attribute)]);
    return "newAttribute(" + stringify(attribute.displayForm) + ", " + builder + ")";
};
var baseMeasureDotAdders = function (measure) { return [
    addAlias(measure),
    addFormat(measure),
    addLocalId(measure),
    addTitle(measure),
]; };
var convertSimpleMeasure = function (measure, definition) {
    var builder = getBuilder("m => m", __spreadArrays(baseMeasureDotAdders(measure), [
        addAggregation(definition.measureDefinition),
        addFilters(definition.measureDefinition),
        addRatio(definition.measureDefinition),
    ]));
    return "newMeasure(" + stringify(definition.measureDefinition.item) + ", " + builder + ")";
};
var convertArithmeticMeasure = function (measure, definition) {
    var builder = getBuilder("m => m", baseMeasureDotAdders(measure));
    return "newArithmeticMeasure(" + stringify(definition.arithmeticMeasure.measureIdentifiers) + ", \"" + definition.arithmeticMeasure.operator + "\", " + builder + ")";
};
var convertPopMeasure = function (measure, definition) {
    var builder = getBuilder("m => m", baseMeasureDotAdders(measure));
    return "newPopMeasure(\"" + definition.popMeasureDefinition.measureIdentifier + "\", \"" + getObjQualifierValue(definition.popMeasureDefinition.popAttribute) + "\", " + builder + ")";
};
var convertPreviousPeriodMeasure = function (measure, definition) {
    var builder = getBuilder("m => m", baseMeasureDotAdders(measure));
    return "newPreviousPeriodMeasure(\"" + definition.previousPeriodMeasure.measureIdentifier + "\", [" + (definition.previousPeriodMeasure.dateDataSets &&
        definition.previousPeriodMeasure.dateDataSets
            .map(function (s) {
            return stringify({
                dataSet: getObjQualifierValue(s.dataSet),
                periodsAgo: s.periodsAgo,
            });
        })
            .join(ARRAY_JOINER)) + "], " + builder + ")";
};
var convertMeasure = function (_a) {
    var measure = _a.measure;
    var definition = measure.definition;
    if (isMeasureDefinition(definition)) {
        return convertSimpleMeasure(measure, definition);
    }
    else if (isArithmeticMeasureDefinition(definition)) {
        return convertArithmeticMeasure(measure, definition);
    }
    else if (isPoPMeasureDefinition(definition)) {
        return convertPopMeasure(measure, definition);
    }
    else if (isPreviousPeriodMeasureDefinition(definition)) {
        return convertPreviousPeriodMeasure(measure, definition);
    }
    throw new Error("Unknown measure type");
};
var convertAttributeAreaSortItem = function (_a) {
    var attributeSortItem = _a.attributeSortItem;
    return "newAttributeAreaSort(\"" + attributeSortItem.attributeIdentifier + "\", \"" + attributeSortItem.direction + "\", \"" + attributeSortItem.aggregation + "\")";
};
var convertAttributeSortItem = function (_a) {
    var attributeSortItem = _a.attributeSortItem;
    return "newAttributeSort(\"" + attributeSortItem.attributeIdentifier + "\", \"" + attributeSortItem.direction + "\", " + !!attributeSortItem.aggregation + ")";
};
var convertMeasureSortItem = function (_a) {
    var measureSortItem = _a.measureSortItem;
    var locators = measureSortItem.locators || [];
    var measureLocator = locators.find(function (l) { return isMeasureLocator(l); });
    var attributeLocators = locators.filter(function (l) { return !isMeasureLocator(l); });
    return "newMeasureSort(\"" + measureLocator.measureLocatorItem.measureIdentifier + "\", \"" + measureSortItem.direction + "\", " + stringify(attributeLocators) + ")";
};
var convertAbsoluteDateFilter = function (_a) {
    var _b = _a.absoluteDateFilter, dataSet = _b.dataSet, from = _b.from, to = _b.to;
    var args = [dataSet, from, to].filter(identity).map(stringify);
    return "newAbsoluteDateFilter(" + args.join(ARRAY_JOINER) + ")";
};
var convertRelativeDateFilter = function (_a) {
    var _b = _a.relativeDateFilter, dataSet = _b.dataSet, granularity = _b.granularity, from = _b.from, to = _b.to;
    var args = [dataSet, granularity, from, to].filter(identity).map(stringify);
    return "newRelativeDateFilter(" + args.join(ARRAY_JOINER) + ")";
};
var convertPositiveAttributeFilter = function (_a) {
    var _b = _a.positiveAttributeFilter, displayForm = _b.displayForm, inValues = _b.in;
    var args = [displayForm, inValues].filter(identity).map(stringify);
    return "newPositiveAttributeFilter(" + args.join(ARRAY_JOINER) + ")";
};
var convertNegativeAttributeFilter = function (_a) {
    var _b = _a.negativeAttributeFilter, displayForm = _b.displayForm, notIn = _b.notIn;
    var args = [displayForm, notIn].filter(identity).map(stringify);
    return "newNegativeAttributeFilter(" + args.join(ARRAY_JOINER) + ")";
};
var convertMeasureValueFilter = function (_a) {
    var _b = _a.measureValueFilter, measure = _b.measure, condition = _b.condition;
    var ref = stringify(measure);
    if (isComparisonCondition(condition)) {
        return "newMeasureValueFilter(" + ref + ", \"" + condition.comparison.operator + "\", " + condition.comparison.value + ")";
    }
    else if (isRangeCondition(condition)) {
        return "newMeasureValueFilter(" + ref + ", \"" + condition.range.operator + "\", " + condition.range.from + ", " + condition.range.to + ")";
    }
    return "{ measureValueFilter: { measure: " + ref + " }";
};
var convertRankingFilter = function (_a) {
    var _b = _a.rankingFilter, measure = _b.measure, attributes = _b.attributes, value = _b.value, operator = _b.operator;
    var attributesString = attributes === null || attributes === void 0 ? void 0 : attributes.map(stringify).join(ARRAY_JOINER);
    var args = [
        stringify(measure),
        attributesString && "[" + attributesString + "]",
        "\"" + operator + "\"",
        "" + value,
    ].filter(isString);
    return "newRankingFilter(" + args.join(ARRAY_JOINER) + ")";
};
/**
 * Returns a code for generating the provided input using convenience factory methods where possible.
 * @param data - data to return the generating code for
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var factoryNotationFor = function (data) {
    if (isArray(data)) {
        return "[" + data.map(factoryNotationFor).join(ARRAY_JOINER) + "]";
    }
    else if (isAttribute(data)) {
        return convertAttribute(data);
    }
    else if (isMeasure(data)) {
        return convertMeasure(data);
    }
    else if (isAttributeAreaSort(data)) {
        return convertAttributeAreaSortItem(data);
    }
    else if (isAttributeSort(data)) {
        return convertAttributeSortItem(data);
    }
    else if (isMeasureSort(data)) {
        return convertMeasureSortItem(data);
    }
    else if (isAbsoluteDateFilter(data)) {
        return convertAbsoluteDateFilter(data);
    }
    else if (isRelativeDateFilter(data)) {
        return convertRelativeDateFilter(data);
    }
    else if (isPositiveAttributeFilter(data)) {
        return convertPositiveAttributeFilter(data);
    }
    else if (isNegativeAttributeFilter(data)) {
        return convertNegativeAttributeFilter(data);
    }
    else if (isMeasureValueFilter(data)) {
        return convertMeasureValueFilter(data);
    }
    else if (isRankingFilter(data)) {
        return convertRankingFilter(data);
    }
    return isObject(data) || isString(data) ? stringify(data) : data;
};
//# sourceMappingURL=index.js.map