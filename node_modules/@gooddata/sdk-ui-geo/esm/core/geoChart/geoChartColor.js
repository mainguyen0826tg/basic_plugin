import { __assign, __spreadArrays } from "tslib";
// (C) 2020 GoodData Corporation
import range from "lodash/range";
import isEmpty from "lodash/isEmpty";
import isFinite from "lodash/isFinite";
import { DEFAULT_PUSHPIN_BORDER_COLOR_VALUE, DEFAULT_PUSHPIN_COLOR_OPACITY, DEFAULT_PUSHPIN_COLOR_SCALE, } from "./constants/geoChart";
import { getColorPalette, rgbToRgba } from "./helpers/geoChart/colors";
import { isAttributeDescriptor, isResultAttributeHeader } from "@gooddata/sdk-backend-spi";
import { getMinMax } from "./helpers/geoChart/common";
var DEFAULT_SEGMENT_ITEM = "default_segment_item";
var DEFAULT_COLOR_INDEX_IN_PALETTE = DEFAULT_PUSHPIN_COLOR_SCALE - 1;
export function getColorIndexInPalette(value, min, max) {
    if (value === null || !isFinite(value) || min === max || value === min) {
        return 0;
    }
    if (value === max) {
        return DEFAULT_COLOR_INDEX_IN_PALETTE;
    }
    var step = (max - min) / DEFAULT_PUSHPIN_COLOR_SCALE;
    for (var i = 0, offset = min; i < DEFAULT_PUSHPIN_COLOR_SCALE; i++, offset += step) {
        if (offset >= value) {
            return i;
        }
    }
    return DEFAULT_COLOR_INDEX_IN_PALETTE;
}
export function getColorPaletteMapping(colorStrategy) {
    var colorAssignment = colorStrategy.getColorAssignment();
    return colorAssignment.reduce(function (result, item, index) {
        var _a, _b;
        var color = colorStrategy.getColorByIndex(index);
        var colorPalette = getColorPalette(color, DEFAULT_PUSHPIN_COLOR_OPACITY);
        // color base on Location
        if (isAttributeDescriptor(item.headerItem)) {
            return _a = {},
                _a[DEFAULT_SEGMENT_ITEM] = colorPalette,
                _a;
        }
        // color base on SegmentBy
        var name = isResultAttributeHeader(item.headerItem)
            ? item.headerItem.attributeHeaderItem.name
            : DEFAULT_SEGMENT_ITEM;
        return __assign(__assign({}, result), (_b = {}, _b[name] = colorPalette, _b));
    }, {});
}
/**
 * Return RGB border and background colors base on color and segment values
 *  Example:
 *      [any-number] => [{
 *           border: "rgb(127,224,198)",
 *           background: "rgb(215,242,250)",
 *      }]
 * @param colorValues
 * @param segmentValues
 */
export function getPushpinColors(colorValues, segmentValues, colorStrategy) {
    if (segmentValues === void 0) { segmentValues = []; }
    var defaultColorValue = colorStrategy.getColorByIndex(0);
    var defaultColor = rgbToRgba(defaultColorValue, DEFAULT_PUSHPIN_COLOR_OPACITY);
    if (!colorValues.length && !segmentValues.length) {
        return [
            {
                border: DEFAULT_PUSHPIN_BORDER_COLOR_VALUE,
                background: defaultColor
            },
        ];
    }
    var segmentNames = __spreadArrays(segmentValues);
    var colorPaletteMapping = getColorPaletteMapping(colorStrategy);
    if (!colorValues.length) {
        return segmentNames.map(function (name) {
            var palette = colorPaletteMapping[name];
            return {
                border: DEFAULT_PUSHPIN_BORDER_COLOR_VALUE,
                background: palette[DEFAULT_COLOR_INDEX_IN_PALETTE]
            };
        });
    }
    var colorsWithoutNull = colorValues.filter(function (value) { return value !== null && isFinite(value); });
    var _a = getMinMax(colorsWithoutNull), min = _a.min, max = _a.max;
    if (min === max && !segmentValues.length) {
        return [
            {
                border: DEFAULT_PUSHPIN_BORDER_COLOR_VALUE,
                background: defaultColor
            },
        ];
    }
    return colorValues.map(function (color, index) {
        var value = color !== null && isFinite(color) ? color : min;
        var colorIndex = getColorIndexInPalette(value, min, max);
        var segmentItemName = segmentNames[index] || DEFAULT_SEGMENT_ITEM;
        var palette = colorPaletteMapping[segmentItemName];
        return {
            border: palette[DEFAULT_COLOR_INDEX_IN_PALETTE],
            background: palette[colorIndex]
        };
    });
}
export function generateLegendColorData(colorSeries, colorString) {
    if (isEmpty(colorSeries)) {
        return [];
    }
    var colorPalette = getColorPalette(colorString, DEFAULT_PUSHPIN_COLOR_OPACITY);
    var min = Math.min.apply(Math, colorSeries);
    var max = Math.max.apply(Math, colorSeries);
    var offset = (max - min) / DEFAULT_PUSHPIN_COLOR_SCALE;
    if (min === max) {
        return [];
    }
    return range(0, DEFAULT_PUSHPIN_COLOR_SCALE).map(function (index) {
        var from = min + offset * index;
        var isLastItem = index === DEFAULT_PUSHPIN_COLOR_SCALE - 1;
        var to = isLastItem ? max : from + offset;
        var range = {
            from: from,
            to: to
        };
        return {
            range: range,
            color: colorPalette[index]
        };
    });
}
//# sourceMappingURL=geoChartColor.js.map