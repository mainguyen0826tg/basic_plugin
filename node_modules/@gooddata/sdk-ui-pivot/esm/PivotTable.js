import { __assign, __extends, __spreadArrays } from "tslib";
// (C) 2007-2018 GoodData Corporation
import React from "react";
import { CorePivotTableAgImpl } from "./CorePivotTable";
import { attributeLocalId, bucketAttributes, bucketIsEmpty, bucketsFind, bucketTotals, MeasureGroupIdentifier, newBucket, } from "@gooddata/sdk-model";
import omit from "lodash/omit";
import { IntlTranslationsProvider, withContexts, BucketNames, IntlWrapper, useResolveValuesWithPlaceholders, } from "@gooddata/sdk-ui";
import invariant from "ts-invariant";
import { AVAILABLE_TOTALS } from "./impl/base/constants";
/**
 * Prepares new execution matching pivot table props.
 *
 * @param props - pivot table props
 * @returns new prepared execution
 */
function prepareExecution(props) {
    var _a;
    var backend = props.backend, workspace = props.workspace, filters = props.filters, _b = props.sortBy, sortBy = _b === void 0 ? [] : _b, _c = props.execConfig, execConfig = _c === void 0 ? {} : _c;
    return (_a = backend
        .workspace(workspace)
        .execution()
        .forBuckets(getBuckets(props), filters)
        .withDimensions(pivotDimensions))
        .withSorting.apply(_a, sortBy).withExecConfig(execConfig);
}
function getBuckets(props) {
    var _a = props.measures, measures = _a === void 0 ? [] : _a, _b = props.rows, rows = _b === void 0 ? [] : _b, _c = props.columns, columns = _c === void 0 ? [] : _c, _d = props.totals, totals = _d === void 0 ? [] : _d;
    return [
        newBucket.apply(void 0, __spreadArrays([BucketNames.MEASURES], measures)),
        // ATTRIBUTE for backwards compatibility with Table component. Actually ROWS
        newBucket.apply(void 0, __spreadArrays([BucketNames.ATTRIBUTE], rows, totals)),
        newBucket.apply(void 0, __spreadArrays([BucketNames.COLUMNS], columns)),
    ];
}
function pivotDimensions(def) {
    var buckets = def.buckets;
    var row = bucketsFind(buckets, BucketNames.ATTRIBUTE);
    var columns = bucketsFind(buckets, BucketNames.COLUMNS);
    var measures = bucketsFind(buckets, BucketNames.MEASURES);
    var rowAttributeIds = row ? bucketAttributes(row).map(attributeLocalId) : [];
    var columnAttributeIds = columns ? bucketAttributes(columns).map(attributeLocalId) : [];
    var measuresItemIdentifiers = measures && !bucketIsEmpty(measures) ? [MeasureGroupIdentifier] : [];
    var totals = row ? bucketTotals(row) : [];
    var totalsProp = totals.length ? { totals: totals } : {};
    return [
        __assign({ itemIdentifiers: rowAttributeIds }, totalsProp),
        {
            itemIdentifiers: __spreadArrays(columnAttributeIds, measuresItemIdentifiers),
        },
    ];
}
var RenderPivotTable = /** @class */ (function (_super) {
    __extends(RenderPivotTable, _super);
    function RenderPivotTable() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RenderPivotTable.prototype.render = function () {
        var _a = this.props, exportTitle = _a.exportTitle, backend = _a.backend, workspace = _a.workspace, _b = _a.config, config = _b === void 0 ? {} : _b;
        invariant(backend, "Backend was not provided for PivotTable. Either pass it as a prop or use BackendContext.");
        invariant(workspace, "Workspace was not provided for PivotTable. Either pass it as a prop or use WorkspaceContext.");
        var newProps = omit(this.props, ["measures", "rows", "columns", "totals", "filters", "sortBy"]);
        var pivotTableConfig = __assign(__assign({}, config), { menu: pivotTableMenuForCapabilities(backend.capabilities, config === null || config === void 0 ? void 0 : config.menu) });
        var corePivotProps = omit(newProps, ["backend", "workspace"]);
        var execution = prepareExecution(this.props);
        return (React.createElement(IntlWrapper, { locale: this.props.locale },
            React.createElement(IntlTranslationsProvider, null, function (translationProps) {
                return (React.createElement(CorePivotTableAgImpl, __assign({}, corePivotProps, { config: pivotTableConfig, intl: translationProps.intl, execution: execution, exportTitle: exportTitle || "PivotTable" })));
            })));
    };
    return RenderPivotTable;
}(React.Component));
var WrappedPivotTable = withContexts(RenderPivotTable);
/**
 * [PivotTable](https://sdk.gooddata.com/gooddata-ui/docs/pivot_table_component.html)
 * is a component with bucket props measures, rows, columns, totals, sortBy, filters
 *
 * @public
 */
export var PivotTable = function (props) {
    var _a = useResolveValuesWithPlaceholders([props.measures, props.columns, props.rows, props.totals, props.filters, props.sortBy], props.placeholdersResolutionContext), measures = _a[0], columns = _a[1], rows = _a[2], totals = _a[3], filters = _a[4], sortBy = _a[5];
    return React.createElement(WrappedPivotTable, __assign({}, props, { measures: measures, columns: columns, rows: rows, totals: totals, filters: filters, sortBy: sortBy }));
};
/**
 * Given analytical backend capabilities and the desired aggregations menu config, this function will correct the menu
 * configuration so that it fits the capabilities.
 *
 * The function will explicitly set the options regardless of what is the (current) default value of the option if
 * it is not present in the menu. The backend capabilities are a hard stop for features.
 *
 * Note: the {@link PivotTable} will use this function out of the box to ensure the effective menu configuration
 * matches the backend capabilities. You don't need to use when creating a PivotTable.
 *
 * @param capabilities - backend capabilities
 * @param desiredMenu - aggregation menu configuration desired by the client
 * @public
 */
export function pivotTableMenuForCapabilities(capabilities, desiredMenu) {
    var _a;
    if (desiredMenu === void 0) { desiredMenu = {}; }
    var effectiveMenu = __assign({}, desiredMenu);
    if (!capabilities.canCalculateGrandTotals) {
        return {
            aggregations: false,
        };
    }
    if (!capabilities.canCalculateSubTotals) {
        effectiveMenu.aggregationsSubMenu = false;
    }
    if (!capabilities.canCalculateNativeTotals) {
        effectiveMenu.aggregationTypes = ((_a = effectiveMenu.aggregationTypes) !== null && _a !== void 0 ? _a : AVAILABLE_TOTALS).filter(function (totalType) { return totalType !== "nat"; });
    }
    if (effectiveMenu.aggregationTypes && effectiveMenu.aggregationTypes.length === 0) {
        return {
            aggregations: false,
        };
    }
    return effectiveMenu;
}
//# sourceMappingURL=PivotTable.js.map