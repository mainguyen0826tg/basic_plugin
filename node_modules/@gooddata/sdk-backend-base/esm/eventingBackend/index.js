import { __extends } from "tslib";
// (C) 2007-2021 GoodData Corporation
import isEmpty from "lodash/isEmpty";
import { v4 as uuid } from "uuid";
import { decoratedBackend } from "../decoratedBackend";
import { DecoratedExecutionFactory, DecoratedExecutionResult, DecoratedPreparedExecution, } from "../decoratedBackend/execution";
var WithExecutionEventing = /** @class */ (function (_super) {
    __extends(WithExecutionEventing, _super);
    function WithExecutionEventing(decorated, callbacks) {
        var _this = _super.call(this, decorated) || this;
        _this.callbacks = callbacks;
        _this.execute = function () {
            var _a = _this.callbacks, beforeExecute = _a.beforeExecute, successfulExecute = _a.successfulExecute, failedExecute = _a.failedExecute;
            var executionId = uuid();
            beforeExecute === null || beforeExecute === void 0 ? void 0 : beforeExecute(_this.definition, executionId);
            return _super.prototype.execute.call(_this)
                .then(function (result) {
                successfulExecute === null || successfulExecute === void 0 ? void 0 : successfulExecute(result, executionId);
                return new WithExecutionResultEventing(result, _this.createNew, _this.callbacks, executionId);
            })
                .catch(function (error) {
                failedExecute === null || failedExecute === void 0 ? void 0 : failedExecute(error, executionId);
                throw error;
            });
        };
        _this.createNew = function (decorated) {
            return new WithExecutionEventing(decorated, _this.callbacks);
        };
        return _this;
    }
    return WithExecutionEventing;
}(DecoratedPreparedExecution));
var WithExecutionResultEventing = /** @class */ (function (_super) {
    __extends(WithExecutionResultEventing, _super);
    function WithExecutionResultEventing(decorated, wrapper, callbacks, executionId) {
        var _this = _super.call(this, decorated, wrapper) || this;
        _this.callbacks = callbacks;
        _this.executionId = executionId;
        _this.readAll = function () {
            var _a = _this.callbacks, successfulResultReadAll = _a.successfulResultReadAll, failedResultReadAll = _a.failedResultReadAll;
            var promisedDataView = _super.prototype.readAll.call(_this);
            return promisedDataView
                .then(function (res) {
                successfulResultReadAll === null || successfulResultReadAll === void 0 ? void 0 : successfulResultReadAll(res, _this.executionId);
                return res;
            })
                .catch(function (e) {
                failedResultReadAll === null || failedResultReadAll === void 0 ? void 0 : failedResultReadAll(e, _this.executionId);
                throw e;
            });
        };
        _this.readWindow = function (offset, size) {
            var _a = _this.callbacks, successfulResultReadWindow = _a.successfulResultReadWindow, failedResultReadWindow = _a.failedResultReadWindow;
            var promisedDataView = _super.prototype.readWindow.call(_this, offset, size);
            return promisedDataView
                .then(function (res) {
                successfulResultReadWindow === null || successfulResultReadWindow === void 0 ? void 0 : successfulResultReadWindow(offset, size, res, _this.executionId);
                return res;
            })
                .catch(function (e) {
                failedResultReadWindow === null || failedResultReadWindow === void 0 ? void 0 : failedResultReadWindow(offset, size, e, _this.executionId);
                throw e;
            });
        };
        return _this;
    }
    return WithExecutionResultEventing;
}(DecoratedExecutionResult));
/**
 * This implementation of analytical backend decorates another implementation with support for eventing. Events
 * for significant actions are emitted to defined callback functions (event handlers).
 *
 * @param realBackend - backend supplying the actual implementation of SPI
 * @param callbacks - callbacks to event handlers
 * @beta
 */
export function withEventing(realBackend, callbacks) {
    if (isEmpty(callbacks)) {
        return realBackend;
    }
    return decoratedBackend(realBackend, {
        execution: function (original) {
            return new DecoratedExecutionFactory(original, function (execution) { return new WithExecutionEventing(execution, callbacks); });
        },
    });
}
//# sourceMappingURL=index.js.map