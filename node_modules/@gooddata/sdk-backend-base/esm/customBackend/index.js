// (C) 2019-2021 GoodData Corporation
import { __assign, __awaiter, __generator } from "tslib";
import { isNotAuthenticated, NotAuthenticated, NotSupported, } from "@gooddata/sdk-backend-spi";
import { AnonymousAuthProvider, AuthProviderCallGuard, } from "../toolkit/auth";
import { CustomWorkspace } from "./workspace";
//
//
//
/**
 * @internal
 */
var CustomBackend = /** @class */ (function () {
    function CustomBackend(config, authProvider, telemetryData) {
        var _this = this;
        this.telemetryData = telemetryData;
        this.onHostname = function (hostname) {
            var newConfig = __assign(__assign({}, _this.config), { hostname: hostname });
            return new CustomBackend(newConfig);
        };
        this.withAuthentication = function (provider) {
            var guardedAuthProvider = new AuthProviderCallGuard(provider);
            return new CustomBackend(_this.config, guardedAuthProvider);
        };
        this.authenticate = function (force) {
            if (!_this.authProvider) {
                return Promise.reject(new NotAuthenticated("Backend is not set up with authentication provider."));
            }
            if (force) {
                _this.authProvider.reset();
            }
            return _this.authProvider.authenticate(_this.getAuthenticationContext());
        };
        this.deauthenticate = function () {
            return _this.authProvider.deauthenticate(_this.getAuthenticationContext());
        };
        this.isAuthenticated = function () {
            return _this.authProvider.getCurrentPrincipal(_this.getAuthenticationContext());
        };
        this.withTelemetry = function (componentName, props) {
            return new CustomBackend(_this.config, _this.authProvider, {
                componentName: componentName,
                props: Object.keys(props),
            });
        };
        this.workspace = function (id) {
            return new CustomWorkspace(id, _this.config, {
                telemetry: _this.telemetryData,
                authApiCall: _this.authApiCall,
            });
        };
        this.workspaces = function () {
            throw new NotSupported("workspace listing is not supported");
        };
        this.currentUser = function () {
            throw new NotSupported("user service is not supported");
        };
        this.organization = function (_organizationId) {
            throw new NotSupported("organization is not supported");
        };
        this.organizations = function () {
            throw new NotSupported("organizations is not supported");
        };
        this.getAuthenticationContext = function (useClient) {
            return {
                client: useClient || _this.config.clientProvider(_this.config),
                backend: _this,
            };
        };
        this.authApiCall = function (call) { return __awaiter(_this, void 0, void 0, function () {
            var result, client, _a, _b, err_1, _c, _d, err_2;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        client = this.config.clientProvider(this.config);
                        _e.label = 1;
                    case 1:
                        _e.trys.push([1, 4, , 11]);
                        _a = call;
                        _b = [client];
                        return [4 /*yield*/, this.getAsyncCallContext(client)];
                    case 2: return [4 /*yield*/, _a.apply(void 0, _b.concat([_e.sent()]))];
                    case 3:
                        result = _e.sent();
                        return [3 /*break*/, 11];
                    case 4:
                        err_1 = _e.sent();
                        if (!isNotAuthenticated(err_1)) {
                            throw err_1;
                        }
                        _e.label = 5;
                    case 5:
                        _e.trys.push([5, 9, , 10]);
                        return [4 /*yield*/, this.triggerAuthentication(true, client)];
                    case 6:
                        _e.sent();
                        _c = call;
                        _d = [client];
                        return [4 /*yield*/, this.getAsyncCallContext(client)];
                    case 7: return [4 /*yield*/, _c.apply(void 0, _d.concat([_e.sent()]))];
                    case 8:
                        result = _e.sent();
                        return [3 /*break*/, 10];
                    case 9:
                        err_2 = _e.sent();
                        if (!isNotAuthenticated(err_2)) {
                            throw err_2;
                        }
                        throw new NotAuthenticated("Current session is not authenticated.", err_2);
                    case 10: return [3 /*break*/, 11];
                    case 11: return [2 /*return*/, result];
                }
            });
        }); };
        this.triggerAuthentication = function (reset, useClient) {
            if (reset === void 0) { reset = false; }
            if (!_this.authProvider) {
                return Promise.reject(new NotAuthenticated("Backend is not set up with authentication provider."));
            }
            if (reset) {
                _this.authProvider.reset();
            }
            return _this.authProvider.authenticate(_this.getAuthenticationContext(useClient));
        };
        this.getAsyncCallContext = function (client) { return __awaiter(_this, void 0, void 0, function () {
            var getPrincipal;
            var _this = this;
            return __generator(this, function (_a) {
                getPrincipal = function () { return __awaiter(_this, void 0, void 0, function () {
                    var principal;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!this.authProvider) {
                                    throw new NotAuthenticated("Cannot obtain principal without an authProvider.");
                                }
                                return [4 /*yield*/, this.authProvider.getCurrentPrincipal({ client: client, backend: this })];
                            case 1:
                                principal = _a.sent();
                                if (principal) {
                                    return [2 /*return*/, principal];
                                }
                                return [2 /*return*/, this.authProvider.authenticate(this.getAuthenticationContext(client))];
                        }
                    });
                }); };
                return [2 /*return*/, {
                        getPrincipal: getPrincipal,
                    }];
            });
        }); };
        this.config = config;
        this.capabilities = {};
        this.authProvider = authProvider || new AnonymousAuthProvider();
    }
    return CustomBackend;
}());
export { CustomBackend };
//
//
//
/**
 * Creates an instance of backend which uses custom functions to calculate results. See {@link CustomBackendConfig}
 * to learn more on what and how should be customized.
 *
 * ---
 *
 * Authentication is handled according to the specification described in the IAnalyticalBackend SPI. The custom backend
 * can be set up with authentication provider which will realize the desired authentication mechanism.
 *
 * Unless explicitly told via forced authentication (see {@link IAnalyticalBackend#authenticate}), the custom backend
 * will defer authentication until it is actually needed. In order for the custom backend to recognize that authentication
 * is needed, the different providers must throw the `NotAuthenticated` error.
 *
 * @beta
 */
export function customBackend(config) {
    return new CustomBackend(config);
}
//# sourceMappingURL=index.js.map