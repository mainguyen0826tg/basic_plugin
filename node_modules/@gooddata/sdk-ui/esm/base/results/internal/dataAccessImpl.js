// (C) 2019-2020 GoodData Corporation
import { isResultTotalHeader, resultHeaderName, } from "@gooddata/sdk-backend-spi";
import { createDataAccessDigest } from "./dataAccessDigest";
import { LazyInitArray } from "./lazyInitArray";
import invariant, { InvariantError } from "ts-invariant";
import { measureFormat, measureName } from "./utils";
import partial from "lodash/partial";
import isArray from "lodash/isArray";
/**
 * Iterates over single-dimensional result and returns values as data points.
 */
var SingleDimIterator = /** @class */ (function () {
    function SingleDimIterator(seriesIdx, accessors, config) {
        var _this = this;
        this.seriesIdx = seriesIdx;
        this.accessors = accessors;
        this.config = config;
        this.next = function () {
            if (_this.returned) {
                return {
                    done: true,
                    value: undefined,
                };
            }
            /*
             * Set series and slices indexes accordingly. If iterator is over series, then base
             * is index of series and offset is index of slice. Similar for slice..
             */
            var _a = _this.accessors.dataAt(_this.seriesIdx), rawValue = _a.rawValue, coordinates = _a.coordinates;
            var valueFormatter = _this.config.valueFormatter;
            var seriesDesc = _this.accessors.seriesDescriptors(_this.seriesIdx);
            var measureFormat = seriesDesc.measureFormat();
            _this.returned = true;
            return {
                done: false,
                value: {
                    rawValue: rawValue,
                    seriesDesc: seriesDesc,
                    coordinates: coordinates,
                    total: false,
                    formattedValue: function () {
                        return valueFormatter(rawValue, measureFormat);
                    },
                },
            };
        };
        this.returned = false;
    }
    return SingleDimIterator;
}());
/**
 * Iterates over two-dimensional data and returns values as data points.
 */
var TwoDimIterator = /** @class */ (function () {
    function TwoDimIterator(type, baseIdx, digest, accessors, config) {
        var _this = this;
        this.type = type;
        this.baseIdx = baseIdx;
        this.digest = digest;
        this.accessors = accessors;
        this.config = config;
        this.next = function () {
            if (_this.offset >= _this.offsetEnd) {
                return {
                    done: true,
                    value: undefined,
                };
            }
            /*
             * Set series and slices indexes accordingly. If iterator is over series, then base
             * is index of series and offset is index of slice. Similar for type "slice".
             */
            var seriesIdx = _this.type === "series" ? _this.baseIdx : _this.offset;
            var sliceIdx = _this.type === "slice" ? _this.baseIdx : _this.offset;
            var _a = _this.accessors.dataAt(_this.baseIdx, _this.offset), rawValue = _a.rawValue, coordinates = _a.coordinates;
            var valueFormatter = _this.config.valueFormatter;
            var seriesDesc = _this.accessors.seriesDescriptors(seriesIdx);
            var sliceDesc = _this.accessors.sliceDescriptors(sliceIdx);
            var measureFormat = seriesDesc.measureFormat();
            _this.offset += 1;
            return {
                done: false,
                value: {
                    rawValue: rawValue,
                    seriesDesc: seriesDesc,
                    sliceDesc: sliceDesc,
                    coordinates: coordinates,
                    total: sliceDesc.isTotal,
                    formattedValue: function () {
                        return valueFormatter(rawValue, measureFormat);
                    },
                },
            };
        };
        this.offset = 0;
        if (this.type === "series") {
            this.offsetEnd = this.digest.slices.count;
        }
        else {
            this.offsetEnd = this.digest.series.count;
        }
    }
    return TwoDimIterator;
}());
var DataSeries = /** @class */ (function () {
    function DataSeries(seriesIdx, digest, accessors, config) {
        var _this = this;
        this.seriesIdx = seriesIdx;
        this.digest = digest;
        this.accessors = accessors;
        this.config = config;
        this.measureFormat = function () {
            return _this.descriptor.measureFormat();
        };
        this.measureTitle = function () {
            return _this.descriptor.measureTitle();
        };
        this.scopeTitles = function () {
            return _this.descriptor.scopeTitles();
        };
        this.rawData = function () {
            if (!_this.rawDataValues) {
                _this.rawDataValues = _this.accessors.rawData(_this.seriesIdx);
            }
            return _this.rawDataValues;
        };
        this.dataPoints = function () {
            if (!_this.dataPointsArray) {
                _this.dataPointsArray = Array.from(_this);
            }
            return _this.dataPointsArray;
        };
        this[Symbol.iterator] = function () {
            var slices = _this.digest.slices;
            /*
             * Note here: code accounts for two invariants:
             *
             * 1. truly a single-dim result - data is array of values
             * 2. weird single-dim result - the slices dimension is empty, contains no attributes to slice by. in that case
             *    the data view is an array-in-array. the result is essentially single-dimensional however is wrapped
             *    in another array. the dataAt accessor impl can handle this
             */
            if (slices === undefined || (slices.dimIdx >= 0 && slices.count === 0)) {
                return new SingleDimIterator(_this.seriesIdx, _this.accessors, _this.config);
            }
            return new TwoDimIterator("series", _this.seriesIdx, _this.digest, _this.accessors, _this.config);
        };
        this.descriptor = this.accessors.seriesDescriptors(this.seriesIdx);
        this.id = this.descriptor.id;
    }
    return DataSeries;
}());
var DataSlice = /** @class */ (function () {
    function DataSlice(sliceIdx, digest, accessors, config) {
        var _this = this;
        this.sliceIdx = sliceIdx;
        this.digest = digest;
        this.accessors = accessors;
        this.config = config;
        this.sliceTitles = function () {
            return _this.descriptor.sliceTitles();
        };
        this.rawData = function () {
            if (!_this.rawDataValues) {
                _this.rawDataValues = _this.accessors.rawData(_this.sliceIdx);
            }
            return _this.rawDataValues;
        };
        // eslint-disable-next-line sonarjs/no-identical-functions
        this.dataPoints = function () {
            if (!_this.dataPointsArray) {
                _this.dataPointsArray = Array.from(_this);
            }
            return _this.dataPointsArray;
        };
        this[Symbol.iterator] = function () {
            if (!_this.digest.series) {
                /*
                 * If there are no data series, there are no measures and therefore there
                 * are no data points to iterate over.
                 */
                return [][Symbol.iterator]();
            }
            return new TwoDimIterator("slice", _this.sliceIdx, _this.digest, _this.accessors, _this.config);
        };
        this.descriptor = this.accessors.sliceDescriptors(this.sliceIdx);
        this.id = this.descriptor.id;
    }
    return DataSlice;
}());
function illegalState(message) {
    return function () {
        throw new InvariantError(message);
    };
}
/**
 * This class holds the underlying implementation of data access methods. The code is designed to follow
 * lazy initialization principles. The various data structures (slices, series, their descriptors etc) are
 * only created when needed.
 *
 * The responsibilities of this class is to operate on top of digest & data stored in the data view and
 * from information therein create descriptors for series, slices and then series and slices itself. It also
 * makes access to underlying data transparent - hiding the detail whether series and slices have their
 * data organized in row->col or col->row.
 */
var DataAccessImpl = /** @class */ (function () {
    function DataAccessImpl(dataView, config) {
        var _this = this;
        var _a, _b;
        this.getDataAccessPointers = function () {
            return _this.digest;
        };
        this.getDataSeriesIterator = function () {
            return _this.series[Symbol.iterator]();
        };
        this.getDataSlicesIterator = function () {
            return _this.slices[Symbol.iterator]();
        };
        this.getDataSeries = function (idx) {
            return _this.series.get(idx);
        };
        this.findDataSeriesIndexes = function (localId) {
            var seriesDigest = _this.digest.series;
            if (!seriesDigest) {
                return [];
            }
            return seriesDigest.measureIndexes[localId] || [];
        };
        this.getRawData = function (fromDimIdx, idx) {
            if (fromDimIdx === 1) {
                /*
                 * Need to extract data from particular columns of two-dim data. Go through all rows, from
                 * each row take value at the desired column's index.
                 */
                return _this.dataView.data.map(function (row) {
                    return row[idx];
                });
            }
            else {
                /*
                 * Either extracting row from two-dim result or extracting single value from one-dim result
                 */
                var value = _this.dataView.data[idx];
                if (isArray(value)) {
                    /*
                     * Two-dim result, return as-is
                     */
                    return value;
                }
                else {
                    /*
                     * Single-dim result, return wrapped
                     */
                    return [value];
                }
            }
        };
        this.getDataAt = function (fromDimIdx, idx, seq) {
            if (seq === void 0) { seq = 0; }
            if (fromDimIdx === 1) {
                /*
                 * Want data from column. Get `idx` column value in of `seq` row
                 */
                var twoDimData = _this.dataView.data;
                return { rawValue: twoDimData[seq][idx], coordinates: [seq, idx] };
            }
            else {
                var value = _this.dataView.data[idx];
                if (isArray(value)) {
                    return { rawValue: value[seq], coordinates: [idx, seq] };
                }
                else {
                    invariant(seq === 0, "trying to get row-col from single dim result");
                    return { rawValue: value, coordinates: [idx] };
                }
            }
        };
        this.createDataSeriesDescriptor = function (seriesIdx) {
            var seriesDigest = _this.digest.series;
            invariant(seriesDigest, "trying to create data series descriptor when there are no data series");
            var fromMeasures = seriesDigest.fromMeasures, fromMeasuresDef = seriesDigest.fromMeasuresDef, measureHeaders = seriesDigest.measureHeaders, allAttributeHeaders = seriesDigest.allAttributeHeaders, scopingAttributes = seriesDigest.scopingAttributes, scopingAttributesDef = seriesDigest.scopingAttributesDef;
            var measureHeader = measureHeaders[seriesIdx];
            var attributeHeaders = allAttributeHeaders.map(function (headers) { return headers[seriesIdx]; });
            var measureDescriptor = fromMeasures[measureHeader.measureHeaderItem.order];
            var measureDefinition = fromMeasuresDef[measureHeader.measureHeaderItem.order];
            var headerTranslator = _this.config.headerTranslator;
            return {
                id: "" + seriesIdx,
                measureDescriptor: measureDescriptor,
                measureDefinition: measureDefinition,
                attributeDescriptors: scopingAttributes,
                attributeDefinitions: scopingAttributesDef,
                measureHeader: measureHeader,
                attributeHeaders: attributeHeaders,
                measureFormat: function () {
                    return measureFormat(measureDescriptor);
                },
                measureTitle: function () {
                    return measureName(measureDescriptor);
                },
                scopeTitles: function () {
                    if (!headerTranslator) {
                        return attributeHeaders.map(resultHeaderName);
                    }
                    return attributeHeaders.map(function (h) { return headerTranslator(resultHeaderName(h)); });
                },
            };
        };
        this.createDataSliceDescriptor = function (sliceIdx) {
            var slicesDigest = _this.digest.slices;
            invariant(slicesDigest, "trying to create data slice descriptor when there are no data slices");
            var descriptors = slicesDigest.descriptors, headerItems = slicesDigest.headerItems, descriptorsDef = slicesDigest.descriptorsDef;
            var headers = [];
            var headerTranslator = _this.config.headerTranslator;
            var total = false;
            headerItems.forEach(function (h) {
                var header = h[sliceIdx];
                headers.push(header);
                if (isResultTotalHeader(header)) {
                    total = true;
                }
            });
            return {
                id: "" + sliceIdx,
                descriptors: descriptors,
                definitions: descriptorsDef,
                headers: headers,
                isTotal: total,
                sliceTitles: function () {
                    if (!headerTranslator) {
                        return headers.map(resultHeaderName);
                    }
                    return headers.map(function (h) { return headerTranslator(resultHeaderName(h)); });
                },
            };
        };
        this.createDataSeries = function (seriesIdx) {
            return new DataSeries(seriesIdx, _this.digest, _this.accessors[0], _this.config);
        };
        this.createDataSlice = function (sliceIdx) {
            return new DataSlice(sliceIdx, _this.digest, _this.accessors[1], _this.config);
        };
        this.dataView = dataView;
        this.config = config;
        this.digest = createDataAccessDigest(this.dataView);
        var _c = this.digest, series = _c.series, slices = _c.slices;
        var seriesCount = (_a = series === null || series === void 0 ? void 0 : series.count) !== null && _a !== void 0 ? _a : 0;
        var slicesCount = (_b = slices === null || slices === void 0 ? void 0 : slices.count) !== null && _b !== void 0 ? _b : 0;
        this.seriesDescriptors = new LazyInitArray(seriesCount, this.createDataSeriesDescriptor);
        this.series = new LazyInitArray(seriesCount, this.createDataSeries);
        this.slicesDescriptors = new LazyInitArray(slicesCount, this.createDataSliceDescriptor);
        this.slices = new LazyInitArray(slicesCount, this.createDataSlice);
        this.accessors = [
            {
                rawData: series
                    ? partial(this.getRawData, series.dimIdx)
                    : illegalState("there are no data series"),
                dataAt: series
                    ? partial(this.getDataAt, series.dimIdx)
                    : illegalState("there are no data series"),
                seriesDescriptors: this.seriesDescriptors.get,
                sliceDescriptors: this.slicesDescriptors.get,
            },
            {
                rawData: slices
                    ? partial(this.getRawData, slices.dimIdx)
                    : illegalState("there are no data slices"),
                dataAt: slices
                    ? partial(this.getDataAt, slices.dimIdx)
                    : illegalState("there are no data slices"),
                seriesDescriptors: this.seriesDescriptors.get,
                sliceDescriptors: this.slicesDescriptors.get,
            },
        ];
    }
    return DataAccessImpl;
}());
export { DataAccessImpl };
//# sourceMappingURL=dataAccessImpl.js.map