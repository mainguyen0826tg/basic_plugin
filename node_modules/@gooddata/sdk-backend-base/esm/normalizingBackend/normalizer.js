import { __assign, __spreadArrays } from "tslib";
// (C) 2007-2020 GoodData Corporation
import { attributeAlias, attributeLocalId, filterIsEmpty, isArithmeticMeasureDefinition, isAttributeLocator, isAttributeSort, isLocalIdRef, isMeasureSort, isMeasureValueFilter, isNegativeAttributeFilter, isPoPMeasureDefinition, isPreviousPeriodMeasureDefinition, measureAlias, measureFormat, MeasureGroupIdentifier, measureLocalId, measureTitle, measureValueFilterCondition, modifyAttribute, modifyMeasure, isAttributeFilter, isRankingFilter, } from "@gooddata/sdk-model";
import { isAttributeDescriptor, isMeasureDescriptor, isResultMeasureHeader, } from "@gooddata/sdk-backend-spi";
import invariant from "ts-invariant";
import cloneDeep from "lodash/cloneDeep";
import cloneDeepWith from "lodash/cloneDeepWith";
import keyBy from "lodash/keyBy";
/**
 * @internal
 */
var Denormalizer = /** @class */ (function () {
    function Denormalizer(state) {
        var _this = this;
        this.state = state;
        /**
         * Given the current normalization state, this method transforms the dimension descriptors of the
         * normalized execution, so that all the customization of the original execution definition is restored
         * into them:
         *
         * -  Reverse lookup of local identifiers happens
         * -  Attribute / Measure name is set according to the defined alias
         * -  Measure format is set according to the format in definition
         *
         * @param normalizedDims - normalized dimension descriptors
         * @returns new descriptors
         */
        this.denormalizeDimDescriptors = function (normalizedDims) {
            return cloneDeepWith(normalizedDims, function (value) {
                if (isAttributeDescriptor(value)) {
                    var localIdentifier = _this.originalLocalId(value.attributeHeader.localIdentifier);
                    var attribute = _this.originalAttributes[localIdentifier];
                    var name_1 = attributeAlias(attribute) || value.attributeHeader.formOf.name;
                    return {
                        attributeHeader: __assign(__assign({}, value.attributeHeader), { localIdentifier: localIdentifier, formOf: __assign(__assign({}, value.attributeHeader.formOf), { name: name_1 }) }),
                    };
                }
                else if (isMeasureDescriptor(value)) {
                    var localIdentifier = _this.originalLocalId(value.measureHeaderItem.localIdentifier);
                    var measure = _this.originalMeasures[localIdentifier];
                    var format = measureFormat(measure) || value.measureHeaderItem.format;
                    var name_2 = _this.originalMeasureTitle(measure, value.measureHeaderItem.name);
                    return {
                        measureHeaderItem: __assign(__assign({}, value.measureHeaderItem), { localIdentifier: localIdentifier,
                            format: format,
                            name: name_2 }),
                    };
                }
                // let the default logic handle this
                return undefined;
            });
        };
        /**
         * Derived measures or arithmetic measures have the 'name' in result header defaulted to measure
         * localId. This method deals with it. It creates a copy of headers with the measure headers denormalized,
         * values replaced with the contents of alias or title (whichever comes first).
         *
         * @param headerItems - headers to denormalize, copy will be done
         * @returns new headers
         */
        this.denormalizeHeaders = function (headerItems) {
            return cloneDeepWith(headerItems, function (value) {
                if (isResultMeasureHeader(value)) {
                    return {
                        measureHeaderItem: {
                            name: _this.fillOriginalMeasureTitle(value.measureHeaderItem.name),
                            order: value.measureHeaderItem.order,
                        },
                    };
                }
                // let the default logic handle this
                return undefined;
            });
        };
        this.originalLocalId = function (normalized) {
            var value = _this.state.n2oMap[normalized];
            invariant(value, "mapping from normalized to real localId does not exist. Normalized: " + normalized);
            return value;
        };
        this.fillOriginalMeasureTitle = function (name) {
            var originalLocalId = _this.state.n2oMap[name];
            if (!originalLocalId) {
                return name;
            }
            var measure = _this.originalMeasures[originalLocalId];
            if (!measure) {
                return name;
            }
            return _this.originalMeasureTitle(measure, name);
        };
        this.originalMeasureTitle = function (originalDef, nameFromBackend) {
            return measureAlias(originalDef) || measureTitle(originalDef) || nameFromBackend;
        };
        this.originalAttributes = keyBy(state.original.attributes, attributeLocalId);
        this.originalMeasures = keyBy(state.original.measures, measureLocalId);
    }
    Denormalizer.from = function (state) {
        return new Denormalizer(state);
    };
    return Denormalizer;
}());
export { Denormalizer };
/**
 * The normalization of execution definition means stripping away all the detail that is unnecessary for the
 * backend:
 *
 * -  attribute / measure alias
 * -  measure title
 * -  measure format
 * -  custom-crafted local IDs
 *
 * The code does the job by _mutating_ a clone of the original definition. The mutation approach, while not
 * backed by functionality in sdk-model and therefore somewhat hacky, is a simpler one for this task.
 *
 * The main reason behind that is the occurrence of attribute and measure objects in multiple parts of the
 * execution definition: same attributes and measures are referenced from both buckets and the attributes and measures
 * props of the execution definition. Mutating values means that after normalizing values the execution definition
 * is fully normalized.
 *
 * @internal
 */
var Normalizer = /** @class */ (function () {
    function Normalizer(original) {
        var _this = this;
        this.original = original;
        /**
         * original to normalized local id map
         */
        this.o2nMap = {};
        /**
         * normalized to original local id map
         */
        this.n2oMap = {};
        this.originalMeasures = new Map();
        this.alreadyNormalized = [];
        /**
         * Creates a new mapping between original local ID and the proposed normalized local ID. This method
         * ensures uniqueness of the normalized local ID. If the proposed normalized local ID is taken, it will
         * append a suffix to make a unique local ID.
         *
         * This can happen if the original execution definition contains same measure / attribute multiple times,
         * each time using different local ID.
         */
        this.createUniqueMapping = function (original, normalized) {
            invariant(!_this.o2nMap[original], "duplicate localId used in execution definition: " + original);
            var uniqueNormalized = normalized;
            var attempt = 1;
            while (_this.n2oMap[uniqueNormalized]) {
                uniqueNormalized = normalized + "_" + attempt;
                attempt += 1;
            }
            _this.o2nMap[original] = uniqueNormalized;
            _this.n2oMap[uniqueNormalized] = original;
            return uniqueNormalized;
        };
        this.normalizedLocalId = function (original) {
            var value = _this.o2nMap[original];
            invariant(value, "dangling localId reference. Target: " + original);
            return value;
        };
        this.maybeNormalizedLocalId = function (original) {
            return _this.o2nMap[original];
        };
        this.normalizeAttributes = function () {
            _this.normalized.attributes.forEach(function (attr) {
                delete attr.attribute.alias;
                var originalLocalId = attributeLocalId(attr);
                var normalizedLocalId = attributeLocalId(modifyAttribute(attr, function (m) { return m.defaultLocalId(); }));
                attr.attribute.localIdentifier = _this.createUniqueMapping(originalLocalId, normalizedLocalId);
            });
        };
        /**
         * Simple measure normalization will toss away noop filters. There is nothing else to do.
         */
        this.normalizeSimple = function (def) {
            var _a;
            if (!def.measureDefinition.filters) {
                return;
            }
            def.measureDefinition.filters = (_a = def.measureDefinition.filters) === null || _a === void 0 ? void 0 : _a.filter(function (filter) {
                return !isNegativeAttributeFilter(filter) || !filterIsEmpty(filter);
            });
        };
        this.normalizePoP = function (def, path) {
            var masterMeasure = def.popMeasureDefinition.measureIdentifier;
            var normalizedId = _this.maybeNormalizedLocalId(masterMeasure) || _this.normalizeMeasureByLocalId(masterMeasure, path);
            def.popMeasureDefinition.measureIdentifier = normalizedId;
        };
        this.normalizePreviousPeriod = function (def, path) {
            var masterMeasure = def.previousPeriodMeasure.measureIdentifier;
            var normalizedId = _this.maybeNormalizedLocalId(masterMeasure) || _this.normalizeMeasureByLocalId(masterMeasure, path);
            def.previousPeriodMeasure.measureIdentifier = normalizedId;
        };
        this.normalizeArithmetic = function (def, path) {
            var normalizedIds = def.arithmeticMeasure.measureIdentifiers.map(function (operand) {
                return _this.maybeNormalizedLocalId(operand) || _this.normalizeMeasureByLocalId(operand, path);
            });
            def.arithmeticMeasure.measureIdentifiers = normalizedIds;
        };
        this.normalizeMeasure = function (measure, path) {
            if (path === void 0) { path = new Set(); }
            var localId = measureLocalId(measure);
            var definition = measure.measure.definition;
            /*
             * don't do anything if the measure is already normalized;
             *
             * this can happen as master / derived / arithmetic measures can be mixed in the measures array
             * in any order & the recursive algorithm goes after the leaves first and then gets to the measure
             * once again as it walks the array
             */
            if (_this.alreadyNormalized.find(function (m) { return m === measure; })) {
                // if already normalized, the measure has been mutated and the localId is the normalized one
                return localId;
            }
            /*
             * circular dependency detection and bail-out.
             */
            invariant(!path.has(localId), "circular dependency on measure with localId " + localId);
            path.add(localId);
            if (isPoPMeasureDefinition(definition)) {
                _this.normalizePoP(definition, path);
            }
            else if (isPreviousPeriodMeasureDefinition(definition)) {
                _this.normalizePreviousPeriod(definition, path);
            }
            else if (isArithmeticMeasureDefinition(definition)) {
                _this.normalizeArithmetic(definition, path);
            }
            else {
                _this.normalizeSimple(definition);
            }
            delete measure.measure.alias;
            delete measure.measure.title;
            delete measure.measure.format;
            var newLocalId = measureLocalId(modifyMeasure(measure, function (m) { return m.defaultLocalId(); }));
            var newUniqueLocalId = _this.createUniqueMapping(localId, newLocalId);
            measure.measure.localIdentifier = newUniqueLocalId;
            _this.alreadyNormalized.push(measure);
            return newUniqueLocalId;
        };
        this.normalizeMeasureByLocalId = function (localId, path) {
            var measure = _this.originalMeasures.get(localId);
            invariant(measure, "measure with localId " + localId + " could not be found");
            return _this.normalizeMeasure(measure, path);
        };
        this.normalizeMeasures = function () {
            _this.normalized.measures.forEach(function (measure) { return _this.normalizeMeasure(measure); });
        };
        this.normalizeFilters = function () {
            _this.normalized.filters.forEach(function (filter) {
                if (isMeasureValueFilter(filter)) {
                    var ref = filter.measureValueFilter.measure;
                    if (isLocalIdRef(ref)) {
                        ref.localIdentifier = _this.normalizedLocalId(ref.localIdentifier);
                    }
                }
                if (isRankingFilter(filter)) {
                    var _a = filter.rankingFilter, measure = _a.measure, _b = _a.attributes, attributes = _b === void 0 ? [] : _b;
                    __spreadArrays(attributes, [measure]).filter(isLocalIdRef).forEach(function (ref) {
                        ref.localIdentifier = _this.normalizedLocalId(ref.localIdentifier);
                    });
                }
            });
        };
        this.normalizeSorts = function () {
            _this.normalized.sortBy.forEach(function (sort) {
                if (isAttributeSort(sort)) {
                    sort.attributeSortItem.attributeIdentifier = _this.normalizedLocalId(sort.attributeSortItem.attributeIdentifier);
                }
                else if (isMeasureSort(sort)) {
                    sort.measureSortItem.locators.forEach(function (locator) {
                        if (isAttributeLocator(locator)) {
                            locator.attributeLocatorItem.attributeIdentifier = _this.normalizedLocalId(locator.attributeLocatorItem.attributeIdentifier);
                        }
                        else {
                            locator.measureLocatorItem.measureIdentifier = _this.normalizedLocalId(locator.measureLocatorItem.measureIdentifier);
                        }
                    });
                }
            });
        };
        this.normalizeDimensions = function () {
            _this.normalized.dimensions.forEach(function (dim) {
                dim.itemIdentifiers = dim.itemIdentifiers.map(function (item) {
                    if (item === MeasureGroupIdentifier) {
                        return item;
                    }
                    else {
                        return _this.normalizedLocalId(item);
                    }
                });
                if (dim.totals) {
                    dim.totals.forEach(function (total) {
                        total.attributeIdentifier = _this.normalizedLocalId(total.attributeIdentifier);
                        total.measureIdentifier = _this.normalizedLocalId(total.measureIdentifier);
                    });
                }
            });
        };
        this.normalize = function () {
            _this.normalizeAttributes();
            _this.normalizeMeasures();
            _this.normalizeFilters();
            _this.normalizeSorts();
            _this.normalizeDimensions();
            return {
                normalized: _this.normalized,
                original: _this.original,
                n2oMap: _this.n2oMap,
            };
        };
        var copy = cloneDeep(this.original);
        // throw away noop filters
        var filters = copy.filters.filter(function (f) {
            if (isAttributeFilter(f)) {
                return !filterIsEmpty(f);
            }
            else if (isMeasureValueFilter(f)) {
                return measureValueFilterCondition(f) !== undefined;
            }
            return true;
        });
        this.normalized = __assign(__assign({}, copy), { filters: filters });
        copy.measures.forEach(function (measure) { return _this.originalMeasures.set(measureLocalId(measure), measure); });
    }
    Normalizer.normalize = function (def) {
        var n = new Normalizer(def);
        return n.normalize();
    };
    return Normalizer;
}());
export { Normalizer };
//# sourceMappingURL=normalizer.js.map