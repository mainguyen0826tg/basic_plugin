// (C) 2021 GoodData Corporation
import { isScopeCol, isSeriesCol, isSliceCol, isRootCol, agColId, isEmptyScopeCol, } from "./tableDescriptorTypes";
import invariant from "ts-invariant";
import { searchForLocatorMatch } from "./colLocatorMatching";
import { createHeadersAndColDefs } from "./tableDescriptorFactory";
import { createSortIndicators } from "./tableDescriptorSorting";
import { createSortItemForCol } from "./colSortItemFactory";
import keyBy from "lodash/keyBy";
import findIndex from "lodash/findIndex";
/**
 * Table Descriptor is the entry point to all table structure data and metadata. It contains exhaustive information
 * about all table columns (column descriptors) and their respective ag-grid column definitions.
 *
 * On top of this data and metadata, the table descriptor provides convenience and added value methods.
 *
 * Column Descriptors vs ag-grid ColDefs | ColGroupDefs
 * ----------------------------------------------------
 *
 * Column Descriptors (shortened to `Col` for sakes of brevity) are our implementation-specific descriptors for
 * the table columns and their grouping into column groups. They contain all the essential GD-specific metadata about
 * the content of the respective table column (attribute descriptors, headers, measure descriptors) and additional
 * structural information.
 *
 * The ag-grid ColDefs and ColGroupDefs are (naturally) used to construct the ag-grid table :) They are built to
 * reflect the column descriptors but only contain the information needed by ag-grid itself.
 *
 * The important thing to remember is that ColDefs and ColGroupDefs have same colId/groupId as their column descriptor
 * counterparts.
 *
 * @alpha
 */
var TableDescriptor = /** @class */ (function () {
    function TableDescriptor(dv, headers, colDefs) {
        this.dv = dv;
        this.headers = headers;
        this.colDefs = colDefs;
        /**
         * This field contains slice column descriptors zipped with their respective ColDef that should
         * be used for ag-grid.
         */
        this.zippedSliceCols = [];
        /**
         * This field contains descriptors of leaf columns zipped with their respective ColDef that should
         * be used for ag-grid.
         */
        this.zippedLeaves = [];
        this._initializeZippedLeaves();
        this._initializeZippedSliceCols();
        this._seriesColsCount = headers.leafDataCols.filter(isSeriesCol).length;
    }
    /**
     * Creates a new table descriptor from the provided data view facade.
     *
     * @param dv - data view facade
     */
    TableDescriptor.for = function (dv) {
        var _a = createHeadersAndColDefs(dv), headers = _a.headers, colDefs = _a.colDefs;
        invariant(headers.leafDataCols.length === colDefs.leafDataColDefs.length);
        return new TableDescriptor(dv, headers, colDefs);
    };
    TableDescriptor.prototype._initializeZippedLeaves = function () {
        var _this = this;
        this.headers.leafDataCols.forEach(function (col, idx) {
            _this.zippedLeaves.push([col, _this.colDefs.leafDataColDefs[idx]]);
        });
    };
    TableDescriptor.prototype._initializeZippedSliceCols = function () {
        var _this = this;
        this.headers.sliceCols.forEach(function (col, idx) {
            _this.zippedSliceCols.push([col, _this.colDefs.sliceColDefs[idx]]);
        });
    };
    /**
     * Gets column descriptor for column with the provided ID. This method will raise error if there is no such
     * col: this is to draw out possible errors in the rest of table code that uses the cols and ColDefs.
     *
     * @param c - column id, Column, ColDef or ColGroupDef from ag-grid
     */
    TableDescriptor.prototype.getCol = function (c) {
        invariant(c, "id of column or Column, ColDef or ColGroupDef must be provided");
        var id = agColId(c);
        var result = this.headers.idToDescriptor[id];
        invariant(result, "no column with id " + id);
        return result;
    };
    /**
     * Gets ColDef or ColGroupDef for column with the provided ID. This method will raise error if there is no such
     * col: this is to draw out possible errors in the rest of table code that uses the cols and ColDefs.
     *
     * @param c - column id, Column, ColDef or ColGroupDef from ag-grid
     */
    TableDescriptor.prototype.getColDef = function (c) {
        invariant(c, "id of column or Column, ColDef or ColGroupDef must be provided");
        var id = agColId(c);
        var result = this.colDefs.idToColDef[id];
        invariant(result, "no column with id " + id);
        return result;
    };
    /**
     * Gets descriptors of all attributes that are used to slice the table into rows. Note that it is perfectly
     * OK that table has no slicing attributes.
     *
     * @returns empty if there are no slicing attributes
     */
    TableDescriptor.prototype.getSlicingAttributes = function () {
        return this.headers.sliceCols.map(function (col) { return col.attributeDescriptor; });
    };
    /**
     *
     */
    TableDescriptor.prototype.sliceColCount = function () {
        return this.headers.sliceCols.length;
    };
    /**
     * Gets all descriptors of all measures that were used to compute data values for this table. Note that it is
     * perfectly OK that table has no measures. If the table has slicing attributes, then it will be listing out
     * all available attribute values.
     *
     * Also note that table MAY have more data leaf columns than there are number of measures. If the measures
     * are further scoped for values of some attribute's elements, then there will be one series col for each combination
     * of measure X attribute element.
     *
     * @returns empty if there are no measures
     */
    TableDescriptor.prototype.getMeasures = function () {
        return this.dv.meta().measureDescriptors();
    };
    /**
     * Returns count of leaf data cols. This represents the actual width of the data sheet holding the computed metric
     * values.
     */
    TableDescriptor.prototype.seriesColsCount = function () {
        return this._seriesColsCount;
    };
    /**
     * Tests whether the column with the provided id is the first (e.g. left-most) column in the table. Table with
     * slicing attributes has first col a SliceCol. Table without slicing attributes starts with either SeriesCol or
     * with ScopeCol (in case table does not contain measures)
     *
     * @param c - column id, Column, ColDef or ColGroupDef from ag-grid
     */
    TableDescriptor.prototype.isFirstCol = function (c) {
        invariant(c, "id of column or Column, ColDef or ColGroupDef must be provided");
        var id = agColId(c);
        if (this.headers.sliceCols.length > 0) {
            return this.headers.sliceCols[0].id === id;
        }
        return this.isFirstDataCol(id);
    };
    /**
     * Tests whether the column with the provided id is the first (e.g. left-most) column of the data sheet part of the table.
     *
     * Note that for table that uses column groups, there will be multiple first columns: the grouping root and recursively
     * its first children down to the first leaf col..
     *
     * @param c - column id, Column, ColDef or ColGroupDef from ag-grid
     */
    TableDescriptor.prototype.isFirstDataCol = function (c) {
        invariant(c, "id of column or Column, ColDef or ColGroupDef must be provided");
        var col = this.getCol(c);
        switch (col.type) {
            case "seriesCol":
            case "scopeCol": {
                return col.fullIndexPathToHere.every(function (idx) { return idx === 0; });
            }
            case "rootCol": {
                return true;
            }
            default: {
                return false;
            }
        }
    };
    /**
     * Tests whether the table has scoping cols. Scoping cols mean table's data cols are organizes into a tree hierarchy.
     */
    TableDescriptor.prototype.hasScopingCols = function () {
        var firstRoot = this.headers.rootDataCols[0];
        return firstRoot && (isScopeCol(firstRoot) || isRootCol(firstRoot));
    };
    /**
     * Tests whether the table has any leaf data cols - in other words whether there any computed data values to show
     * in the table. It is OK for table not to have any data leaf cols - it may be just a table with slicing cols listing
     * elements of an attribute.
     */
    TableDescriptor.prototype.hasDataLeafCols = function () {
        return this.headers.leafDataCols.length > 0;
    };
    /**
     * Given a column that may appear as a leaf of table headers this method returns its absolute index in the table.
     *
     * This takes into account that the table columns go from left-to-right, starting with slicing columns first then
     * followed by leaf data columns.
     *
     * @param col - column to get absolute index of
     */
    TableDescriptor.prototype.getAbsoluteLeafColIndex = function (col) {
        if (isSliceCol(col)) {
            return col.index;
        }
        else if (isScopeCol(col)) {
            // if this bombs, caller is not operating with the leaf columns correctly and sent over
            // a col that is not a leaf
            invariant(isEmptyScopeCol(col));
            return this.sliceColCount() + findIndex(this.headers.leafDataCols, function (leaf) { return leaf.id === col.id; });
        }
        return this.sliceColCount() + col.index;
    };
    /**
     * Attempts to match the provided attribute column width item to a SliceCol descriptor.
     *
     * @param columnWidthItem - item to match
     */
    TableDescriptor.prototype.matchAttributeWidthItem = function (columnWidthItem) {
        var matcher = attributeDescriptorLocalIdMatch(columnWidthItem.attributeColumnWidthItem.attributeIdentifier);
        return this.headers.sliceCols.find(function (col) { return matcher(col.attributeDescriptor); });
    };
    /**
     * Attempts to match the provided measure width item to a leaf data col. The locators in the item
     * will be used to traverse the column structure.
     *
     * @param measureWidthItem - item to match
     */
    TableDescriptor.prototype.matchMeasureWidthItem = function (measureWidthItem) {
        return searchForLocatorMatch(this.headers.rootDataCols, measureWidthItem.measureColumnWidthItem.locators);
    };
    /**
     * Tests whether the table can be enriched by totals. Tables that do not have any measures or do not have any
     * slicing attributes cannot have totals. Because by definition they either have exactly 1 row with all measure grant total
     * sum or have no rows whatsover.
     */
    TableDescriptor.prototype.canTableHaveTotals = function () {
        return this.sliceColCount() > 0 && this.seriesColsCount() > 0;
    };
    /**
     * Returns slice col against which grant totals can be defined. This is essentially the left-most slicing column.
     * This method will raise invariant error if there are no slicing cols. Rationale being that inclusion of grand
     * totals requires more checks anyway and calling this blindly does not make much sense.
     *
     * @remarks see {@link TableDescriptor.canTableHaveTotals}
     */
    TableDescriptor.prototype.getGrandTotalCol = function () {
        var result = this.headers.sliceCols[0];
        invariant(result);
        return result;
    };
    /**
     * Given a col, this function determines all slice cols that are effective up to and including
     * the col. In other words, it returns all slice cols 'to the left' of the provided col.
     *
     * Note: the col can be of any type. If a data col is provided, then by definition all slice cols are
     * effective. if col is a slice col, then slice cols from start up to and including the provided col
     * are returned.
     */
    TableDescriptor.prototype.getSliceColsUpToIncludingCol = function (col) {
        var allSliceCols = this.headers.sliceCols;
        if (!isSliceCol(col)) {
            return allSliceCols;
        }
        var colAt = findIndex(allSliceCols, function (slice) { return slice.id === col.id; });
        // if this happens, then caller has mismatch of descriptor and cols
        invariant(colAt > -1);
        return allSliceCols.slice(0, colAt + 1);
    };
    /**
     * Given ag-grid columns or coldefs and a list of initial sort items, this function will create
     * sort items that reflect current table sorting configuration. The sorting configuration is obtained from the
     * Column/ColDef `getSort`/`sort` property.
     *
     * Note: the initial sort items are passed to here to ensure that attribute area sort setting is reused
     * correctly when sort direction for the respective column changes.
     *
     * @param columns - ag-grid columns / coldefs to obtain sorting information from
     * @param originalSorts - original sorts
     */
    TableDescriptor.prototype.createSortItems = function (columns, originalSorts) {
        var _this = this;
        if (originalSorts === void 0) { originalSorts = []; }
        if (columns.length === 0) {
            return [];
        }
        var sortIndicators = createSortIndicators(columns);
        return sortIndicators.map(function (sortModelItem) {
            var colId = sortModelItem.colId, sort = sortModelItem.sort;
            var col = _this.getCol(colId);
            return createSortItemForCol(col, sort, originalSorts);
        });
    };
    /**
     * Updates effective totals for the slice cols using the new total descriptors included for their respective
     * attributes in the new data view facade.
     *
     * @param dv - data view with same attribute structure but with added totals
     */
    TableDescriptor.prototype.updateEffectiveTotals = function (dv) {
        var idToDescriptor = keyBy(dv.meta().attributeDescriptors(), function (desc) { return desc.attributeHeader.localIdentifier; });
        this.headers.sliceCols.forEach(function (sliceCol) { return updateEffectiveTotals(sliceCol, idToDescriptor); });
    };
    return TableDescriptor;
}());
export { TableDescriptor };
function attributeDescriptorLocalIdMatch(localId) {
    return function (b) {
        return localId === b.attributeHeader.localIdentifier;
    };
}
function updateEffectiveTotals(col, newDescriptors) {
    var _a;
    var attributeLocalId = col.attributeDescriptor.attributeHeader.localIdentifier;
    var newDescriptor = newDescriptors[attributeLocalId];
    // if this bombs then reinit logic of the entire pivot table is flawed because upon change of table structure is
    // re-initialized - which includes the table descriptor so the code should be getting to this place at all.
    invariant(newDescriptor, "attempting to refresh attribute descriptors for different table. attribute with local id " + attributeLocalId + " not found");
    col.effectiveTotals = (_a = newDescriptor.attributeHeader.totalItems) !== null && _a !== void 0 ? _a : [];
}
//# sourceMappingURL=tableDescriptor.js.map