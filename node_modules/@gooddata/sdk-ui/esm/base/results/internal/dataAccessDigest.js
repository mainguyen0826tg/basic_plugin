import { __read, __values } from "tslib";
// (C) 2019-2020 GoodData Corporation
import { isAttributeDescriptor, isMeasureGroupDescriptor, isResultAttributeHeader, isResultMeasureHeader, } from "@gooddata/sdk-backend-spi";
import { dataViewDimensionItems, dataViewHeaders, measureGroupItems } from "./utils";
import { attributeLocalId, measureLocalId } from "@gooddata/sdk-model";
import keyBy from "lodash/keyBy";
/**
 * Given data view dimensions, this function identifies dimensions where data series and
 * data slices are laid out. The returned result always contains two elements. First being
 * the index to data series dimension, second to data slices dimension. If series / slices
 * are not present, then the respective element contains -1.
 */
function findSlicesAndSeriesDims(dimensions) {
    var e_1, _a;
    if (dimensions.length === 0) {
        return {
            locations: [-1, -1],
        };
    }
    /*
     * possible valid locations of series and slices. rows and cols OR cols and rows.
     */
    var possibleLocations = [
        [0, 1],
        [1, 0],
    ];
    try {
        for (var possibleLocations_1 = __values(possibleLocations), possibleLocations_1_1 = possibleLocations_1.next(); !possibleLocations_1_1.done; possibleLocations_1_1 = possibleLocations_1.next()) {
            var locations = possibleLocations_1_1.value;
            var _b = __read(locations, 2), seriesIdx = _b[0], slicesIdx = _b[1];
            var dimension = dimensions[seriesIdx];
            if (!dimension) {
                continue;
            }
            var measureGroup = dimension.headers.find(isMeasureGroupDescriptor);
            if (measureGroup) {
                if (!dimensions[slicesIdx]) {
                    return {
                        locations: [seriesIdx, -1],
                        measureGroup: measureGroup,
                    };
                }
                return {
                    locations: locations,
                    measureGroup: measureGroup,
                };
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (possibleLocations_1_1 && !possibleLocations_1_1.done && (_a = possibleLocations_1.return)) _a.call(possibleLocations_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    /*
     * The only possibility at this point is there are no data series.
     */
    return {
        locations: [-1, 0],
    };
}
function createMeasureIndexes(measureDescriptors, measureHeaders) {
    var _a;
    var measureAndIndex = (_a = measureHeaders === null || measureHeaders === void 0 ? void 0 : measureHeaders.map(function (m, idx) {
        var measure = measureDescriptors[m.measureHeaderItem.order].measureHeaderItem.localIdentifier;
        return [measure, idx];
    })) !== null && _a !== void 0 ? _a : [];
    return measureAndIndex.reduce(function (res, _a) {
        var _b = __read(_a, 2), localId = _b[0], seriesIdx = _b[1];
        if (!res[localId]) {
            res[localId] = [];
        }
        res[localId].push(seriesIdx);
        return res;
    }, {});
}
function createDataSeriesDigest(dataView, resultDesc, def) {
    var _a, _b;
    var measureGroup = resultDesc.measureGroup, locations = resultDesc.locations;
    if (!measureGroup) {
        return;
    }
    var dimIdx = locations[0];
    var headerItems = dataViewHeaders(dataView, dimIdx);
    var measureHeaders = (_a = headerItems.find(function (headers) { return isResultMeasureHeader(headers[0]); })) !== null && _a !== void 0 ? _a : [];
    var allAttributeHeaders = (_b = headerItems.filter(function (headers) {
        return isResultAttributeHeader(headers[0]);
    })) !== null && _b !== void 0 ? _b : [];
    var count = measureHeaders ? measureHeaders.length : 0;
    var fromMeasures = measureGroupItems(measureGroup);
    var fromMeasuresDef = fromMeasures.map(function (m) { return def.measuresIndex[m.measureHeaderItem.localIdentifier]; });
    var scopingAttributes = dataViewDimensionItems(dataView, dimIdx).filter(isAttributeDescriptor);
    var scopingAttributesDef = scopingAttributes.map(function (a) { return def.attributesIndex[a.attributeHeader.localIdentifier]; });
    var measureIndexes = createMeasureIndexes(fromMeasures, measureHeaders);
    return {
        dimIdx: dimIdx,
        fromMeasures: fromMeasures,
        fromMeasuresDef: fromMeasuresDef,
        scopingAttributes: scopingAttributes,
        scopingAttributesDef: scopingAttributesDef,
        measureHeaders: measureHeaders,
        allAttributeHeaders: allAttributeHeaders,
        measureIndexes: measureIndexes,
        count: count,
    };
}
function createDataSlicesDigest(dataView, resultDesc, def) {
    var locations = resultDesc.locations;
    var dimIdx = locations[1];
    if (dimIdx < 0) {
        return;
    }
    var headerItems = dataViewHeaders(dataView, dimIdx);
    var count = headerItems.length > 0 ? headerItems[0].length : 0;
    var descriptors = dataViewDimensionItems(dataView, dimIdx).filter(isAttributeDescriptor);
    var descriptorsDef = descriptors.map(function (d) { return def.attributesIndex[d.attributeHeader.localIdentifier]; });
    return {
        dimIdx: dimIdx,
        descriptors: descriptors,
        descriptorsDef: descriptorsDef,
        headerItems: headerItems,
        count: count,
    };
}
function createExecutionDefinitionDigest(dataView) {
    var definition = dataView.definition;
    var attributesIndex = keyBy(definition.attributes, attributeLocalId);
    var measuresIndex = keyBy(definition.measures, measureLocalId);
    return {
        attributesIndex: attributesIndex,
        measuresIndex: measuresIndex,
    };
}
/**
 * Creates digest for the provided data view. The digest includes references to various parts of the
 * data view. The digest never copies any data from the input data view.
 *
 * @param dataView - data view to calculate digest for
 * @returns new digest
 */
export function createDataAccessDigest(dataView) {
    var resultDesc = findSlicesAndSeriesDims(dataView.result.dimensions);
    var def = createExecutionDefinitionDigest(dataView);
    var series = createDataSeriesDigest(dataView, resultDesc, def);
    var slices = createDataSlicesDigest(dataView, resultDesc, def);
    return {
        series: series,
        slices: slices,
        def: def,
    };
}
//# sourceMappingURL=dataAccessDigest.js.map