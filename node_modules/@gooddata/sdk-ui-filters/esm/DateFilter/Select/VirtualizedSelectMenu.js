import { __assign, __extends } from "tslib";
// (C) 2019 GoodData Corporation
import React from "react";
import { VariableSizeList as List } from "react-window";
import cx from "classnames";
import range from "lodash/range";
import { SelectOption } from "./SelectOption";
import { SelectHeading } from "./SelectHeading";
import { SelectSeparator } from "./SelectSeparator";
import { getSelectableItems } from "./utils";
export var defaultVisibleItemsRange = 3;
// eslint-disable-next-line @typescript-eslint/ban-types
var optionGetter = function (_a) {
    var items = _a.items, selectedItem = _a.selectedItem, highlightedIndex = _a.highlightedIndex, getItemProps = _a.getItemProps, optionClassName = _a.optionClassName;
    return function WrappedSelectOption(_a) {
        var index = _a.index, style = _a.style;
        var selectableOptions = getSelectableItems(items);
        var item = items[index];
        if (item.type === "option") {
            return (React.createElement(SelectOption, __assign({}, getItemProps({
                key: item.type + "-" + item.value,
                item: item,
                index: selectableOptions.indexOf(item),
                isSelected: selectedItem && item ? selectedItem.value === item.value : false,
                className: optionClassName,
            }), { isFocused: selectableOptions[highlightedIndex] && item
                    ? selectableOptions[highlightedIndex].value === item.value
                    : false, style: style }), item.label));
        }
        else if (item.type === "heading" || item.type === "error") {
            // for now errors look the same as headings
            return (React.createElement(SelectHeading, { key: item.type + "-" + item.label, style: style }, item.label));
        }
        else if (item.type === "separator") {
            return React.createElement(SelectSeparator, { key: item.type + "-" + index, style: style });
        }
        return null;
    };
};
var itemHeightByTypeMap = {
    option: 32,
    heading: 22,
    error: 22,
    separator: 1,
};
var getItemHeight = function (items) {
    return function (index) {
        var itemType = items[index].type;
        return itemHeightByTypeMap[itemType];
    };
};
export var getMedianIndex = function (array) { return Math.floor(array.length / 2); };
var VirtualizedSelectMenu = /** @class */ (function (_super) {
    __extends(VirtualizedSelectMenu, _super);
    function VirtualizedSelectMenu() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.listRef = React.createRef();
        _this.scrollToIndex = function (index) {
            if (index === void 0) { index = _this.props.highlightedIndex; }
            if (_this.listRef.current) {
                var items = _this.props.items;
                var selectableOptions = getSelectableItems(items);
                var optionIndex = index !== null ? index : getMedianIndex(getSelectableItems(items));
                var highlightedOption = selectableOptions[optionIndex];
                // highlightedIndex ignores non selectable items, but scrollToItem doesn't.
                var actualItemIndex = items.indexOf(highlightedOption);
                _this.listRef.current.scrollToItem(actualItemIndex, "center");
            }
        };
        _this.scrollToTop = function () {
            if (!_this.listRef.current) {
                return;
            }
            _this.listRef.current.scrollTo(0);
        };
        _this.componentDidUpdate = function (lastProps) {
            var _a = _this.props, highlightedIndex = _a.highlightedIndex, items = _a.items, setHighlightedIndex = _a.setHighlightedIndex, inputValue = _a.inputValue;
            var lastSelectibleLastItemIndex = getSelectableItems(lastProps.items).length - 1;
            var selectiblelastItemIndex = getSelectableItems(items).length - 1;
            var lastHighlightIsAtStart = lastProps.highlightedIndex === 0;
            var lastHighlightIsAtEnd = lastProps.highlightedIndex === lastSelectibleLastItemIndex;
            var highlightIsAtStart = highlightedIndex === 0;
            var highlightIsAtEnd = highlightedIndex === selectiblelastItemIndex;
            var isHighlightLoopedBack = lastHighlightIsAtStart && highlightIsAtEnd;
            var isHighlightLoopedForward = lastHighlightIsAtEnd && highlightIsAtStart;
            var isInputValueEmpty = inputValue.trim() === "";
            var isInputValueReset = lastProps.inputValue.trim() !== "" && isInputValueEmpty;
            var isInputValueChanged = lastProps.inputValue.trim() !== inputValue.trim();
            var medianIndex = getMedianIndex(getSelectableItems(items));
            if (isInputValueReset) {
                // We need to set highlight to medianIndex manually after clearing inputValue
                setHighlightedIndex(medianIndex);
            }
            else if (isInputValueChanged) {
                // We need to set highlight to 0 manually after filtering
                setHighlightedIndex(0);
            }
            var hasOnlyOneItem = _this.props.items.length === 1;
            if (isInputValueReset) {
                // We need to restore explicitly medianIndex scroll position immediately after inputValue reset
                // even though setHighlightedIndex(medianIndex) is called, because it takes effect after one tick
                _this.scrollToIndex(medianIndex);
            }
            else if (isHighlightLoopedBack || isHighlightLoopedForward) {
                _this.scrollToIndex();
            }
            else if (hasOnlyOneItem) {
                // if there is only one item, we need to explicitly scroll to top
                // in order to handle error messages being scrolled out of view
                _this.scrollToTop();
            }
        };
        return _this;
    }
    VirtualizedSelectMenu.prototype.render = function () {
        var _a = this.props, items = _a.items, selectedItem = _a.selectedItem, highlightedIndex = _a.highlightedIndex, getItemProps = _a.getItemProps, getMenuProps = _a.getMenuProps, className = _a.className, optionClassName = _a.optionClassName, visibleItemsRange = _a.visibleItemsRange;
        var Option = optionGetter({
            items: items,
            selectedItem: selectedItem,
            highlightedIndex: highlightedIndex,
            getItemProps: getItemProps,
            optionClassName: optionClassName,
        });
        var middleItemIndex = getMedianIndex(getSelectableItems(items));
        var visibleIndexes = range(Math.max(middleItemIndex - visibleItemsRange, 0), Math.min(middleItemIndex + visibleItemsRange + 1, items.length));
        var listHeight = visibleIndexes.reduce(function (totalHeight, itemIndex) { return totalHeight + getItemHeight(items)(itemIndex); }, 0);
        return (React.createElement("div", __assign({}, getMenuProps({ className: cx("gd-select-menu-wrapper", className) })),
            React.createElement("div", { className: "gd-select-menu s-select-menu" },
                React.createElement(List, { className: "List", ref: this.listRef, itemCount: items.length, itemSize: getItemHeight(items), height: listHeight, width: "100%", overscanCount: 10, estimatedItemSize: itemHeightByTypeMap.option, 
                    // IE shows an unnecessary scrollbar when the list has only one item
                    // this means we have to explicitly disallow that
                    // we also cannot use className prop because react-window sets overflow using style
                    style: items.length === 1 ? { overflow: "hidden" } : undefined }, Option))));
    };
    VirtualizedSelectMenu.prototype.componentDidMount = function () {
        if (!this.props.inputValue) {
            var medianIndex = getMedianIndex(getSelectableItems(this.props.items));
            this.props.setHighlightedIndex(medianIndex);
            this.scrollToIndex(medianIndex);
        }
        else {
            this.scrollToIndex();
        }
    };
    // static cannot have <V>
    VirtualizedSelectMenu.defaultProps = {
        selectedItem: null,
        visibleItemsRange: defaultVisibleItemsRange,
    };
    return VirtualizedSelectMenu;
}(React.Component));
export { VirtualizedSelectMenu };
//# sourceMappingURL=VirtualizedSelectMenu.js.map