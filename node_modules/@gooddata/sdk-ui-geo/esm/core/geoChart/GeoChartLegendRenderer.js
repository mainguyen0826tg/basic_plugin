import { __assign } from "tslib";
// (C) 2020 GoodData Corporation
import React from "react";
import Measure from "react-measure";
import cx from "classnames";
import { generateLegendColorData } from "./geoChartColor";
import PushpinCategoryLegend, { HEIGHT_OF_SIZE_LEGEND } from "./legends/PushpinCategoryLegend";
import PushpinSizeLegend from "./legends/PushpinSizeLegend";
import { getAvailableLegends } from "./helpers/geoChart/data";
import { Paging, ColorLegend } from "@gooddata/sdk-ui-vis-commons";
import { getPushpinColorLegendSize, getPushpinColorLegendTitle, isSmallPushpinSizeLegend, getPushpinSizeLegendTitle, shouldRenderCircleLegendInsidePopUp, shouldRenderMiddleCircle, } from "./helpers/geoChart/responsive";
var HEIGHT_OF_COLOR_LEGEND = 210;
function getClassnames(props, availableLegends) {
    var _a;
    var position = props.position, isFluidLegend = props.isFluidLegend;
    var hasSizeLegend = availableLegends.hasSizeLegend;
    var isBottomPosition = isFluidLegend || position === "bottom";
    return cx("geo-legend", "s-geo-legend", "viz-legend", (_a = {
            "viz-fluid-legend-wrap": isFluidLegend,
            "viz-static-legend-wrap": !isFluidLegend,
            static: !isFluidLegend,
            "has-size-legend": hasSizeLegend
        },
        _a["position-" + position] = !isBottomPosition,
        // this is required in case
        // position is not BOTTOM but isFluidLegend is true
        _a["position-bottom"] = isBottomPosition,
        _a));
}
export default function GeoChartLegendRenderer(props) {
    var _a;
    var _b = props.categoryItems, categoryItems = _b === void 0 ? [] : _b, _c = props.geoData, geoData = _c === void 0 ? {} : _c, height = props.height, _d = props.numericSymbols, numericSymbols = _d === void 0 ? [] : _d;
    var position = (_a = props.position) !== null && _a !== void 0 ? _a : "top";
    var availableLegends = getAvailableLegends(categoryItems, geoData);
    var hasCategoryLegend = availableLegends.hasCategoryLegend, hasColorLegend = availableLegends.hasColorLegend, hasSizeLegend = availableLegends.hasSizeLegend;
    var isLegendVisible = hasCategoryLegend || hasColorLegend || hasSizeLegend;
    if (!isLegendVisible) {
        return null;
    }
    if (hasCategoryLegend) {
        return renderCategoryAndSizeLegend(props, availableLegends);
    }
    if (hasColorLegend && hasSizeLegend && shouldShowPagingLegend(height, position)) {
        return (React.createElement(ColorAndSizeLegendWithPaging, __assign({}, props, { numericSymbols: numericSymbols, availableLegends: availableLegends })));
    }
    return renderColorAndSizeLegend(props, availableLegends);
}
function renderCategoryAndSizeLegend(props, availableLegends) {
    var contentRect = props.contentRect, renderPopUp = props.renderPopUp;
    var hasSizeLegend = availableLegends.hasSizeLegend;
    var classNames = cx(getClassnames(props, availableLegends));
    return (React.createElement(Measure, { client: true }, function (_a) {
        var _b;
        var measureRef = _a.measureRef, contentRectLegend = _a.contentRect;
        if (shouldRenderCircleLegendInsidePopUp((_b = contentRect === null || contentRect === void 0 ? void 0 : contentRect.client) === null || _b === void 0 ? void 0 : _b.width, renderPopUp)) {
            return (React.createElement("div", { className: classNames, ref: measureRef }, renderPushpinLegend(props, contentRectLegend, hasSizeLegend)));
        }
        return (React.createElement("div", { className: classNames, ref: measureRef },
            renderPushpinCategoryLegend(props, contentRectLegend, hasSizeLegend),
            renderPushpinSizeLegend(props, hasSizeLegend)));
    }));
}
// if height of color + size is bigger than container, we will show paging for legends
function shouldShowPagingLegend(height, legendPosition) {
    if (height !== undefined && (legendPosition === "left" || legendPosition === "right")) {
        var heightOfColorAndSizeLegend = HEIGHT_OF_COLOR_LEGEND + HEIGHT_OF_SIZE_LEGEND;
        return height < heightOfColorAndSizeLegend;
    }
    return false;
}
function ColorAndSizeLegendWithPaging(props) {
    var _a = React.useState(1), page = _a[0], setPage = _a[1];
    var showNextPage = function () { return setPage(2); };
    var showPrevPage = function () { return setPage(1); };
    var availableLegends = props.availableLegends;
    var classNames = getClassnames(props, availableLegends);
    return (React.createElement("div", { className: classNames },
        React.createElement("div", { className: "geo-legend-paging" },
            renderPushpinColorLegend(props, page === 1),
            renderPushpinSizeLegend(props, page === 2)),
        React.createElement(Paging, { page: page, pagesCount: 2, showNextPage: showNextPage, showPrevPage: showPrevPage })));
}
function renderColorAndSizeLegend(props, availableLegends) {
    var hasColorLegend = availableLegends.hasColorLegend, hasSizeLegend = availableLegends.hasSizeLegend;
    var classNames = getClassnames(props, availableLegends);
    return (React.createElement("div", { className: classNames },
        renderPushpinColorLegend(props, hasColorLegend),
        renderPushpinSizeLegend(props, hasSizeLegend)));
}
function renderPushpinColorLegend(props, hasColorLegend) {
    var _a, _b;
    if (!hasColorLegend) {
        return null;
    }
    var geoData = props.geoData, _c = props.position, position = _c === void 0 ? "top" : _c, responsive = props.responsive, isFluidLegend = props.isFluidLegend, colorLegendValue = props.colorLegendValue, _d = props.numericSymbols, numericSymbols = _d === void 0 ? [] : _d, contentRect = props.contentRect;
    var data = geoData.color.data;
    var format = geoData.color.format;
    var dataWithoutNull = data.filter(isFinite);
    var colorData = generateLegendColorData(dataWithoutNull, colorLegendValue);
    var width = (_a = contentRect === null || contentRect === void 0 ? void 0 : contentRect.client) === null || _a === void 0 ? void 0 : _a.width;
    var size = getPushpinColorLegendSize(width, isFluidLegend, responsive);
    var title = getPushpinColorLegendTitle((_b = geoData === null || geoData === void 0 ? void 0 : geoData.color) === null || _b === void 0 ? void 0 : _b.name, width, responsive);
    return (React.createElement(ColorLegend, { data: colorData, format: format, size: size, numericSymbols: numericSymbols, position: position, title: title }));
}
function renderPushpinCategoryLegend(props, contentRect, hasSizeLegend) {
    var containerId = props.containerId;
    if (!containerId) {
        return null;
    }
    return (React.createElement(PushpinCategoryLegend, __assign({}, props, { contentRect: contentRect, hasSizeLegend: hasSizeLegend, containerId: containerId })));
}
function renderPushpinSizeLegend(props, hasSizeLegend, ignoreMeasureName, ignoreSmallSize) {
    var _a;
    if (ignoreMeasureName === void 0) { ignoreMeasureName = false; }
    if (ignoreSmallSize === void 0) { ignoreSmallSize = false; }
    if (!hasSizeLegend) {
        return null;
    }
    var geoData = props.geoData, _b = props.numericSymbols, numericSymbols = _b === void 0 ? [] : _b, responsive = props.responsive, contentRect = props.contentRect;
    if (!geoData || !geoData.size) {
        return null;
    }
    var _c = geoData.size, data = _c.data, format = _c.format, name = _c.name;
    var width = (_a = contentRect === null || contentRect === void 0 ? void 0 : contentRect.client) === null || _a === void 0 ? void 0 : _a.width;
    var isSmall = isSmallPushpinSizeLegend(width, ignoreSmallSize, responsive);
    var title = getPushpinSizeLegendTitle(name, width, ignoreMeasureName);
    var showMiddleCircle = shouldRenderMiddleCircle(width, ignoreSmallSize);
    return (React.createElement(PushpinSizeLegend, { format: format, measureName: title, numericSymbols: numericSymbols, sizes: data, isSmall: isSmall, showMiddleCircle: showMiddleCircle }));
}
function renderPushpinLegend(props, contentRect, hasSizeLegend) {
    var _a, _b;
    var containerId = props.containerId;
    if (!containerId) {
        return null;
    }
    return (React.createElement(PushpinCategoryLegend, __assign({}, props, { contentRect: contentRect, hasSizeLegend: hasSizeLegend, isSizeLegendVisible: false, containerId: containerId, customComponent: renderPushpinSizeLegend(props, hasSizeLegend, true, true), customComponentName: (_b = (_a = props.geoData) === null || _a === void 0 ? void 0 : _a.size) === null || _b === void 0 ? void 0 : _b.name })));
}
//# sourceMappingURL=GeoChartLegendRenderer.js.map