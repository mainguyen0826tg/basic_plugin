// (C) 2019-2020 GoodData Corporation
import { __extends } from "tslib";
import { defaultDimensionsGenerator, defWithDimensions, newDefForInsight, } from "@gooddata/sdk-model";
import { BearPreparedExecution } from "./preparedExecution";
import { AbstractExecutionFactory } from "@gooddata/sdk-backend-base";
import { BearPreparedExecutionByRef } from "./preparedExecutionByRef";
import compact from "lodash/compact";
var BearExecution = /** @class */ (function (_super) {
    __extends(BearExecution, _super);
    function BearExecution(authCall, workspace) {
        var _this = _super.call(this, workspace) || this;
        _this.authCall = authCall;
        return _this;
    }
    BearExecution.prototype.forDefinition = function (def) {
        return new BearPreparedExecution(this.authCall, def, this);
    };
    BearExecution.prototype.forInsightByRef = function (insight, filters) {
        var def = defWithDimensions(newDefForInsight(this.workspace, insight, filters), defaultDimensionsGenerator);
        var nonNullFilters = compact(filters);
        /*
         * Need different factory to retain `insight` and `filters` during as the prepared execution is
         * cumulatively constructed
         */
        var byRefFactory = new BearExecutionByRef(this.authCall, this.workspace, insight, nonNullFilters);
        return new BearPreparedExecutionByRef(this.authCall, def, insight, nonNullFilters, byRefFactory);
    };
    return BearExecution;
}(AbstractExecutionFactory));
export { BearExecution };
/**
 * Execution by reference is a different execution type, represented by different class using with different endpoint. Yet
 * it still has to stick to the cumulative and fluent API specified by IPreparedExecution. On top of that, the executions
 * need to be done in a way that they support 'decorability' - so that they can be transparenty wrapped by for instance
 * caching decorator.
 *
 * The transparent decorability in combination with the requirements for cumulative, immutable construction require
 * that each implementation of prepared execution receives an execution factory to create the new instance of
 * the prepared execution with updated definition.
 *
 * In order for this to work with the execution by reference (implemented by different class, requiring always
 * the entire insight which contains the necessary 'ref'), it is essential to use this other execution factory which
 * retains this essential detail during the cumulative operations.
 */
var BearExecutionByRef = /** @class */ (function (_super) {
    __extends(BearExecutionByRef, _super);
    function BearExecutionByRef(authCall, workspace, insight, filters) {
        if (filters === void 0) { filters = []; }
        var _this = _super.call(this, workspace) || this;
        _this.authCall = authCall;
        _this.insight = insight;
        _this.filters = filters;
        return _this;
    }
    BearExecutionByRef.prototype.forDefinition = function (def) {
        return new BearPreparedExecutionByRef(this.authCall, def, this.insight, this.filters, this);
    };
    BearExecutionByRef.prototype.forInsightByRef = function (insight, filters) {
        var def = defWithDimensions(newDefForInsight(this.workspace, insight, filters), defaultDimensionsGenerator);
        return new BearPreparedExecutionByRef(this.authCall, def, insight, filters, this);
    };
    return BearExecutionByRef;
}(AbstractExecutionFactory));
//# sourceMappingURL=executionFactory.js.map