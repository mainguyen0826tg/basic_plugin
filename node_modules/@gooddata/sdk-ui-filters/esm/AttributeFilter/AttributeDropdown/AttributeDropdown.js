import { __assign, __awaiter, __extends, __generator } from "tslib";
// (C) 2007-2018 GoodData Corporation
import React from "react";
import { injectIntl } from "react-intl";
import { areObjRefsEqual } from "@gooddata/sdk-model";
import { Dropdown, DropdownButton } from "@gooddata/sdk-ui-kit";
import { stringUtils } from "@gooddata/util";
import cx from "classnames";
import debounce from "lodash/debounce";
import noop from "lodash/noop";
import { AttributeDropdownBody } from "./AttributeDropdownBody";
import { MAX_SELECTION_SIZE } from "./AttributeDropdownList";
import { mergeElementQueryResults } from "./mergeElementQueryResults";
import { isNonEmptyListItem, } from "./types";
import isEmpty from "lodash/isEmpty";
import isEqual from "lodash/isEqual";
import { getAllTitleIntl, getElementTotalCount, isParentFilteringEnabled, showAllFilteredMessage, showItemsFilteredMessage, updateSelectedOptionsWithData, } from "../utils/AttributeFilterUtils";
import { AttributeDropdownAllFilteredOutBody } from "./AttributeDropdownAllFilteredOutBody";
import MediaQuery from "react-responsive";
import { MediaQueries } from "../../constants";
var LIMIT = MAX_SELECTION_SIZE + 50;
var DefaultFilterLoading = injectIntl(function (_a) {
    var intl = _a.intl;
    return (React.createElement("button", { className: "gd-button gd-button-secondary gd-button-small gd-icon-right gd-icon disabled s-button-loading" }, intl.formatMessage({ id: "gs.filter.loading" })));
});
var AttributeDropdownCore = /** @class */ (function (_super) {
    __extends(AttributeDropdownCore, _super);
    function AttributeDropdownCore(props) {
        var _a;
        var _this = _super.call(this, props) || this;
        _this.getBackend = function () {
            return _this.props.backend.withTelemetry("AttributeFilter", _this.props);
        };
        _this.getElementTotalCount = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, workspace, displayForm, parentFilters;
            return __generator(this, function (_b) {
                _a = this.props, workspace = _a.workspace, displayForm = _a.displayForm, parentFilters = _a.parentFilters;
                return [2 /*return*/, getElementTotalCount(workspace, this.getBackend(), displayForm, "", parentFilters)];
            });
        }); };
        _this.getElements = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, offset, limit, validElements, currentElements, isQueryOutOfBounds, isMissingDataInWindow, hasAllData, needsLoading;
            return __generator(this, function (_b) {
                _a = this.state, offset = _a.offset, limit = _a.limit, validElements = _a.validElements;
                currentElements = validElements ? validElements.items : [];
                isQueryOutOfBounds = offset + limit > currentElements.length;
                isMissingDataInWindow = currentElements
                    .slice(offset, offset + limit)
                    .some(function (e) { return e.empty; });
                hasAllData = validElements &&
                    currentElements.length === validElements.totalCount &&
                    !currentElements.some(function (e) { return e.empty; });
                needsLoading = !hasAllData && (isQueryOutOfBounds || isMissingDataInWindow);
                if (needsLoading) {
                    this.loadElements(offset, limit);
                }
                return [2 /*return*/];
            });
        }); };
        _this.onSearch = debounce(function (query) {
            _this.setState({ searchString: query });
        }, 250);
        _this.clearSearchString = function () {
            _this.setState({ searchString: "" });
        };
        _this.loadElements = function (offset, limit) { return __awaiter(_this, void 0, void 0, function () {
            var _a, workspace, displayForm, preparedQuery, newElements, mergedValidElements, items, updatedSelectedItems, updatedPrevSelectedItems;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.props, workspace = _a.workspace, displayForm = _a.displayForm;
                        this.setState({ isLoading: true });
                        preparedQuery = this.getBackend()
                            .workspace(workspace)
                            .attributes()
                            .elements()
                            .forDisplayForm(displayForm)
                            .withOptions(__assign({}, (this.state.searchString ? { filter: this.state.searchString } : {})))
                            .withOffset(offset)
                            .withLimit(limit);
                        if (this.props.parentFilters && isParentFilteringEnabled(this.getBackend())) {
                            preparedQuery.withAttributeFilters(this.props.parentFilters);
                        }
                        return [4 /*yield*/, preparedQuery.query()];
                    case 1:
                        newElements = _b.sent();
                        mergedValidElements = mergeElementQueryResults(this.state.validElements, newElements);
                        items = mergedValidElements.items;
                        updatedSelectedItems = updateSelectedOptionsWithData(this.state.selectedItems, items);
                        updatedPrevSelectedItems = updateSelectedOptionsWithData(this.state.prevSelectedItems, items);
                        this.setState(function (state) {
                            return __assign(__assign({}, state), { selectedItems: updatedSelectedItems, prevSelectedItems: updatedPrevSelectedItems, isLoading: false, validElements: state.searchString ? newElements : mergedValidElements, items: items, totalCount: state.firstLoad ? newElements.totalCount : state.totalCount, firstLoad: false });
                        });
                        return [2 /*return*/];
                }
            });
        }); };
        _this.getTitle = function () {
            var _a = _this.state, isInverted = _a.isInverted, selectedItems = _a.selectedItems, totalCount = _a.totalCount;
            var _b = _this.props, title = _b.title, displayForm = _b.displayForm, titleWithSelection = _b.titleWithSelection;
            if (totalCount && titleWithSelection && displayForm) {
                var empty = isEmpty(selectedItems);
                var equal = isEqual(totalCount, selectedItems.length);
                var getAllPartIntl = getAllTitleIntl(_this.props.intl, isInverted, empty, equal);
                if (empty) {
                    return isInverted ? title + ": " + getAllPartIntl : title;
                }
                if (equal) {
                    return isInverted ? title : title + ": " + getAllPartIntl;
                }
                var itemTitlesToString = selectedItems.map(function (selectedItem) { return selectedItem.title; }).join(", ");
                var fullTitle = isInverted
                    ? title + ": " + getAllPartIntl + " " + itemTitlesToString
                    : title + ": " + itemTitlesToString;
                return stringUtils.shortenText(fullTitle, { maxLength: 35 }) + " (" + selectedItems.length + ")";
            }
            return title;
        };
        _this.backupSelection = function (callback) {
            if (callback === void 0) { callback = noop; }
            var _a = _this.state, selectedItems = _a.selectedItems, isInverted = _a.isInverted;
            _this.setState({
                prevSelectedItems: selectedItems,
                prevIsInverted: isInverted,
            }, callback);
        };
        _this.restoreSelection = function () {
            var _a = _this.state, prevSelectedItems = _a.prevSelectedItems, prevIsInverted = _a.prevIsInverted;
            _this.setState({
                selectedItems: prevSelectedItems,
                isInverted: prevIsInverted,
            });
        };
        _this.onDropdownOpenStateChanged = function (isOpen) {
            if (isOpen) {
                _this.getElements();
            }
            else {
                _this.clearSearchString();
                _this.restoreSelection();
            }
        };
        _this.onApplyButtonClicked = function (callback) {
            if (callback === void 0) { callback = noop; }
            _this.props.onApply(_this.state.selectedItems.filter(isNonEmptyListItem), _this.state.isInverted);
            _this.backupSelection(callback);
        };
        _this.onSelect = function (selectedItems, isInverted) {
            _this.setState({
                selectedItems: selectedItems,
                isInverted: isInverted,
            });
        };
        _this.onRangeChange = function (_searchString, from, to) {
            _this.setState({ offset: from, limit: to - from }, function () { return _this.getElements(); });
        };
        var selectedItems = updateSelectedOptionsWithData(props.selectedItems || [], []);
        var isInverted = (_a = props.isInverted) !== null && _a !== void 0 ? _a : false;
        _this.state = {
            validElements: null,
            selectedItems: selectedItems,
            isInverted: isInverted,
            prevSelectedItems: selectedItems,
            prevIsInverted: isInverted,
            firstLoad: true,
            isLoading: false,
            limit: LIMIT,
            offset: 0,
            searchString: "",
            totalCount: LIMIT,
            items: [],
        };
        return _this;
    }
    AttributeDropdownCore.prototype.componentDidUpdate = function (prevProps, prevState) {
        var _this = this;
        var parentFilterChanged = !isEqual(this.props.parentFilters, prevProps.parentFilters);
        var needsInvalidation = !areObjRefsEqual(this.props.displayForm, prevProps.displayForm) ||
            this.props.workspace !== prevProps.workspace ||
            parentFilterChanged ||
            this.state.searchString !== prevState.searchString;
        if (needsInvalidation) {
            this.setState({
                validElements: null,
                error: null,
                isLoading: false,
                offset: 0,
                limit: LIMIT,
                selectedItems: parentFilterChanged ? [] : this.state.selectedItems,
                prevSelectedItems: parentFilterChanged ? [] : this.state.selectedItems,
                isInverted: parentFilterChanged ? true : this.state.isInverted,
                prevIsInverted: parentFilterChanged ? true : this.state.prevIsInverted,
            }, function () {
                _this.getElements();
                parentFilterChanged &&
                    _this.getElementTotalCount().then(function (totalCount) {
                        _this.setState(function (state) {
                            return __assign(__assign({}, state), { totalCount: totalCount });
                        });
                    });
                // calling onApply to get the values changed in parent component
                parentFilterChanged && _this.onApplyButtonClicked();
            });
        }
    };
    AttributeDropdownCore.prototype.render = function () {
        var _this = this;
        var _a = this.props, FilterLoading = _a.FilterLoading, fullscreenOnMobile = _a.fullscreenOnMobile;
        var customizedTitle = this.getTitle();
        var classes = cx("gd-attribute-filter", customizedTitle ? "gd-id-" + stringUtils.simplifyText(customizedTitle) : "");
        return this.props.isLoading ? (React.createElement(FilterLoading, null)) : (React.createElement(Dropdown, { renderButton: function (_a) {
                var toggleDropdown = _a.toggleDropdown, isOpen = _a.isOpen;
                return (React.createElement(DropdownButton, { isOpen: isOpen, value: customizedTitle, onClick: toggleDropdown }));
            }, renderBody: function (_a) {
                var closeDropdown = _a.closeDropdown;
                return _this.renderDropdownBody(closeDropdown);
            }, className: classes, fullscreenOnMobile: fullscreenOnMobile, onOpenStateChanged: this.onDropdownOpenStateChanged }));
    };
    AttributeDropdownCore.prototype.emptyValueItems = function (items) {
        var emptyHeaderString = this.props.translationProps
            ? this.props.translationProps.emptyHeaderString
            : "(empty value)";
        var nonEmptyItems = items.filter(isNonEmptyListItem);
        nonEmptyItems.forEach(function (item) {
            if (isEmpty(item.title)) {
                // @ts-expect-error TODO: SDK8: this is evil; mutating the items of readonly array; need to find a conceptual way to do this
                item.title = emptyHeaderString;
            }
        });
        return items;
    };
    AttributeDropdownCore.prototype.renderDropdownBody = function (closeDropdown) {
        var _this = this;
        var _a, _b, _c, _d;
        var _e = this.state, selectedItems = _e.selectedItems, isInverted = _e.isInverted, error = _e.error, isLoading = _e.isLoading, validElements = _e.validElements, searchString = _e.searchString;
        var shouldDisableApplyButton = error || isLoading || (validElements && !validElements.items.length);
        var hasTriedToLoadData = validElements && validElements.items;
        var isAllFiltered = showAllFilteredMessage(this.state.isLoading, (_a = this.props.parentFilters) === null || _a === void 0 ? void 0 : _a.map(function (filter) { return filter.attributeFilter; }), (_b = validElements === null || validElements === void 0 ? void 0 : validElements.items.length) !== null && _b !== void 0 ? _b : 0);
        var isItemsFiltered = showItemsFilteredMessage(this.state.isLoading, (_c = this.props.parentFilters) === null || _c === void 0 ? void 0 : _c.map(function (filter) { return filter.attributeFilter; }));
        return !isEmpty(this.props.parentFilterTitles) && isAllFiltered ? (React.createElement(MediaQuery, { query: MediaQueries.IS_MOBILE_DEVICE }, function (isMobile) { return (React.createElement(AttributeDropdownAllFilteredOutBody, { parentFilterTitles: _this.props.parentFilterTitles, onApplyButtonClick: function () { return _this.onApplyButtonClicked(closeDropdown); }, onCancelButtonClick: function () { return closeDropdown(); }, isMobile: isMobile })); })) : (React.createElement(AttributeDropdownBody, { error: error, isLoading: !hasTriedToLoadData && isLoading, items: validElements ? this.emptyValueItems(validElements.items) : [], isInverted: isInverted, onRangeChange: this.onRangeChange, selectedItems: selectedItems, totalCount: (_d = validElements === null || validElements === void 0 ? void 0 : validElements.items.length) !== null && _d !== void 0 ? _d : LIMIT, applyDisabled: shouldDisableApplyButton, onSearch: this.onSearch, searchString: searchString, onSelect: this.onSelect, onApplyButtonClicked: function () { return _this.onApplyButtonClicked(closeDropdown); }, onCloseButtonClicked: function () { return closeDropdown(); }, parentFilterTitles: this.props.parentFilterTitles, showItemsFilteredMessage: isItemsFiltered }));
    };
    AttributeDropdownCore.defaultProps = {
        fullscreenOnMobile: false,
        isMobile: false,
        titleWithSelection: false,
        FilterLoading: DefaultFilterLoading,
        isLoading: false,
    };
    return AttributeDropdownCore;
}(React.PureComponent));
export { AttributeDropdownCore };
export var AttributeDropdown = injectIntl(AttributeDropdownCore);
//# sourceMappingURL=AttributeDropdown.js.map