import { __assign, __read, __spread } from "tslib";
// (C) 2019-2021 GoodData Corporation
import isArray from "lodash/isArray";
import { isPlaceholder, isAnyPlaceholder, isComposedPlaceholder, } from "./base";
/**
 * Set placeholder value to the context.
 * @internal
 */
export function setPlaceholder(placeholder, value, state) {
    var _a;
    if (placeholder.validate) {
        placeholder.validate(value);
    }
    if (isPlaceholder(placeholder)) {
        return __assign(__assign({}, state), { placeholders: __assign(__assign({}, state.placeholders), (_a = {}, _a[placeholder.id] = __assign(__assign({}, placeholder), { value: value }), _a)) });
    }
    return state;
}
/**
 * Resolve placeholder value from the context, or fallback to default value.
 * @internal
 */
export function resolvePlaceholderValue(placeholder, state) {
    var _a, _b;
    var placeholderValue = (_b = (_a = state.placeholders[placeholder.id]) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : placeholder.defaultValue;
    if (placeholder.validate) {
        placeholder.validate(placeholderValue);
    }
    return placeholderValue;
}
/**
 * Resolve composed placeholder value with provided resolution context.
 * @internal
 */
export function resolveComposedPlaceholderValue(placeholder, state, resolutionContext) {
    var values = placeholder.placeholders.map(function (p) {
        return resolveValueWithPlaceholders(p, state, resolutionContext);
    });
    return placeholder.computeValue(values, resolutionContext);
}
/**
 * Resolve value(s) that can possibly contain also placeholder(s) to actual value(s).
 * Arrays with nested placeholders that are holding arrays are flattened.
 * You can specify custom resolution context for the composed placeholders.
 *
 * This is method you want to use to replace placeholders in any value with actual placeholder values.
 * It does not support object traversing as most of the visualizations interfaces
 * are consuming only arrays or single values.
 *
 * @internal
 */
export function resolveValueWithPlaceholders(value, state, resolutionContext) {
    if (isPlaceholder(value)) {
        return resolvePlaceholderValue(value, state);
    }
    else if (isComposedPlaceholder(value)) {
        return resolveComposedPlaceholderValue(value, state, resolutionContext);
    }
    else if (isArray(value)) {
        return value.reduce(function (acc, v) {
            var resolvedValue = resolveValueWithPlaceholders(v, state, resolutionContext);
            if (isAnyPlaceholder(v)) {
                // Omit placeholder values that are not set
                if (!resolvedValue) {
                    return acc;
                }
                else if (isArray(resolvedValue)) {
                    return __spread(acc, resolvedValue.filter(function (v) { return typeof v !== "undefined"; }));
                }
            }
            return __spread(acc, [resolvedValue]);
        }, []);
    }
    return value;
}
//# sourceMappingURL=resolve.js.map