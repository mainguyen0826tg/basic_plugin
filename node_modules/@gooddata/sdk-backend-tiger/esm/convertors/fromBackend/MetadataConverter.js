// (C) 2019-2021 GoodData Corporation
import { JsonApiLabelOutWithLinksTypeEnum, } from "@gooddata/api-client-tiger";
import keyBy from "lodash/keyBy";
import { newAttributeDisplayFormMetadataObject, newAttributeMetadataObject, newDashboardMetadataObject, newDataSetMetadataObject, } from "@gooddata/sdk-backend-base";
import { idRef } from "@gooddata/sdk-model";
import invariant from "ts-invariant";
export var commonMetadataObjectModifications = function (item) {
    return function (builder) {
        var _a, _b;
        return builder
            .id(item.id)
            .uri(item.links.self)
            .title(((_a = item.attributes) === null || _a === void 0 ? void 0 : _a.title) || "")
            .description(((_b = item.attributes) === null || _b === void 0 ? void 0 : _b.description) || "");
    };
};
function createLabelMap(included) {
    if (!included) {
        return {};
    }
    var labels = included.filter(function (include) {
        return include.type === JsonApiLabelOutWithLinksTypeEnum.Label;
    });
    return keyBy(labels, function (t) { return t.id; });
}
/**
 * Converts all labels of this attribute. The map contains sideloaded label information
 */
function convertAttributeLabels(attribute, labelsMap) {
    var _a, _b;
    var labelsRefs = (_b = (_a = attribute.relationships) === null || _a === void 0 ? void 0 : _a.labels) === null || _b === void 0 ? void 0 : _b.data;
    return labelsRefs
        .map(function (ref) {
        var label = labelsMap[ref.id];
        if (!label) {
            return undefined;
        }
        return convertLabelWithLinks(label, attribute.id);
    })
        .filter(function (df) { return df !== undefined; });
}
/**
 * Converts attribute when its sideloaded
 */
function convertAttributeWithLinks(attribute, labels) {
    return newAttributeMetadataObject(idRef(attribute.id, "attribute"), function (m) {
        return m
            .modify(commonMetadataObjectModifications(attribute))
            .displayForms(convertAttributeLabels(attribute, labels));
    });
}
/**
 * Converts attribute when its top-level
 */
function convertAttributeDocument(attributeDoc, labels) {
    var attribute = attributeDoc.data;
    return newAttributeMetadataObject(idRef(attribute.id, "attribute"), function (m) {
        var _a, _b;
        return m
            .id(attribute.id)
            .title(((_a = attribute.attributes) === null || _a === void 0 ? void 0 : _a.title) || "")
            .description(((_b = attribute.attributes) === null || _b === void 0 ? void 0 : _b.description) || "")
            .uri(attributeDoc.links.self)
            .displayForms(convertAttributeLabels(attribute, labels));
    });
}
/**
 * Converts label when its side-loaded. attributeId must be passed by context because sideloaded label does not
 * contain relationships
 */
function convertLabelWithLinks(label, attributeId) {
    return newAttributeDisplayFormMetadataObject(idRef(label.id, "displayForm"), function (m) {
        var _a, _b;
        return m
            .id(label.id)
            .title(((_a = label.attributes) === null || _a === void 0 ? void 0 : _a.title) || "")
            .description(((_b = label.attributes) === null || _b === void 0 ? void 0 : _b.description) || "")
            .uri(label.links.self)
            .attribute(idRef(attributeId, "attribute"))
            .isDefault(label.attributes.primary);
    });
}
/**
 * Converts label when its top-level
 */
function convertLabelDocument(labelDoc) {
    var label = labelDoc.data;
    var attributes = label.attributes;
    invariant(attributes);
    return newAttributeDisplayFormMetadataObject(idRef(label.id, "displayForm"), function (m) {
        return m
            .id(label.id)
            .title(attributes.title || "")
            .description(attributes.description || "")
            .uri(labelDoc.links.self)
            .isDefault(attributes.primary)
            .attribute(idRef(label.relationships.attribute.data.id, "attribute"));
    });
}
//
//
//
/**
 * Converts result of a single label query with included attribute into a {@link IAttributeDisplayFormMetadataObject};
 *
 * Note: the attribute must be sideloaded otherwise the label won't contain attribute relationship and it would not be possible
 * to set attribute ref on the display form.
 *
 * @param labelDoc - response from backend
 */
export function convertLabelWithSideloadedAttribute(labelDoc) {
    return convertLabelDocument(labelDoc);
}
/**
 * Converts result of a single attribute query with included labels into a {@link IAttributeMetadataObject}.
 *
 * @param attribute - response from backend
 */
export function convertAttributeWithSideloadedLabels(attribute) {
    var labels = createLabelMap(attribute.included);
    return convertAttributeDocument(attribute, labels);
}
/**
 * Converts result of attributes query with included labels into list of {@link IAttributeMetadataObject}s
 *
 * @param attributes - response from backend
 */
export function convertAttributesWithSideloadedLabels(attributes) {
    var labels = createLabelMap(attributes.included);
    /*
     * Filter out date data set attributes. Purely because there is special processing for them
     * in catalog & code generators. Want to stick to that.
     *
     */
    return attributes.data.map(function (attribute) { return convertAttributeWithLinks(attribute, labels); });
}
/**
 * Converts sideloaded dataset into {@link IDataSetMetadataObject}
 *
 * @param dataset - sideloaded dataset
 */
export function convertDatasetWithLinks(dataset) {
    return newDataSetMetadataObject(idRef(dataset.id, "dataSet"), function (m) {
        return m.modify(commonMetadataObjectModifications(dataset));
    });
}
/**
 * Converts sideloaded dashboard into {@link IDashboardMetadataObject}
 *
 * @param dashboard - sideloaded dashboard
 */
export function convertAnalyticalDashboardWithLinks(dashboard) {
    return newDashboardMetadataObject(idRef(dashboard.id, "analyticalDashboard"), function (m) {
        return m.modify(commonMetadataObjectModifications(dashboard));
    });
}
//# sourceMappingURL=MetadataConverter.js.map