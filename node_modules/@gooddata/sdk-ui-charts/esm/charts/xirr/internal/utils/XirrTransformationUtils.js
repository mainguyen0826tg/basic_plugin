// (C) 2019-2020 GoodData Corporation
import cloneDeep from "lodash/cloneDeep";
import isEmpty from "lodash/isEmpty";
import invariant from "ts-invariant";
import { calculateXirr } from "./calculateXirr";
import { DataViewFacade, VisualizationTypes, isSomeHeaderPredicateMatched, } from "@gooddata/sdk-ui";
var computeXirr = function (executionData) {
    // prevent errors on invalid inputs
    if (!executionData || !executionData.length) {
        return NaN;
    }
    var transactions = executionData
        .map(function (datum) { return ({
        amount: datum.value != null ? Number.parseFloat(datum.value.toString()) : 0,
        date: datum.date,
    }); })
        .filter(function (datum) { return datum.amount !== 0; }) // zero values are irrelevant to XIRR computation, filter them out here to avoid useless Date parsing later
        .map(function (_a) {
        var amount = _a.amount, date = _a.date;
        return ({
            amount: amount,
            when: new Date(date),
        });
    });
    return calculateXirr(transactions);
};
function getExecutionData(dv) {
    var headerItems = dv.meta().attributeHeaders()[0][0]; // TODO: is there a better way to do this?
    var data = dv.rawData().singleDimData();
    return headerItems
        ? headerItems.map(function (item, index) {
            var value = data[index];
            invariant(value !== undefined, "Undefined execution value data for XIRR transformation");
            invariant(item.attributeHeaderItem, "Missing expected attributeHeaderItem");
            return {
                date: item.attributeHeaderItem.name,
                value: value,
            };
        })
        : [];
}
/**
 * Get {HeadlineData} used by the {Headline} component.
 *
 * @param dataView - data to visualize
 * @param intl - Required localization for compare item title
 * @returns {*}
 */
export function getHeadlineData(dataView) {
    var dv = DataViewFacade.for(dataView);
    var measure = dv.meta().measureDescriptors()[0];
    var executionData = getExecutionData(dv);
    var value = computeXirr(executionData);
    return {
        primaryItem: {
            localIdentifier: measure.measureHeaderItem.localIdentifier,
            title: measure.measureHeaderItem.name,
            value: value ? String(value) : null,
            format: measure.measureHeaderItem.format,
            isDrillable: false,
        },
    };
}
/**
 * Take headline data and apply list of drillable items.
 * The method will return copied collection of the headline data with altered drillable status.
 *
 * @param headlineData - The headline data that we want to change the drillable status.
 * @param drillableItems - list of drillable items {uri, identifier}
 * @param dataView - data visualized by the headline
 * @returns altered headlineData
 */
export function applyDrillableItems(headlineData, drillableItems, dataView) {
    var dv = DataViewFacade.for(dataView);
    var data = cloneDeep(headlineData);
    var primaryItem = data.primaryItem;
    var primaryItemHeader = dv.meta().measureDescriptors()[0];
    if (!isEmpty(primaryItem) && !isEmpty(primaryItemHeader)) {
        primaryItem.isDrillable = isSomeHeaderPredicateMatched(drillableItems, primaryItemHeader, dv);
    }
    return data;
}
/**
 * Build drill event data (object with execution and drill context) from the data obtained by clicking on the {Xirr}
 * component an from the execution objects.
 *
 * @param itemContext - data received from the click on the {Xirr} component.
 * @param dataView - data visualized by the headline
 * @returns {*}
 */
export function buildDrillEventData(itemContext, dataView) {
    var dv = DataViewFacade.for(dataView);
    var measureHeaderItem = dv.meta().measureDescriptor(itemContext.localIdentifier);
    if (!measureHeaderItem) {
        throw new Error("The metric uri has not been found in execution response!");
    }
    var intersectionElement = {
        header: measureHeaderItem,
    };
    var drillContext = {
        type: VisualizationTypes.XIRR,
        element: "primaryValue",
        value: itemContext.value,
        intersection: [intersectionElement],
    };
    return {
        dataView: dataView,
        drillContext: drillContext,
    };
}
//# sourceMappingURL=XirrTransformationUtils.js.map