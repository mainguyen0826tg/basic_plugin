import { isAttributeLocator, isAttributeSort, isMeasureSort, sortMeasureLocators, } from "@gooddata/sdk-model";
import invariant from "ts-invariant";
import findIndex from "lodash/findIndex";
function attributeLocatorMatch(col, locator) {
    var _a = col.seriesDescriptor, attributeDescriptors = _a.attributeDescriptors, attributeHeaders = _a.attributeHeaders;
    var _b = locator.attributeLocatorItem, attributeIdentifier = _b.attributeIdentifier, element = _b.element;
    if (!attributeDescriptors || !attributeHeaders) {
        return false;
    }
    var attributeIdx = findIndex(attributeDescriptors, function (d) { return d.attributeHeader.localIdentifier === attributeIdentifier; });
    if (attributeIdx === -1) {
        return false;
    }
    // if this happens then either data access infrastructure or the col descriptor method is hosed. there must
    // always be same number of descriptors and headers.
    invariant(attributeHeaders[attributeIdx]);
    return attributeHeaders[attributeIdx].attributeHeaderItem.uri === element;
}
function measureLocatorMatch(col, locator) {
    var measureDescriptor = col.seriesDescriptor.measureDescriptor;
    var measureIdentifier = locator.measureLocatorItem.measureIdentifier;
    return measureDescriptor.measureHeaderItem.localIdentifier === measureIdentifier;
}
export function measureSortMatcher(col, sortItem) {
    return (isMeasureSort(sortItem) &&
        sortMeasureLocators(sortItem).every(function (locator) {
            if (isAttributeLocator(locator)) {
                return attributeLocatorMatch(col, locator);
            }
            else {
                return measureLocatorMatch(col, locator);
            }
        }));
}
export function attributeSortMatcher(col, sortItem) {
    return (isAttributeSort(sortItem) &&
        col.attributeDescriptor.attributeHeader.localIdentifier ===
            sortItem.attributeSortItem.attributeIdentifier);
}
//# sourceMappingURL=colSortItemMatching.js.map