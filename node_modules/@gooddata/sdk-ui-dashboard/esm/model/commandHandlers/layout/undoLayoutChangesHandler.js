import { __generator } from "tslib";
import { invalidArgumentsProvided } from "../../events/general";
import { selectLayout, selectUndoableLayoutCommands } from "../../store/layout/layoutSelectors";
import { put, select } from "redux-saga/effects";
import { layoutActions } from "../../store/layout";
import { layoutChanged } from "../../events/layout";
/*
 * Default impl returns 0 -> meaning drop everything that the latest command achieved.
 */
var latestCommandUndoSelector = function (_cmds) {
    return 0;
};
export function undoLayoutChangesHandler(ctx, cmd) {
    var undoableCommands, _a, undoPointSelector, undoUpToIncludingCmd, selectedCommand, layout;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, select(selectUndoableLayoutCommands)];
            case 1:
                undoableCommands = _b.sent();
                _a = cmd.payload.undoPointSelector, undoPointSelector = _a === void 0 ? latestCommandUndoSelector : _a;
                undoUpToIncludingCmd = undoPointSelector(undoableCommands.map(function (entry) { return entry.cmd; }));
                if (undoUpToIncludingCmd < 0 || undoUpToIncludingCmd >= undoableCommands.length) {
                    throw invalidArgumentsProvided(ctx, cmd, "Undo point selector returned result out of bounds. Undoable commands: " + undoableCommands.length + ". Got index: " + undoUpToIncludingCmd);
                }
                selectedCommand = undoableCommands[undoUpToIncludingCmd];
                return [4 /*yield*/, put(layoutActions.undoLayout({
                        undoDownTo: selectedCommand.firstOccurrenceOnStack,
                    }))];
            case 2:
                _b.sent();
                return [4 /*yield*/, select(selectLayout)];
            case 3:
                layout = _b.sent();
                return [2 /*return*/, layoutChanged(ctx, layout, cmd.correlationId)];
        }
    });
}
//# sourceMappingURL=undoLayoutChangesHandler.js.map