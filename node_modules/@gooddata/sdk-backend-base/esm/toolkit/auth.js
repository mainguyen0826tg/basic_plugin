import { __awaiter, __generator } from "tslib";
// (C) 2019-2021 GoodData Corporation
import { NotSupported, } from "@gooddata/sdk-backend-spi";
/**
 * This implementation of auth provider ensures, that the auth provider is called exactly once in the happy path
 * execution where provider successfully authenticates a principal.
 *
 * If underlying provider fails, subsequent calls that need authentication will land in the provider.
 *
 * This class encapsulates the stateful nature of interaction of the provider across multiple different instances
 * of the bear backend, all of which are set with the same provider. All instances of the backend should be
 * subject to the same authentication flow AND the call to the authentication provider should be synchronized
 * through this scoped instance.
 *
 * @internal
 */
var AuthProviderCallGuard = /** @class */ (function () {
    function AuthProviderCallGuard(realProvider) {
        var _this = this;
        this.realProvider = realProvider;
        this.reset = function () {
            _this.principal = undefined;
        };
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        this.initializeClient = function (client) {
            var _a, _b;
            (_b = (_a = _this.realProvider).initializeClient) === null || _b === void 0 ? void 0 : _b.call(_a, client);
        };
        this.onNotAuthenticated = function (context, error) {
            var _a, _b;
            (_b = (_a = _this.realProvider).onNotAuthenticated) === null || _b === void 0 ? void 0 : _b.call(_a, context, error);
        };
        this.authenticate = function (context) {
            if (_this.principal) {
                return Promise.resolve(_this.principal);
            }
            if (_this.inflightRequest) {
                return _this.inflightRequest;
            }
            _this.inflightRequest = _this.realProvider
                .authenticate(context)
                .then(function (res) {
                _this.principal = res;
                _this.inflightRequest = undefined;
                return res;
            })
                .catch(function (err) {
                _this.inflightRequest = undefined;
                throw err;
            });
            return _this.inflightRequest;
        };
    }
    AuthProviderCallGuard.prototype.getCurrentPrincipal = function (context) {
        return this.realProvider.getCurrentPrincipal(context);
    };
    AuthProviderCallGuard.prototype.deauthenticate = function (context) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.realProvider.deauthenticate(context)];
            });
        });
    };
    return AuthProviderCallGuard;
}());
export { AuthProviderCallGuard };
/**
 * This implementation serves as a Null object for IAuthProviderCallGuard.
 *
 * @internal
 */
var NoopAuthProvider = /** @class */ (function () {
    function NoopAuthProvider() {
    }
    NoopAuthProvider.prototype.authenticate = function (_context) {
        throw new NotSupported("NoopAuthProvider does not support authenticate");
    };
    NoopAuthProvider.prototype.getCurrentPrincipal = function (_context) {
        throw new NotSupported("NoopAuthProvider does not support getCurrentPrincipal");
    };
    NoopAuthProvider.prototype.deauthenticate = function (_context) {
        throw new NotSupported("NoopAuthProvider does not support deauthenticate");
    };
    NoopAuthProvider.prototype.reset = function () {
        throw new NotSupported("NoopAuthProvider does not support reset");
    };
    return NoopAuthProvider;
}());
export { NoopAuthProvider };
export var AnonymousUser = {
    userId: "anonymous",
};
/**
 * This is a noop implementation of authentication provider - it does nothing and assumes anonymous user.
 *
 * @public
 */
var AnonymousAuthProvider = /** @class */ (function () {
    function AnonymousAuthProvider() {
    }
    AnonymousAuthProvider.prototype.authenticate = function (_context) {
        return Promise.resolve(AnonymousUser);
    };
    AnonymousAuthProvider.prototype.getCurrentPrincipal = function (_context) {
        return Promise.resolve(AnonymousUser);
    };
    AnonymousAuthProvider.prototype.deauthenticate = function (_context) {
        return Promise.resolve();
    };
    AnonymousAuthProvider.prototype.reset = function () {
        return;
    };
    return AnonymousAuthProvider;
}());
export { AnonymousAuthProvider };
//# sourceMappingURL=auth.js.map