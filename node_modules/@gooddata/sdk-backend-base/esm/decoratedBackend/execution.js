import identity from "lodash/identity";
/**
 * Base class for execution factory decorators. Implements all delegates.
 *
 * There is an opt-in functionality to decorate the prepared executions - which is a typical use case for
 * factory decorators.
 *
 * @alpha
 */
var DecoratedExecutionFactory = /** @class */ (function () {
    function DecoratedExecutionFactory(decorated, wrapper) {
        var _this = this;
        if (wrapper === void 0) { wrapper = identity; }
        this.decorated = decorated;
        this.wrapper = wrapper;
        /**
         * This method is a hook that can be used to wrap the execution prepared by the decorated factory - in essence
         * to keep the decorator chain going and add extra functionality to the prepared execution.
         *
         * By default, this method will call the wrapper function passed to this class at construction time - so use
         * that unless you need anything more fancy.
         *
         * @param execution - execution to wrap
         */
        this.wrap = function (execution) {
            return _this.wrapper(execution);
        };
    }
    DecoratedExecutionFactory.prototype.forDefinition = function (def) {
        return this.wrap(this.decorated.forDefinition(def));
    };
    DecoratedExecutionFactory.prototype.forItems = function (items, filters) {
        return this.wrap(this.decorated.forItems(items, filters));
    };
    DecoratedExecutionFactory.prototype.forBuckets = function (buckets, filters) {
        return this.wrap(this.decorated.forBuckets(buckets, filters));
    };
    DecoratedExecutionFactory.prototype.forInsight = function (insight, filters) {
        return this.wrap(this.decorated.forInsight(insight, filters));
    };
    DecoratedExecutionFactory.prototype.forInsightByRef = function (insight, filters) {
        return this.wrap(this.decorated.forInsightByRef(insight, filters));
    };
    return DecoratedExecutionFactory;
}());
export { DecoratedExecutionFactory };
/**
 * Abstract base class for prepared execution decorators. Implements delegates to decorated execution. Concrete
 * implementations can override just the functions they are interested in.
 *
 * @alpha
 */
var DecoratedPreparedExecution = /** @class */ (function () {
    function DecoratedPreparedExecution(decorated) {
        this.decorated = decorated;
        this.definition = decorated.definition;
    }
    DecoratedPreparedExecution.prototype.equals = function (other) {
        return this.decorated.equals(other);
    };
    DecoratedPreparedExecution.prototype.execute = function () {
        return this.decorated.execute();
    };
    DecoratedPreparedExecution.prototype.explain = function (config) {
        return this.decorated.explain(config);
    };
    DecoratedPreparedExecution.prototype.fingerprint = function () {
        return this.decorated.fingerprint();
    };
    DecoratedPreparedExecution.prototype.withDimensions = function () {
        var _a;
        var dim = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            dim[_i] = arguments[_i];
        }
        return this.createNew((_a = this.decorated).withDimensions.apply(_a, dim));
    };
    DecoratedPreparedExecution.prototype.withSorting = function () {
        var _a;
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        return this.createNew((_a = this.decorated).withSorting.apply(_a, items));
    };
    DecoratedPreparedExecution.prototype.withDateFormat = function (dateFormat) {
        return this.createNew(this.decorated.withDateFormat(dateFormat));
    };
    DecoratedPreparedExecution.prototype.withExecConfig = function (config) {
        return this.createNew(this.decorated.withExecConfig(config));
    };
    return DecoratedPreparedExecution;
}());
export { DecoratedPreparedExecution };
/**
 * Abstract base class for execution result decorators. Implements delegates to decorated execution. Concrete
 * implementations can override just the functions they are interested in.
 *
 * The prepared execution wrap is needed here because of the transform function which normally creates new
 * instances of prepared execution - and so the decoration needs to be maintained.
 *
 * @alpha
 */
var DecoratedExecutionResult = /** @class */ (function () {
    function DecoratedExecutionResult(decorated, wrapper) {
        if (wrapper === void 0) { wrapper = identity; }
        this.decorated = decorated;
        this.wrapper = wrapper;
        this.definition = decorated.definition;
        this.dimensions = decorated.dimensions;
    }
    DecoratedExecutionResult.prototype.export = function (options) {
        return this.decorated.export(options);
    };
    DecoratedExecutionResult.prototype.readAll = function () {
        return this.decorated.readAll();
    };
    DecoratedExecutionResult.prototype.readWindow = function (offset, size) {
        return this.decorated.readWindow(offset, size);
    };
    DecoratedExecutionResult.prototype.transform = function () {
        return this.wrapper(this.decorated.transform());
    };
    DecoratedExecutionResult.prototype.equals = function (other) {
        return this.decorated.equals(other);
    };
    DecoratedExecutionResult.prototype.fingerprint = function () {
        return this.decorated.fingerprint();
    };
    return DecoratedExecutionResult;
}());
export { DecoratedExecutionResult };
/**
 * Abstract base class for data view decorators. Implements delegates to decorated data view. Concrete
 * implementations can override just the functions they are interested in.
 *
 * @alpha
 */
var DecoratedDataView = /** @class */ (function () {
    function DecoratedDataView(decorated, result) {
        this.decorated = decorated;
        this.result = result !== null && result !== void 0 ? result : decorated.result;
        this.count = decorated.count;
        this.data = decorated.data;
        this.definition = decorated.definition;
        this.headerItems = decorated.headerItems;
        this.offset = decorated.offset;
        this.totalCount = decorated.totalCount;
        this.totals = decorated.totals;
        this.warnings = decorated.warnings;
    }
    DecoratedDataView.prototype.equals = function (other) {
        return this.decorated.equals(other);
    };
    DecoratedDataView.prototype.fingerprint = function () {
        return this.decorated.fingerprint();
    };
    return DecoratedDataView;
}());
export { DecoratedDataView };
//# sourceMappingURL=execution.js.map