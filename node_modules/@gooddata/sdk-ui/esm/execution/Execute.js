import { __assign, __read } from "tslib";
// (C) 2019 GoodData Corporation
import React from "react";
import { withExecution } from "./withExecution";
import isEqual from "lodash/isEqual";
import { useResolveValuesWithPlaceholders, withContexts, } from "../base";
import { createExecution } from "./createExecution";
var CoreExecute = function (props) {
    var children = props.children, error = props.error, isLoading = props.isLoading, reload = props.reload, result = props.result, LoadingComponent = props.LoadingComponent, ErrorComponent = props.ErrorComponent;
    if (ErrorComponent && error) {
        return React.createElement(ErrorComponent, { error: error });
    }
    if (LoadingComponent && isLoading) {
        return React.createElement(LoadingComponent, null);
    }
    if (LoadingComponent && ErrorComponent && !result) {
        return null;
    }
    return children({
        error: error,
        isLoading: isLoading,
        reload: reload,
        result: result,
    });
};
function componentName(props) {
    return props.componentName || "Execute";
}
function exportTitle(props) {
    return props.exportTitle || componentName(props);
}
var WrappedExecute = withContexts(withExecution({
    exportTitle: exportTitle,
    execution: function (props) {
        var seriesBy = props.seriesBy, slicesBy = props.slicesBy, totals = props.totals, filters = props.filters, sortBy = props.sortBy;
        return createExecution(__assign(__assign({}, props), { componentName: componentName(props), seriesBy: seriesBy, slicesBy: slicesBy, totals: totals, filters: filters, sortBy: sortBy }));
    },
    events: function (props) {
        var onError = props.onError, onLoadingChanged = props.onLoadingChanged, onLoadingFinish = props.onLoadingFinish, onLoadingStart = props.onLoadingStart, onExportReady = props.onExportReady;
        return {
            onError: onError,
            onLoadingChanged: onLoadingChanged,
            onLoadingFinish: onLoadingFinish,
            onLoadingStart: onLoadingStart,
            onExportReady: onExportReady,
        };
    },
    shouldRefetch: function (prevProps, nextProps) {
        var relevantProps = [
            "onError",
            "onLoadingChanged",
            "onLoadingFinish",
            "onLoadingStart",
        ];
        var relevantPropsDeepEqual = [
            "seriesBy",
            "slicesBy",
            "totals",
            "filters",
            "sortBy",
            "window",
        ];
        return (relevantProps.some(function (propName) { return prevProps[propName] !== nextProps[propName]; }) ||
            relevantPropsDeepEqual.some(function (propName) { return !isEqual(prevProps[propName], nextProps[propName]); }));
    },
    loadOnMount: function (props) {
        var _a = (props !== null && props !== void 0 ? props : {}).loadOnMount, loadOnMount = _a === void 0 ? true : _a;
        return loadOnMount;
    },
    window: function (props) { return props.window; },
})(CoreExecute));
/**
 * The executor provides a more curated experience to obtain and work with data from backends. It is aligned
 * with the `DataAccess` infrastructure which exposes the underlying data as data series that can be
 * optionally sliced by additional attributes.
 *
 * Once the executor finishes, the {@link DataViewFacade.data} method will expose the data as series and
 * slices according to the specification to the executor.
 * Note that if the resulting data is empty this will NOT throw a NoDataError. It is the responsibility
 * of the child component to handle that if they need to.
 *
 * @remarks see {@link IDataAccessMethods} for additional documentation
 * @public
 */
export var Execute = function (props) {
    var _a = __read(useResolveValuesWithPlaceholders([props.seriesBy, props.slicesBy, props.totals, props.filters, props.sortBy], props.placeholdersResolutionContext), 5), seriesBy = _a[0], slicesBy = _a[1], totals = _a[2], filters = _a[3], sortBy = _a[4];
    return React.createElement(WrappedExecute, __assign({}, props, { seriesBy: seriesBy, slicesBy: slicesBy, totals: totals, filters: filters, sortBy: sortBy }));
};
//# sourceMappingURL=Execute.js.map