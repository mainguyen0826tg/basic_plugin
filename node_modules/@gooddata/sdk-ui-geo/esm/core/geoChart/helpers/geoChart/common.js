// (C) 2019-2021 GoodData Corporation
import { BucketNames } from "@gooddata/sdk-ui";
import { bucketIsEmpty, bucketsFind } from "@gooddata/sdk-model";
import isEqual from "lodash/isEqual";
import { getResponsiveInfo } from "./responsive";
export function getGeoAttributeHeaderItems(dv, geoData) {
    var color = geoData.color, size = geoData.size;
    var hasColorMeasure = color !== undefined;
    var hasSizeMeasure = size !== undefined;
    var attrHeaderItemIndex = hasColorMeasure || hasSizeMeasure ? 1 : 0;
    return dv.meta().allHeaders()[attrHeaderItemIndex];
}
export function isDataOfReasonableSize(dv, geoData, limit) {
    var location = geoData.location;
    var attributeHeaderItems = getGeoAttributeHeaderItems(dv, geoData);
    var locationData = location !== undefined ? attributeHeaderItems[location.index] : [];
    return locationData.length <= limit;
}
export function isLocationMissing(buckets) {
    var locationBucket = bucketsFind(buckets, BucketNames.LOCATION);
    return !locationBucket || bucketIsEmpty(locationBucket);
}
export function calculateAverage(values) {
    if (values === void 0) { values = []; }
    if (!values.length) {
        return 0;
    }
    return values.reduce(function (a, b) { return a + b; }, 0) / values.length;
}
export function getFormatFromExecutionResponse(dv, indexMeasure) {
    var measureDescriptors = dv.meta().measureDescriptors();
    return measureDescriptors[indexMeasure].measureHeaderItem.format;
}
// show clusters when there is location attribute only
export function isClusteringAllowed(geoData, groupNearbyPoints) {
    if (groupNearbyPoints === void 0) { groupNearbyPoints = true; }
    var color = geoData.color, location = geoData.location, segment = geoData.segment, size = geoData.size;
    return Boolean(groupNearbyPoints && location && !(color || segment || size));
}
export function isPointsConfigChanged(prevPointsConfig, pointsConfig) {
    return !isEqual(prevPointsConfig, pointsConfig);
}
/**
 * Get min/max values in number array and ignore NaN values
 * @param data
 */
export function getMinMax(data) {
    return data.reduce(function (result, value) {
        if (!isFinite(value)) {
            return result;
        }
        var min = result.min && isFinite(result.min) ? Math.min(value, result.min) : value;
        var max = result.max && isFinite(result.max) ? Math.max(value, result.max) : value;
        return {
            min: min,
            max: max
        };
    }, {
        min: undefined,
        max: undefined
    });
}
export function dataValueAsFloat(value) {
    if (value === null) {
        return NaN;
    }
    var parsedNumber = typeof value === "string" ? parseFloat(value) : value;
    if (isNaN(parsedNumber)) {
        // eslint-disable-next-line no-console
        console.warn("SDK: utils - stringToFloat: " + value + " is not a number");
    }
    return parsedNumber;
}
export function isFluidLegendEnabled(responsive, showFluidLegend) {
    return getResponsiveInfo(responsive) === true && showFluidLegend;
}
export function isColorAssignmentItemChanged(prevColorAssignment, colorAssignment) {
    return !isEqual(prevColorAssignment, colorAssignment);
}
//# sourceMappingURL=common.js.map