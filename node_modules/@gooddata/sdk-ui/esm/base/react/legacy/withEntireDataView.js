// (C) 2019 GoodData Corporation
import { __assign, __awaiter, __extends, __generator } from "tslib";
import { isNoDataError, isUnexpectedResponseError, } from "@gooddata/sdk-backend-spi";
import { defFingerprint } from "@gooddata/sdk-model";
import React from "react";
import { injectIntl } from "react-intl";
import noop from "lodash/noop";
import omit from "lodash/omit";
import { DataTooLargeToDisplaySdkError, NegativeValuesSdkError, } from "../../errors/GoodDataSdkError";
import { createExportErrorFunction, createExportFunction } from "../../vis/export";
import { DataViewFacade } from "../../results/facade";
import { convertError } from "../../errors/errorHandling";
import { IntlWrapper } from "../../localization/IntlWrapper";
import { getAvailableDrillTargets } from "./availableDrillTargets";
/**
 * A HOC to wrap data visualization components with loading / error handling.
 *
 * Note: this is a legacy HOC with a long history. In v7 we had VisualizationLoadingHOC - that one was used for
 * all components and was linked to AFM and the paging and everything. We took this and gutted it out, changed to
 * work with executions and to only support reading all the data.
 *
 * @param InnerComponent - component to wrap
 * @internal
 */
export function withEntireDataView(InnerComponent) {
    var LoadingHOCWrapped = /** @class */ (function (_super) {
        __extends(LoadingHOCWrapped, _super);
        function LoadingHOCWrapped(props) {
            var _this = _super.call(this, props) || this;
            _this.hasUnmounted = false;
            /**
             * Fingerprint of the last execution definition the initialize was called with.
             */
            _this.lastInitRequestFingerprint = null;
            _this.stripWorkspace = function (props) {
                return omit(props, ["workspace"]);
            };
            _this.state = {
                isLoading: false,
                error: null,
                executionResult: null,
                dataView: null,
            };
            _this.onLoadingChanged = _this.onLoadingChanged.bind(_this);
            _this.onDataTooLarge = _this.onDataTooLarge.bind(_this);
            _this.onNegativeValues = _this.onNegativeValues.bind(_this);
            return _this;
        }
        LoadingHOCWrapped.prototype.componentDidMount = function () {
            this.initDataLoading(this.props.execution);
        };
        LoadingHOCWrapped.prototype.render = function () {
            var _a = this.state, isLoading = _a.isLoading, error = _a.error, dataView = _a.dataView;
            var intl = this.props.intl;
            // lower-level components do not need workspace
            var props = this.stripWorkspace(this.props);
            return (React.createElement(InnerComponent, __assign({}, props, { dataView: dataView, onDataTooLarge: this.onDataTooLarge, onNegativeValues: this.onNegativeValues, error: error, isLoading: isLoading, intl: intl })));
        };
        LoadingHOCWrapped.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
            //  we need strict equality here in case only the buckets changed (not measures or attributes)
            if (!this.props.execution.equals(nextProps.execution)) {
                this.initDataLoading(nextProps.execution);
            }
        };
        LoadingHOCWrapped.prototype.componentWillUnmount = function () {
            this.hasUnmounted = true;
            this.onLoadingChanged = noop;
            this.onError = noop;
        };
        LoadingHOCWrapped.prototype.onLoadingChanged = function (loadingState) {
            var onLoadingChanged = this.props.onLoadingChanged;
            onLoadingChanged === null || onLoadingChanged === void 0 ? void 0 : onLoadingChanged(loadingState);
            var isLoading = loadingState.isLoading;
            var state = { isLoading: isLoading };
            if (isLoading) {
                state.error = null;
            }
            this.setState(state);
        };
        LoadingHOCWrapped.prototype.onError = function (error) {
            var _a, _b;
            var onExportReady = this.props.onExportReady;
            this.setState({ error: error.getMessage(), dataView: null });
            this.onLoadingChanged({ isLoading: false });
            if (onExportReady) {
                onExportReady(createExportErrorFunction(error));
            }
            (_b = (_a = this.props).onError) === null || _b === void 0 ? void 0 : _b.call(_a, error);
        };
        LoadingHOCWrapped.prototype.onDataTooLarge = function () {
            this.onError(new DataTooLargeToDisplaySdkError());
        };
        LoadingHOCWrapped.prototype.onNegativeValues = function () {
            this.onError(new NegativeValuesSdkError());
        };
        LoadingHOCWrapped.prototype.initDataLoading = function (execution) {
            return __awaiter(this, void 0, void 0, function () {
                var _a, onExportReady, pushData, exportTitle, executionResult_1, dataView, availableDrillTargets, error_1, availableDrillTargets;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            _a = this.props, onExportReady = _a.onExportReady, pushData = _a.pushData, exportTitle = _a.exportTitle;
                            this.onLoadingChanged({ isLoading: true });
                            this.setState({ dataView: null });
                            this.lastInitRequestFingerprint = defFingerprint(execution.definition);
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 4, , 5]);
                            return [4 /*yield*/, execution.execute()];
                        case 2:
                            executionResult_1 = _b.sent();
                            if (this.lastInitRequestFingerprint !== defFingerprint(execution.definition)) {
                                return [2 /*return*/];
                            }
                            if (this.hasUnmounted) {
                                return [2 /*return*/];
                            }
                            return [4 /*yield*/, executionResult_1.readAll().catch(function (err) {
                                    /**
                                     * When execution result is received successfully,
                                     * but data load fails with unexpected http response,
                                     * we still want to push availableDrillTargets
                                     */
                                    if (isUnexpectedResponseError(err) && pushData) {
                                        var availableDrillTargets = getAvailableDrillTargets(DataViewFacade.forResult(executionResult_1));
                                        pushData({ availableDrillTargets: availableDrillTargets });
                                    }
                                    throw err;
                                })];
                        case 3:
                            dataView = _b.sent();
                            if (this.hasUnmounted) {
                                return [2 /*return*/];
                            }
                            if (this.lastInitRequestFingerprint !== defFingerprint(dataView.definition)) {
                                /*
                                 * Stop right now if the data are not relevant anymore because there was another
                                 * initialize request in the meantime.
                                 */
                                return [2 /*return*/];
                            }
                            this.setState({ dataView: dataView, error: null, executionResult: executionResult_1 });
                            this.onLoadingChanged({ isLoading: false });
                            if (onExportReady) {
                                onExportReady(createExportFunction(dataView.result, exportTitle));
                            }
                            if (pushData) {
                                availableDrillTargets = getAvailableDrillTargets(DataViewFacade.for(dataView));
                                pushData({ dataView: dataView, availableDrillTargets: availableDrillTargets });
                            }
                            return [3 /*break*/, 5];
                        case 4:
                            error_1 = _b.sent();
                            if (this.lastInitRequestFingerprint !== defFingerprint(execution.definition)) {
                                return [2 /*return*/];
                            }
                            if (this.hasUnmounted) {
                                return [2 /*return*/];
                            }
                            /*
                             * There can be situations, where there is no data to visualize but the result / dataView contains
                             * metadata essential for setup of drilling. Look for that and if available push up.
                             */
                            if (isNoDataError(error_1) && error_1.dataView && pushData) {
                                availableDrillTargets = getAvailableDrillTargets(DataViewFacade.for(error_1.dataView));
                                pushData({ availableDrillTargets: availableDrillTargets });
                            }
                            this.onError(convertError(error_1));
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        LoadingHOCWrapped.defaultProps = InnerComponent.defaultProps || {};
        return LoadingHOCWrapped;
    }(React.Component));
    var IntlLoadingHOC = injectIntl(LoadingHOCWrapped);
    return /** @class */ (function (_super) {
        __extends(LoadingHOC, _super);
        function LoadingHOC() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        LoadingHOC.prototype.render = function () {
            return (React.createElement(IntlWrapper, { locale: this.props.locale },
                React.createElement(IntlLoadingHOC, __assign({}, this.props))));
        };
        return LoadingHOC;
    }(React.Component));
}
//# sourceMappingURL=withEntireDataView.js.map