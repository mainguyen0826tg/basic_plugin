// (C) 2021 GoodData Corporation
import { __assign, __extends } from "tslib";
/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
// @ts-ignore
import globalImportUrl from "url";
import globalImportQs from "qs";
import globalAxios from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from "./base";
// utility function that adds support for nested objects in query
var addFlattenedObjectTo = function (object, target) {
    var flattened = globalImportQs.parse(globalImportQs.stringify(object, { allowDots: true }), {
        depth: 0,
    });
    Object.keys(flattened).forEach(function (key) {
        target[key] = flattened[key];
    });
};
/**
 * @export
 * @enum {string}
 */
export var AfmValidObjectsQueryTypesEnum;
(function (AfmValidObjectsQueryTypesEnum) {
    AfmValidObjectsQueryTypesEnum["Facts"] = "facts";
    AfmValidObjectsQueryTypesEnum["Attributes"] = "attributes";
    AfmValidObjectsQueryTypesEnum["Measures"] = "measures";
    AfmValidObjectsQueryTypesEnum["UNRECOGNIZED"] = "UNRECOGNIZED";
})(AfmValidObjectsQueryTypesEnum || (AfmValidObjectsQueryTypesEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum;
(function (ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum) {
    ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum["SUM"] = "SUM";
    ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum["DIFFERENCE"] = "DIFFERENCE";
    ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum["MULTIPLICATION"] = "MULTIPLICATION";
    ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum["RATIO"] = "RATIO";
    ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum["CHANGE"] = "CHANGE";
})(ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum || (ArithmeticMeasureDefinitionArithmeticMeasureOperatorEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var AttributeHeaderAttributeHeaderGranularityEnum;
(function (AttributeHeaderAttributeHeaderGranularityEnum) {
    AttributeHeaderAttributeHeaderGranularityEnum["YEAR"] = "YEAR";
    AttributeHeaderAttributeHeaderGranularityEnum["DAY"] = "DAY";
    AttributeHeaderAttributeHeaderGranularityEnum["HOUR"] = "HOUR";
    AttributeHeaderAttributeHeaderGranularityEnum["MINUTE"] = "MINUTE";
    AttributeHeaderAttributeHeaderGranularityEnum["QUARTER"] = "QUARTER";
    AttributeHeaderAttributeHeaderGranularityEnum["MONTH"] = "MONTH";
    AttributeHeaderAttributeHeaderGranularityEnum["WEEK"] = "WEEK";
    AttributeHeaderAttributeHeaderGranularityEnum["QUARTEROFYEAR"] = "QUARTER_OF_YEAR";
    AttributeHeaderAttributeHeaderGranularityEnum["MONTHOFYEAR"] = "MONTH_OF_YEAR";
    AttributeHeaderAttributeHeaderGranularityEnum["DAYOFYEAR"] = "DAY_OF_YEAR";
    AttributeHeaderAttributeHeaderGranularityEnum["DAYOFWEEK"] = "DAY_OF_WEEK";
    AttributeHeaderAttributeHeaderGranularityEnum["DAYOFMONTH"] = "DAY_OF_MONTH";
    AttributeHeaderAttributeHeaderGranularityEnum["HOUROFDAY"] = "HOUR_OF_DAY";
    AttributeHeaderAttributeHeaderGranularityEnum["MINUTEOFHOUR"] = "MINUTE_OF_HOUR";
    AttributeHeaderAttributeHeaderGranularityEnum["WEEKOFYEAR"] = "WEEK_OF_YEAR";
})(AttributeHeaderAttributeHeaderGranularityEnum || (AttributeHeaderAttributeHeaderGranularityEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var ComparisonMeasureValueFilterBodyOperatorEnum;
(function (ComparisonMeasureValueFilterBodyOperatorEnum) {
    ComparisonMeasureValueFilterBodyOperatorEnum["GREATERTHAN"] = "GREATER_THAN";
    ComparisonMeasureValueFilterBodyOperatorEnum["GREATERTHANOREQUALTO"] = "GREATER_THAN_OR_EQUAL_TO";
    ComparisonMeasureValueFilterBodyOperatorEnum["LESSTHAN"] = "LESS_THAN";
    ComparisonMeasureValueFilterBodyOperatorEnum["LESSTHANOREQUALTO"] = "LESS_THAN_OR_EQUAL_TO";
    ComparisonMeasureValueFilterBodyOperatorEnum["EQUALTO"] = "EQUAL_TO";
    ComparisonMeasureValueFilterBodyOperatorEnum["NOTEQUALTO"] = "NOT_EQUAL_TO";
})(ComparisonMeasureValueFilterBodyOperatorEnum || (ComparisonMeasureValueFilterBodyOperatorEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var ComparisonMeasureValueFilterBodyAllOfOperatorEnum;
(function (ComparisonMeasureValueFilterBodyAllOfOperatorEnum) {
    ComparisonMeasureValueFilterBodyAllOfOperatorEnum["GREATERTHAN"] = "GREATER_THAN";
    ComparisonMeasureValueFilterBodyAllOfOperatorEnum["GREATERTHANOREQUALTO"] = "GREATER_THAN_OR_EQUAL_TO";
    ComparisonMeasureValueFilterBodyAllOfOperatorEnum["LESSTHAN"] = "LESS_THAN";
    ComparisonMeasureValueFilterBodyAllOfOperatorEnum["LESSTHANOREQUALTO"] = "LESS_THAN_OR_EQUAL_TO";
    ComparisonMeasureValueFilterBodyAllOfOperatorEnum["EQUALTO"] = "EQUAL_TO";
    ComparisonMeasureValueFilterBodyAllOfOperatorEnum["NOTEQUALTO"] = "NOT_EQUAL_TO";
})(ComparisonMeasureValueFilterBodyAllOfOperatorEnum || (ComparisonMeasureValueFilterBodyAllOfOperatorEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var ElementsRequestSortOrderEnum;
(function (ElementsRequestSortOrderEnum) {
    ElementsRequestSortOrderEnum["ASC"] = "ASC";
    ElementsRequestSortOrderEnum["DESC"] = "DESC";
})(ElementsRequestSortOrderEnum || (ElementsRequestSortOrderEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var RangeMeasureValueFilterBodyOperatorEnum;
(function (RangeMeasureValueFilterBodyOperatorEnum) {
    RangeMeasureValueFilterBodyOperatorEnum["BETWEEN"] = "BETWEEN";
    RangeMeasureValueFilterBodyOperatorEnum["NOTBETWEEN"] = "NOT_BETWEEN";
})(RangeMeasureValueFilterBodyOperatorEnum || (RangeMeasureValueFilterBodyOperatorEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var RangeMeasureValueFilterBodyAllOfOperatorEnum;
(function (RangeMeasureValueFilterBodyAllOfOperatorEnum) {
    RangeMeasureValueFilterBodyAllOfOperatorEnum["BETWEEN"] = "BETWEEN";
    RangeMeasureValueFilterBodyAllOfOperatorEnum["NOTBETWEEN"] = "NOT_BETWEEN";
})(RangeMeasureValueFilterBodyAllOfOperatorEnum || (RangeMeasureValueFilterBodyAllOfOperatorEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var RankingFilterBodyOperatorEnum;
(function (RankingFilterBodyOperatorEnum) {
    RankingFilterBodyOperatorEnum["TOP"] = "TOP";
    RankingFilterBodyOperatorEnum["BOTTOM"] = "BOTTOM";
})(RankingFilterBodyOperatorEnum || (RankingFilterBodyOperatorEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var RankingFilterBodyAllOfOperatorEnum;
(function (RankingFilterBodyAllOfOperatorEnum) {
    RankingFilterBodyAllOfOperatorEnum["TOP"] = "TOP";
    RankingFilterBodyAllOfOperatorEnum["BOTTOM"] = "BOTTOM";
})(RankingFilterBodyAllOfOperatorEnum || (RankingFilterBodyAllOfOperatorEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var RelativeDateFilterBodyGranularityEnum;
(function (RelativeDateFilterBodyGranularityEnum) {
    RelativeDateFilterBodyGranularityEnum["MINUTE"] = "MINUTE";
    RelativeDateFilterBodyGranularityEnum["HOUR"] = "HOUR";
    RelativeDateFilterBodyGranularityEnum["DAY"] = "DAY";
    RelativeDateFilterBodyGranularityEnum["WEEK"] = "WEEK";
    RelativeDateFilterBodyGranularityEnum["MONTH"] = "MONTH";
    RelativeDateFilterBodyGranularityEnum["QUARTER"] = "QUARTER";
    RelativeDateFilterBodyGranularityEnum["YEAR"] = "YEAR";
    RelativeDateFilterBodyGranularityEnum["MINUTEOFHOUR"] = "MINUTE_OF_HOUR";
    RelativeDateFilterBodyGranularityEnum["HOUROFDAY"] = "HOUR_OF_DAY";
    RelativeDateFilterBodyGranularityEnum["DAYOFWEEK"] = "DAY_OF_WEEK";
    RelativeDateFilterBodyGranularityEnum["DAYOFMONTH"] = "DAY_OF_MONTH";
    RelativeDateFilterBodyGranularityEnum["DAYOFYEAR"] = "DAY_OF_YEAR";
    RelativeDateFilterBodyGranularityEnum["WEEKOFYEAR"] = "WEEK_OF_YEAR";
    RelativeDateFilterBodyGranularityEnum["MONTHOFYEAR"] = "MONTH_OF_YEAR";
    RelativeDateFilterBodyGranularityEnum["QUARTEROFYEAR"] = "QUARTER_OF_YEAR";
})(RelativeDateFilterBodyGranularityEnum || (RelativeDateFilterBodyGranularityEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var RelativeDateFilterBodyAllOfGranularityEnum;
(function (RelativeDateFilterBodyAllOfGranularityEnum) {
    RelativeDateFilterBodyAllOfGranularityEnum["MINUTE"] = "MINUTE";
    RelativeDateFilterBodyAllOfGranularityEnum["HOUR"] = "HOUR";
    RelativeDateFilterBodyAllOfGranularityEnum["DAY"] = "DAY";
    RelativeDateFilterBodyAllOfGranularityEnum["WEEK"] = "WEEK";
    RelativeDateFilterBodyAllOfGranularityEnum["MONTH"] = "MONTH";
    RelativeDateFilterBodyAllOfGranularityEnum["QUARTER"] = "QUARTER";
    RelativeDateFilterBodyAllOfGranularityEnum["YEAR"] = "YEAR";
    RelativeDateFilterBodyAllOfGranularityEnum["MINUTEOFHOUR"] = "MINUTE_OF_HOUR";
    RelativeDateFilterBodyAllOfGranularityEnum["HOUROFDAY"] = "HOUR_OF_DAY";
    RelativeDateFilterBodyAllOfGranularityEnum["DAYOFWEEK"] = "DAY_OF_WEEK";
    RelativeDateFilterBodyAllOfGranularityEnum["DAYOFMONTH"] = "DAY_OF_MONTH";
    RelativeDateFilterBodyAllOfGranularityEnum["DAYOFYEAR"] = "DAY_OF_YEAR";
    RelativeDateFilterBodyAllOfGranularityEnum["WEEKOFYEAR"] = "WEEK_OF_YEAR";
    RelativeDateFilterBodyAllOfGranularityEnum["MONTHOFYEAR"] = "MONTH_OF_YEAR";
    RelativeDateFilterBodyAllOfGranularityEnum["QUARTEROFYEAR"] = "QUARTER_OF_YEAR";
})(RelativeDateFilterBodyAllOfGranularityEnum || (RelativeDateFilterBodyAllOfGranularityEnum = {}));
/**
 * @export
 * @enum {string}
 */
export var SimpleMeasureDefinitionMeasureAggregationEnum;
(function (SimpleMeasureDefinitionMeasureAggregationEnum) {
    SimpleMeasureDefinitionMeasureAggregationEnum["SUM"] = "SUM";
    SimpleMeasureDefinitionMeasureAggregationEnum["COUNT"] = "COUNT";
    SimpleMeasureDefinitionMeasureAggregationEnum["APPROXIMATECOUNT"] = "APPROXIMATE_COUNT";
    SimpleMeasureDefinitionMeasureAggregationEnum["AVG"] = "AVG";
    SimpleMeasureDefinitionMeasureAggregationEnum["MIN"] = "MIN";
    SimpleMeasureDefinitionMeasureAggregationEnum["MAX"] = "MAX";
    SimpleMeasureDefinitionMeasureAggregationEnum["MEDIAN"] = "MEDIAN";
    SimpleMeasureDefinitionMeasureAggregationEnum["RUNSUM"] = "RUNSUM";
})(SimpleMeasureDefinitionMeasureAggregationEnum || (SimpleMeasureDefinitionMeasureAggregationEnum = {}));
/**
 * Sorting elements - ascending/descending order.
 * @export
 * @enum {string}
 */
export var SortDirection;
(function (SortDirection) {
    SortDirection["ASC"] = "ASC";
    SortDirection["DESC"] = "DESC";
})(SortDirection || (SortDirection = {}));
/**
 * Sorting elements - ascending/descending order.
 * @export
 * @enum {string}
 */
export var TotalFunction;
(function (TotalFunction) {
    TotalFunction["SUM"] = "SUM";
    TotalFunction["MIN"] = "MIN";
    TotalFunction["MAX"] = "MAX";
    TotalFunction["AVG"] = "AVG";
    TotalFunction["MED"] = "MED";
})(TotalFunction || (TotalFunction = {}));
/**
 * ActionsApi - axios parameter creator
 * @export
 */
export var ActionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {Array<string>} [exactFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title exactly matches one of &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60;.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {number} [dataSamplingPercentage] Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElements: function (params, options) {
            if (options === void 0) { options = {}; }
            var workspaceId = params.workspaceId, label = params.label, sortOrder = params.sortOrder, complementFilter = params.complementFilter, patternFilter = params.patternFilter, exactFilter = params.exactFilter, offset = params.offset, limit = params.limit, dataSamplingPercentage = params.dataSamplingPercentage, skipCache = params.skipCache;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError("workspaceId", "Required parameter workspaceId was null or undefined when calling computeLabelElements.");
            }
            // verify required parameter 'label' is not null or undefined
            if (label === null || label === undefined) {
                throw new RequiredError("label", "Required parameter label was null or undefined when calling computeLabelElements.");
            }
            var localVarPath = "/api/actions/workspaces/{workspaceId}/execution/collectLabelElements".replace("{" + "workspaceId" + "}", encodeURIComponent(String(workspaceId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign(__assign({ method: "GET" }, baseOptions), options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (label !== undefined) {
                if (typeof label === "object") {
                    addFlattenedObjectTo(label, localVarQueryParameter);
                }
                else {
                    localVarQueryParameter["label"] = label;
                }
            }
            if (sortOrder !== undefined) {
                if (typeof sortOrder === "object") {
                    addFlattenedObjectTo(sortOrder, localVarQueryParameter);
                }
                else {
                    localVarQueryParameter["sortOrder"] = sortOrder;
                }
            }
            if (complementFilter !== undefined) {
                if (typeof complementFilter === "object") {
                    addFlattenedObjectTo(complementFilter, localVarQueryParameter);
                }
                else {
                    localVarQueryParameter["complementFilter"] = complementFilter;
                }
            }
            if (patternFilter !== undefined) {
                if (typeof patternFilter === "object") {
                    addFlattenedObjectTo(patternFilter, localVarQueryParameter);
                }
                else {
                    localVarQueryParameter["patternFilter"] = patternFilter;
                }
            }
            if (exactFilter) {
                localVarQueryParameter["exactFilter"] = exactFilter;
            }
            if (offset !== undefined) {
                if (typeof offset === "object") {
                    addFlattenedObjectTo(offset, localVarQueryParameter);
                }
                else {
                    localVarQueryParameter["offset"] = offset;
                }
            }
            if (limit !== undefined) {
                if (typeof limit === "object") {
                    addFlattenedObjectTo(limit, localVarQueryParameter);
                }
                else {
                    localVarQueryParameter["limit"] = limit;
                }
            }
            if (dataSamplingPercentage !== undefined) {
                if (typeof dataSamplingPercentage === "object") {
                    addFlattenedObjectTo(dataSamplingPercentage, localVarQueryParameter);
                }
                else {
                    localVarQueryParameter["dataSamplingPercentage"] = dataSamplingPercentage;
                }
            }
            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }
            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign(__assign({}, localVarHeaderParameter), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: function (params, options) {
            if (options === void 0) { options = {}; }
            var workspaceId = params.workspaceId, elementsRequest = params.elementsRequest, offset = params.offset, limit = params.limit, skipCache = params.skipCache;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError("workspaceId", "Required parameter workspaceId was null or undefined when calling computeLabelElementsPost.");
            }
            // verify required parameter 'elementsRequest' is not null or undefined
            if (elementsRequest === null || elementsRequest === undefined) {
                throw new RequiredError("elementsRequest", "Required parameter elementsRequest was null or undefined when calling computeLabelElementsPost.");
            }
            var localVarPath = "/api/actions/workspaces/{workspaceId}/execution/collectLabelElements".replace("{" + "workspaceId" + "}", encodeURIComponent(String(workspaceId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign(__assign({ method: "POST" }, baseOptions), options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (offset !== undefined) {
                if (typeof offset === "object") {
                    addFlattenedObjectTo(offset, localVarQueryParameter);
                }
                else {
                    localVarQueryParameter["offset"] = offset;
                }
            }
            if (limit !== undefined) {
                if (typeof limit === "object") {
                    addFlattenedObjectTo(limit, localVarQueryParameter);
                }
                else {
                    localVarQueryParameter["limit"] = limit;
                }
            }
            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign(__assign({}, localVarHeaderParameter), options.headers);
            var needsSerialization = typeof elementsRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(elementsRequest !== undefined ? elementsRequest : {})
                : elementsRequest || "";
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: function (params, options) {
            if (options === void 0) { options = {}; }
            var workspaceId = params.workspaceId, afmExecution = params.afmExecution, skipCache = params.skipCache, timestamp = params.timestamp;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError("workspaceId", "Required parameter workspaceId was null or undefined when calling computeReport.");
            }
            // verify required parameter 'afmExecution' is not null or undefined
            if (afmExecution === null || afmExecution === undefined) {
                throw new RequiredError("afmExecution", "Required parameter afmExecution was null or undefined when calling computeReport.");
            }
            var localVarPath = "/api/actions/workspaces/{workspaceId}/execution/afm/execute".replace("{" + "workspaceId" + "}", encodeURIComponent(String(workspaceId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign(__assign({ method: "POST" }, baseOptions), options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (skipCache !== undefined && skipCache !== null) {
                localVarHeaderParameter["skip-cache"] = String(JSON.stringify(skipCache));
            }
            if (timestamp !== undefined && timestamp !== null) {
                localVarHeaderParameter["timestamp"] = String(timestamp);
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign(__assign({}, localVarHeaderParameter), options.headers);
            var needsSerialization = typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: function (params, options) {
            if (options === void 0) { options = {}; }
            var workspaceId = params.workspaceId, afmValidObjectsQuery = params.afmValidObjectsQuery;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError("workspaceId", "Required parameter workspaceId was null or undefined when calling computeValidObjects.");
            }
            // verify required parameter 'afmValidObjectsQuery' is not null or undefined
            if (afmValidObjectsQuery === null || afmValidObjectsQuery === undefined) {
                throw new RequiredError("afmValidObjectsQuery", "Required parameter afmValidObjectsQuery was null or undefined when calling computeValidObjects.");
            }
            var localVarPath = "/api/actions/workspaces/{workspaceId}/execution/afm/computeValidObjects".replace("{" + "workspaceId" + "}", encodeURIComponent(String(workspaceId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign(__assign({ method: "POST" }, baseOptions), options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign(__assign({}, localVarHeaderParameter), options.headers);
            var needsSerialization = typeof afmValidObjectsQuery !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmValidObjectsQuery !== undefined ? afmValidObjectsQuery : {})
                : afmValidObjectsQuery || "";
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM), and logical and physical models (LDM and PDM) of corresponding workspace.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {string} [explainType] Requested explain type (LDM, PDM or MAQL). If not specified all types are bundled in a ZIP archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: function (params, options) {
            if (options === void 0) { options = {}; }
            var workspaceId = params.workspaceId, afmExecution = params.afmExecution, explainType = params.explainType;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError("workspaceId", "Required parameter workspaceId was null or undefined when calling explainAFM.");
            }
            // verify required parameter 'afmExecution' is not null or undefined
            if (afmExecution === null || afmExecution === undefined) {
                throw new RequiredError("afmExecution", "Required parameter afmExecution was null or undefined when calling explainAFM.");
            }
            var localVarPath = "/api/actions/workspaces/{workspaceId}/execution/afm/explain".replace("{" + "workspaceId" + "}", encodeURIComponent(String(workspaceId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign(__assign({ method: "POST" }, baseOptions), options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (explainType !== undefined) {
                if (typeof explainType === "object") {
                    addFlattenedObjectTo(explainType, localVarQueryParameter);
                }
                else {
                    localVarQueryParameter["explainType"] = explainType;
                }
            }
            localVarHeaderParameter["Content-Type"] = "application/json";
            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign(__assign({}, localVarHeaderParameter), options.headers);
            var needsSerialization = typeof afmExecution !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(afmExecution !== undefined ? afmExecution : {})
                : afmExecution || "";
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: function (params, options) {
            if (options === void 0) { options = {}; }
            var workspaceId = params.workspaceId, resultId = params.resultId, offset = params.offset, limit = params.limit;
            // verify required parameter 'workspaceId' is not null or undefined
            if (workspaceId === null || workspaceId === undefined) {
                throw new RequiredError("workspaceId", "Required parameter workspaceId was null or undefined when calling retrieveResult.");
            }
            // verify required parameter 'resultId' is not null or undefined
            if (resultId === null || resultId === undefined) {
                throw new RequiredError("resultId", "Required parameter resultId was null or undefined when calling retrieveResult.");
            }
            var localVarPath = "/api/actions/workspaces/{workspaceId}/execution/afm/execute/result/{resultId}"
                .replace("{" + "workspaceId" + "}", encodeURIComponent(String(workspaceId)))
                .replace("{" + "resultId" + "}", encodeURIComponent(String(resultId)));
            var localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            var baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            var localVarRequestOptions = __assign(__assign({ method: "GET" }, baseOptions), options);
            var localVarHeaderParameter = {};
            var localVarQueryParameter = {};
            if (offset) {
                localVarQueryParameter["offset"] = offset.join(COLLECTION_FORMATS.csv);
            }
            if (limit) {
                localVarQueryParameter["limit"] = limit.join(COLLECTION_FORMATS.csv);
            }
            localVarUrlObj.query = __assign(__assign(__assign({}, localVarUrlObj.query), localVarQueryParameter), options.query);
            // @ts-ignore fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = __assign(__assign({}, localVarHeaderParameter), options.headers);
            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ActionsApi - functional programming interface
 * @export
 */
export var ActionsApiFp = function (configuration) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {Array<string>} [exactFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title exactly matches one of &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60;.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {number} [dataSamplingPercentage] Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElements: function (params, options) {
            if (options === void 0) { options = {}; }
            var localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).computeLabelElements(params, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = globalAxios; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: function (params, options) {
            if (options === void 0) { options = {}; }
            var localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).computeLabelElementsPost(params, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = globalAxios; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: function (params, options) {
            if (options === void 0) { options = {}; }
            var localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).computeReport(params, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = globalAxios; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: function (params, options) {
            if (options === void 0) { options = {}; }
            var localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).computeValidObjects(params, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = globalAxios; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM), and logical and physical models (LDM and PDM) of corresponding workspace.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {string} [explainType] Requested explain type (LDM, PDM or MAQL). If not specified all types are bundled in a ZIP archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: function (params, options) {
            if (options === void 0) { options = {}; }
            var localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).explainAFM(params, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = globalAxios; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: function (params, options) {
            if (options === void 0) { options = {}; }
            var localVarAxiosArgs = ActionsApiAxiosParamCreator(configuration).retrieveResult(params, options);
            return function (axios, basePath) {
                if (axios === void 0) { axios = globalAxios; }
                if (basePath === void 0) { basePath = BASE_PATH; }
                var axiosRequestArgs = __assign(__assign({}, localVarAxiosArgs.options), { url: basePath + localVarAxiosArgs.url });
                return axios.request(axiosRequestArgs);
            };
        },
    };
};
/**
 * ActionsApi - factory interface
 * @export
 */
export var ActionsApiFactory = function (configuration, basePath, axios) {
    return {
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {string} label Requested label.
         * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
         * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60;
         * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
         * @param {Array<string>} [exactFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title exactly matches one of &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60;.
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {number} [dataSamplingPercentage] Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElements: function (params, options) {
            return ActionsApiFp(configuration).computeLabelElements(params, options)(axios, basePath);
        },
        /**
         * Returns paged list of elements (values) of given label satisfying given filtering criteria.
         * @summary Listing of label values.
         * @param {string} workspaceId Workspace identifier
         * @param {ElementsRequest} elementsRequest
         * @param {number} [offset] Request page with this offset.
         * @param {number} [limit] Return only this number of items.
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeLabelElementsPost: function (params, options) {
            return ActionsApiFp(configuration).computeLabelElementsPost(params, options)(axios, basePath);
        },
        /**
         * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
         * @summary Executes analytical request and returns link to the result
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {boolean} [skipCache] Ignore all caches during execution of current request.
         * @param {string} [timestamp]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeReport: function (params, options) {
            return ActionsApiFp(configuration).computeReport(params, options)(axios, basePath);
        },
        /**
         * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
         * @summary Valid objects
         * @param {string} workspaceId Workspace identifier
         * @param {AfmValidObjectsQuery} afmValidObjectsQuery
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeValidObjects: function (params, options) {
            return ActionsApiFp(configuration).computeValidObjects(params, options)(axios, basePath);
        },
        /**
         * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM), and logical and physical models (LDM and PDM) of corresponding workspace.
         * @summary AFM explain resource.
         * @param {string} workspaceId Workspace identifier
         * @param {AfmExecution} afmExecution
         * @param {string} [explainType] Requested explain type (LDM, PDM or MAQL). If not specified all types are bundled in a ZIP archive.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        explainAFM: function (params, options) {
            return ActionsApiFp(configuration).explainAFM(params, options)(axios, basePath);
        },
        /**
         * Gets a single execution result.
         * @summary Get a single execution result
         * @param {string} workspaceId Workspace identifier
         * @param {string} resultId Result ID
         * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
         * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveResult: function (params, options) {
            return ActionsApiFp(configuration).retrieveResult(params, options)(axios, basePath);
        },
    };
};
/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
var ActionsApi = /** @class */ (function (_super) {
    __extends(ActionsApi, _super);
    function ActionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values.
     * @param {string} workspaceId Workspace identifier
     * @param {string} label Requested label.
     * @param {'ASC' | 'DESC'} [sortOrder] Sort order of returned items. Items are sorted by &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title.
     * @param {boolean} [complementFilter] Inverse filter: * &#x60;&#x60;&#x60;false&#x60;&#x60;&#x60; - return items matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60; * &#x60;&#x60;&#x60;true&#x60;&#x60;&#x60; - return items not matching &#x60;&#x60;&#x60;patternFilter&#x60;&#x60;&#x60; and &#x60;&#x60;&#x60;exactFilter&#x60;&#x60;&#x60;
     * @param {string} [patternFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title case insensitively contains &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60; as substring.
     * @param {Array<string>} [exactFilter] Return only items, whose &#x60;&#x60;&#x60;label&#x60;&#x60;&#x60; title exactly matches one of &#x60;&#x60;&#x60;filter&#x60;&#x60;&#x60;.
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {number} [dataSamplingPercentage] Specifies the percentage of rows from fact datasets to use during computation. This feature is available only for workspaces that use a Vertica Data Source without table views.
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.computeLabelElements = function (params, options) {
        return ActionsApiFp(this.configuration).computeLabelElements(params, options)(this.axios, this.basePath);
    };
    /**
     * Returns paged list of elements (values) of given label satisfying given filtering criteria.
     * @summary Listing of label values.
     * @param {string} workspaceId Workspace identifier
     * @param {ElementsRequest} elementsRequest
     * @param {number} [offset] Request page with this offset.
     * @param {number} [limit] Return only this number of items.
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.computeLabelElementsPost = function (params, options) {
        return ActionsApiFp(this.configuration).computeLabelElementsPost(params, options)(this.axios, this.basePath);
    };
    /**
     * AFM is a combination of attributes, measures and filters that describe a query you want to execute.
     * @summary Executes analytical request and returns link to the result
     * @param {string} workspaceId Workspace identifier
     * @param {AfmExecution} afmExecution
     * @param {boolean} [skipCache] Ignore all caches during execution of current request.
     * @param {string} [timestamp]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.computeReport = function (params, options) {
        return ActionsApiFp(this.configuration).computeReport(params, options)(this.axios, this.basePath);
    };
    /**
     * Returns list containing attributes, facts, or measures, which can be added to given AFM while still keeping it computable.
     * @summary Valid objects
     * @param {string} workspaceId Workspace identifier
     * @param {AfmValidObjectsQuery} afmValidObjectsQuery
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.computeValidObjects = function (params, options) {
        return ActionsApiFp(this.configuration).computeValidObjects(params, options)(this.axios, this.basePath);
    };
    /**
     * The resource provides static structures needed for investigation of a problem with given AFM. The structures are MAQL (internal form of AFM), and logical and physical models (LDM and PDM) of corresponding workspace.
     * @summary AFM explain resource.
     * @param {string} workspaceId Workspace identifier
     * @param {AfmExecution} afmExecution
     * @param {string} [explainType] Requested explain type (LDM, PDM or MAQL). If not specified all types are bundled in a ZIP archive.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.explainAFM = function (params, options) {
        return ActionsApiFp(this.configuration).explainAFM(params, options)(this.axios, this.basePath);
    };
    /**
     * Gets a single execution result.
     * @summary Get a single execution result
     * @param {string} workspaceId Workspace identifier
     * @param {string} resultId Result ID
     * @param {Array<number>} [offset] Request page with these offsets. Format is offset&#x3D;1,2,3,... - one offset for each dimensions in ResultSpec from originating AFM.
     * @param {Array<number>} [limit] Return only this number of items. Format is limit&#x3D;1,2,3,... - one limit for each dimensions in ResultSpec from originating AFM.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.retrieveResult = function (params, options) {
        return ActionsApiFp(this.configuration).retrieveResult(params, options)(this.axios, this.basePath);
    };
    return ActionsApi;
}(BaseAPI));
export { ActionsApi };
//# sourceMappingURL=api.js.map