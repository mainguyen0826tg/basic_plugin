import { __assign, __extends } from "tslib";
// (C) 2020 GoodData Corporation
import React from "react";
import invariant from "ts-invariant";
import { isDataOfReasonableSize } from "./helpers/geoChart/common";
import { getGeoData } from "./helpers/geoChart/data";
import { GeoChartInner } from "./GeoChartInner";
import { DEFAULT_DATA_POINTS_LIMIT } from "./constants/geoChart";
import { DataViewFacade, ErrorCodes, newErrorMapping, ErrorComponent as DefaultErrorComponent, LoadingComponent as DefaultLoadingComponent, } from "@gooddata/sdk-ui";
import { getValidColorPalette, fixEmptyHeaderItems, } from "@gooddata/sdk-ui-vis-commons";
import { getColorStrategy } from "./colorStrategy/geoChart";
import { isResultAttributeHeader } from "@gooddata/sdk-backend-spi";
import "../../../styles/css/main.css";
var GeoChartOptionsWrapper = /** @class */ (function (_super) {
    __extends(GeoChartOptionsWrapper, _super);
    function GeoChartOptionsWrapper(props) {
        var _this = _super.call(this, props) || this;
        _this.buildGeoChartOptions = function (geoData, props) {
            var segment = geoData.segment;
            var _a = props.config, _b = _a === void 0 ? {} : _a, _c = _b.colors, colors = _c === void 0 ? [] : _c, _d = _b.colorPalette, colorPalette = _d === void 0 ? [] : _d, _e = _b.colorMapping, colorMapping = _e === void 0 ? [] : _e, dataView = props.dataView;
            var dv = DataViewFacade["for"](dataView);
            var palette = getValidColorPalette(colors, colorPalette);
            var colorStrategy = getColorStrategy(palette, colorMapping, geoData, dv);
            var categoryItems = [];
            if (segment) {
                categoryItems = _this.getCategoryLegendItems(colorStrategy);
            }
            return {
                geoData: geoData,
                categoryItems: categoryItems,
                colorStrategy: colorStrategy,
                colorPalette: palette
            };
        };
        _this.validateData = function (geoData, props) {
            var _a, _b;
            if (!props.dataView) {
                return;
            }
            var dataView = props.dataView;
            var limit = (_b = (_a = props.config) === null || _a === void 0 ? void 0 : _a.limit) !== null && _b !== void 0 ? _b : DEFAULT_DATA_POINTS_LIMIT;
            var dv = DataViewFacade["for"](dataView);
            return {
                isDataTooLarge: !isDataOfReasonableSize(dv, geoData, limit)
            };
        };
        _this.emptyHeaderString = props.intl.formatMessage({ id: "visualization.emptyValue" });
        _this.errorMap = newErrorMapping(props.intl);
        return _this;
    }
    GeoChartOptionsWrapper.prototype.render = function () {
        var _a, _b;
        var _c = this.props, dataView = _c.dataView, error = _c.error, isLoading = _c.isLoading;
        // if explicitly null, do not default the components to allow them to be disabled
        var ErrorComponent = this.props.ErrorComponent === null ? null : (_a = this.props.ErrorComponent) !== null && _a !== void 0 ? _a : DefaultErrorComponent;
        var LoadingComponent = this.props.LoadingComponent === null
            ? null
            : (_b = this.props.LoadingComponent) !== null && _b !== void 0 ? _b : DefaultLoadingComponent;
        if (error) {
            var errorProps = this.errorMap[Object.prototype.hasOwnProperty.call(this.errorMap, error)
                ? error
                : ErrorCodes.UNKNOWN_ERROR];
            return ErrorComponent ? React.createElement(ErrorComponent, __assign({ code: error }, errorProps)) : null;
        }
        if (isLoading || !dataView) {
            return LoadingComponent ? React.createElement(LoadingComponent, null) : null;
        }
        return this.renderVisualization();
    };
    GeoChartOptionsWrapper.prototype.renderVisualization = function () {
        var sanitizedProps = this.sanitizeProperties();
        var dataView = sanitizedProps.dataView, onDataTooLarge = sanitizedProps.onDataTooLarge;
        var dv = DataViewFacade["for"](dataView);
        var geoData = getGeoData(dv);
        var validationResult = this.validateData(geoData, sanitizedProps);
        if (validationResult && validationResult.isDataTooLarge) {
            invariant(onDataTooLarge, "GeoChart's onDataTooLarge callback is missing.");
            onDataTooLarge();
            return null;
        }
        var geoChartOptions = this.buildGeoChartOptions(geoData, sanitizedProps);
        return React.createElement(GeoChartInner, __assign({}, sanitizedProps, { geoChartOptions: geoChartOptions }));
    };
    GeoChartOptionsWrapper.prototype.getCategoryLegendItems = function (colorStrategy) {
        return createCategoryLegendItems(colorStrategy, this.emptyHeaderString);
    };
    GeoChartOptionsWrapper.prototype.sanitizeProperties = function () {
        var dataView = this.props.dataView;
        fixEmptyHeaderItems(dataView, "(" + this.emptyHeaderString + ")");
        return __assign(__assign({}, this.props), { dataView: dataView });
    };
    return GeoChartOptionsWrapper;
}(React.Component));
export { GeoChartOptionsWrapper };
export function createCategoryLegendItems(colorStrategy, emptyHeaderString) {
    var colorAssignment = colorStrategy.getColorAssignment();
    return colorAssignment.map(function (item, legendIndex) {
        var _a = isResultAttributeHeader(item.headerItem)
            ? item.headerItem.attributeHeaderItem
            : { name: emptyHeaderString, uri: emptyHeaderString }, name = _a.name, uri = _a.uri;
        var color = colorStrategy.getColorByIndex(legendIndex);
        return {
            uri: uri,
            name: name,
            color: color,
            legendIndex: legendIndex,
            isVisible: true
        };
    });
}
//# sourceMappingURL=GeoChartOptionsWrapper.js.map